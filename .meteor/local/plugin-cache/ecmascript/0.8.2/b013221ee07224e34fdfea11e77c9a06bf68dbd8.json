{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./foundation.util.box","imported":["Box"],"specifiers":[{"kind":"named","imported":"Box","local":"Box"}]},{"source":"./foundation.plugin","imported":["Plugin"],"specifiers":[{"kind":"named","imported":"Plugin","local":"Plugin"}]},{"source":"./foundation.util.core","imported":["rtl"],"specifiers":[{"kind":"named","imported":"rtl","local":"Rtl"}]}],"exports":{"exported":["Positionable"],"specifiers":[{"kind":"local","local":"Positionable","exported":"Positionable"}]}}},"options":{"filename":"packages/zurb:foundation-sites/js/foundation.positionable.js","filenameRelative":"packages/zurb:foundation-sites/js/foundation.positionable.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/js/foundation.positionable.js.map","sourceFileName":"packages/zurb:foundation-sites/js/foundation.positionable.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"foundation.positionable"},"ignored":false,"code":"'use strict';\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nmodule.export({\n  Positionable: function () {\n    return Positionable;\n  }\n});\nvar Box = void 0;\nmodule.watch(require(\"./foundation.util.box\"), {\n  Box: function (v) {\n    Box = v;\n  }\n}, 0);\nvar Plugin = void 0;\nmodule.watch(require(\"./foundation.plugin\"), {\n  Plugin: function (v) {\n    Plugin = v;\n  }\n}, 1);\nvar Rtl = void 0;\nmodule.watch(require(\"./foundation.util.core\"), {\n  rtl: function (v) {\n    Rtl = v;\n  }\n}, 2);\nvar POSITIONS = ['left', 'right', 'top', 'bottom'];\nvar VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];\nvar HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];\nvar ALIGNMENTS = {\n  'left': VERTICAL_ALIGNMENTS,\n  'right': VERTICAL_ALIGNMENTS,\n  'top': HORIZONTAL_ALIGNMENTS,\n  'bottom': HORIZONTAL_ALIGNMENTS\n};\n\nfunction nextItem(item, array) {\n  var currentIdx = array.indexOf(item);\n\n  if (currentIdx === array.length - 1) {\n    return array[0];\n  } else {\n    return array[currentIdx + 1];\n  }\n}\n\nvar Positionable = function (_Plugin) {\n  (0, _inherits3.default)(Positionable, _Plugin);\n\n  function Positionable() {\n    (0, _classCallCheck3.default)(this, Positionable);\n    return (0, _possibleConstructorReturn3.default)(this, _Plugin.apply(this, arguments));\n  }\n\n  /**\n   * Abstract class encapsulating the tether-like explicit positioning logic\n   * including repositioning based on overlap.\n   * Expects classes to define defaults for vOffset, hOffset, position,\n   * alignment, allowOverlap, and allowBottomOverlap. They can do this by\n   * extending the defaults, or (for now recommended due to the way docs are\n   * generated) by explicitly declaring them.\n   *\n   **/Positionable.prototype._init = function () {\n    function _init() {\n      this.triedPositions = {};\n      this.position = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;\n      this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;\n    }\n\n    return _init;\n  }();\n\n  Positionable.prototype._getDefaultPosition = function () {\n    function _getDefaultPosition() {\n      return 'bottom';\n    }\n\n    return _getDefaultPosition;\n  }();\n\n  Positionable.prototype._getDefaultAlignment = function () {\n    function _getDefaultAlignment() {\n      switch (this.position) {\n        case 'bottom':\n        case 'top':\n          return Rtl() ? 'right' : 'left';\n\n        case 'left':\n        case 'right':\n          return 'bottom';\n      }\n    }\n\n    return _getDefaultAlignment;\n  }(); /**\n        * Adjusts the positionable possible positions by iterating through alignments\n        * and positions.\n        * @function\n        * @private\n        */\n\n  Positionable.prototype._reposition = function () {\n    function _reposition() {\n      if (this._alignmentsExhausted(this.position)) {\n        this.position = nextItem(this.position, POSITIONS);\n        this.alignment = ALIGNMENTS[this.position][0];\n      } else {\n        this._realign();\n      }\n    }\n\n    return _reposition;\n  }(); /**\n        * Adjusts the dropdown pane possible positions by iterating through alignments\n        * on the current position.\n        * @function\n        * @private\n        */\n\n  Positionable.prototype._realign = function () {\n    function _realign() {\n      this._addTriedPosition(this.position, this.alignment);\n\n      this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position]);\n    }\n\n    return _realign;\n  }();\n\n  Positionable.prototype._addTriedPosition = function () {\n    function _addTriedPosition(position, alignment) {\n      this.triedPositions[position] = this.triedPositions[position] || [];\n      this.triedPositions[position].push(alignment);\n    }\n\n    return _addTriedPosition;\n  }();\n\n  Positionable.prototype._positionsExhausted = function () {\n    function _positionsExhausted() {\n      var isExhausted = true;\n\n      for (var i = 0; i < POSITIONS.length; i++) {\n        isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);\n      }\n\n      return isExhausted;\n    }\n\n    return _positionsExhausted;\n  }();\n\n  Positionable.prototype._alignmentsExhausted = function () {\n    function _alignmentsExhausted(position) {\n      return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;\n    }\n\n    return _alignmentsExhausted;\n  }(); // When we're trying to center, we don't want to apply offset that's going to\n  // take us just off center, so wrap around to return 0 for the appropriate\n  // offset in those alignments.  TODO: Figure out if we want to make this\n  // configurable behavior... it feels more intuitive, especially for tooltips, but\n  // it's possible someone might actually want to start from center and then nudge\n  // slightly off.\n\n\n  Positionable.prototype._getVOffset = function () {\n    function _getVOffset() {\n      return this.options.vOffset;\n    }\n\n    return _getVOffset;\n  }();\n\n  Positionable.prototype._getHOffset = function () {\n    function _getHOffset() {\n      return this.options.hOffset;\n    }\n\n    return _getHOffset;\n  }();\n\n  Positionable.prototype._setPosition = function () {\n    function _setPosition($anchor, $element, $parent) {\n      if ($anchor.attr('aria-expanded') === 'false') {\n        return false;\n      }\n\n      var $eleDims = Box.GetDimensions($element),\n          $anchorDims = Box.GetDimensions($anchor);\n      $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n\n      if (!this.options.allowOverlap) {\n        var overlaps = {};\n        var minOverlap = 100000000; // default coordinates to how we start, in case we can't figure out better\n\n        var minCoordinates = {\n          position: this.position,\n          alignment: this.alignment\n        };\n\n        while (!this._positionsExhausted()) {\n          var overlap = Box.OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);\n\n          if (overlap === 0) {\n            return;\n          }\n\n          if (overlap < minOverlap) {\n            minOverlap = overlap;\n            minCoordinates = {\n              position: this.position,\n              alignment: this.alignment\n            };\n          }\n\n          this._reposition();\n\n          $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n        } // If we get through the entire loop, there was no non-overlapping\n        // position available. Pick the version with least overlap.\n\n\n        this.position = minCoordinates.position;\n        this.alignment = minCoordinates.alignment;\n        $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n      }\n    }\n\n    return _setPosition;\n  }();\n\n  return Positionable;\n}(Plugin);\n\nPositionable.defaults = {\n  /**\n   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */position: 'auto',\n  /**\n   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */alignment: 'auto',\n  /**\n   * Allow overlap of container/window. If false, dropdown positionable first\n   * try to position as defined by data-position and data-alignment, but\n   * reposition if it would cause an overflow.\n   * @option\n   * @type {boolean}\n   * @default false\n   */allowOverlap: false,\n  /**\n   * Allow overlap of only the bottom of the container. This is the most common\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\n   * screen but not otherwise influence or break out of the container.\n   * @option\n   * @type {boolean}\n   * @default true\n   */allowBottomOverlap: true,\n  /**\n   * Number of pixels the positionable should be separated vertically from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */vOffset: 0,\n  /**\n   * Number of pixels the positionable should be separated horizontally from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */hOffset: 0\n};","map":{"version":3,"sources":["packages/zurb:foundation-sites/js/foundation.positionable.js"],"names":["module","export","Positionable","Box","watch","require","v","Plugin","Rtl","rtl","POSITIONS","VERTICAL_ALIGNMENTS","HORIZONTAL_ALIGNMENTS","ALIGNMENTS","nextItem","item","array","currentIdx","indexOf","length","_init","triedPositions","position","options","_getDefaultPosition","alignment","_getDefaultAlignment","_reposition","_alignmentsExhausted","_realign","_addTriedPosition","push","_positionsExhausted","isExhausted","i","_getVOffset","vOffset","_getHOffset","hOffset","_setPosition","$anchor","$element","$parent","attr","$eleDims","GetDimensions","$anchorDims","offset","GetExplicitOffsets","allowOverlap","overlaps","minOverlap","minCoordinates","overlap","OverlapArea","allowBottomOverlap","defaults"],"mappings":"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","file":"packages/zurb:foundation-sites/js/foundation.positionable.js.map","sourcesContent":["'use strict';\n\nimport { Box } from './foundation.util.box';\nimport { Plugin } from './foundation.plugin';\nimport { rtl as Rtl } from './foundation.util.core';\n\nconst POSITIONS = ['left', 'right', 'top', 'bottom'];\nconst VERTICAL_ALIGNMENTS = ['top', 'bottom', 'center'];\nconst HORIZONTAL_ALIGNMENTS = ['left', 'right', 'center'];\n\nconst ALIGNMENTS = {\n  'left': VERTICAL_ALIGNMENTS,\n  'right': VERTICAL_ALIGNMENTS,\n  'top': HORIZONTAL_ALIGNMENTS,\n  'bottom': HORIZONTAL_ALIGNMENTS\n}\n\nfunction nextItem(item, array) {\n  var currentIdx = array.indexOf(item);\n  if(currentIdx === array.length - 1) {\n    return array[0];\n  } else {\n    return array[currentIdx + 1];\n  }\n}\n\n\nclass Positionable extends Plugin {\n  /**\n   * Abstract class encapsulating the tether-like explicit positioning logic\n   * including repositioning based on overlap.\n   * Expects classes to define defaults for vOffset, hOffset, position,\n   * alignment, allowOverlap, and allowBottomOverlap. They can do this by\n   * extending the defaults, or (for now recommended due to the way docs are\n   * generated) by explicitly declaring them.\n   *\n   **/\n\n  _init() {\n    this.triedPositions = {};\n    this.position  = this.options.position === 'auto' ? this._getDefaultPosition() : this.options.position;\n    this.alignment = this.options.alignment === 'auto' ? this._getDefaultAlignment() : this.options.alignment;\n  }\n\n  _getDefaultPosition () {\n    return 'bottom';\n  }\n\n  _getDefaultAlignment() {\n    switch(this.position) {\n      case 'bottom':\n      case 'top':\n        return Rtl() ? 'right' : 'left';\n      case 'left':\n      case 'right':\n        return 'bottom';\n    }\n  }\n\n  /**\n   * Adjusts the positionable possible positions by iterating through alignments\n   * and positions.\n   * @function\n   * @private\n   */\n  _reposition() {\n    if(this._alignmentsExhausted(this.position)) {\n      this.position = nextItem(this.position, POSITIONS);\n      this.alignment = ALIGNMENTS[this.position][0];\n    } else {\n      this._realign();\n    }\n  }\n\n  /**\n   * Adjusts the dropdown pane possible positions by iterating through alignments\n   * on the current position.\n   * @function\n   * @private\n   */\n  _realign() {\n    this._addTriedPosition(this.position, this.alignment)\n    this.alignment = nextItem(this.alignment, ALIGNMENTS[this.position])\n  }\n\n  _addTriedPosition(position, alignment) {\n    this.triedPositions[position] = this.triedPositions[position] || []\n    this.triedPositions[position].push(alignment);\n  }\n\n  _positionsExhausted() {\n    var isExhausted = true;\n    for(var i = 0; i < POSITIONS.length; i++) {\n      isExhausted = isExhausted && this._alignmentsExhausted(POSITIONS[i]);\n    }\n    return isExhausted;\n  }\n\n  _alignmentsExhausted(position) {\n    return this.triedPositions[position] && this.triedPositions[position].length == ALIGNMENTS[position].length;\n  }\n\n\n  // When we're trying to center, we don't want to apply offset that's going to\n  // take us just off center, so wrap around to return 0 for the appropriate\n  // offset in those alignments.  TODO: Figure out if we want to make this\n  // configurable behavior... it feels more intuitive, especially for tooltips, but\n  // it's possible someone might actually want to start from center and then nudge\n  // slightly off.\n  _getVOffset() {\n    return this.options.vOffset;\n  }\n\n  _getHOffset() {\n    return this.options.hOffset;\n  }\n\n\n  _setPosition($anchor, $element, $parent) {\n    if($anchor.attr('aria-expanded') === 'false'){ return false; }\n    var $eleDims = Box.GetDimensions($element),\n        $anchorDims = Box.GetDimensions($anchor);\n\n\n    $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n\n    if(!this.options.allowOverlap) {\n      var overlaps = {};\n      var minOverlap = 100000000;\n      // default coordinates to how we start, in case we can't figure out better\n      var minCoordinates = {position: this.position, alignment: this.alignment};\n      while(!this._positionsExhausted()) {\n        let overlap = Box.OverlapArea($element, $parent, false, false, this.options.allowBottomOverlap);\n        if(overlap === 0) {\n          return;\n        }\n\n        if(overlap < minOverlap) {\n          minOverlap = overlap;\n          minCoordinates = {position: this.position, alignment: this.alignment};\n        }\n\n        this._reposition();\n\n        $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n      }\n      // If we get through the entire loop, there was no non-overlapping\n      // position available. Pick the version with least overlap.\n      this.position = minCoordinates.position;\n      this.alignment = minCoordinates.alignment;\n      $element.offset(Box.GetExplicitOffsets($element, $anchor, this.position, this.alignment, this._getVOffset(), this._getHOffset()));\n    }\n  }\n\n}\n\nPositionable.defaults = {\n  /**\n   * Position of positionable relative to anchor. Can be left, right, bottom, top, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  position: 'auto',\n  /**\n   * Alignment of positionable relative to anchor. Can be left, right, bottom, top, center, or auto.\n   * @option\n   * @type {string}\n   * @default 'auto'\n   */\n  alignment: 'auto',\n  /**\n   * Allow overlap of container/window. If false, dropdown positionable first\n   * try to position as defined by data-position and data-alignment, but\n   * reposition if it would cause an overflow.\n   * @option\n   * @type {boolean}\n   * @default false\n   */\n  allowOverlap: false,\n  /**\n   * Allow overlap of only the bottom of the container. This is the most common\n   * behavior for dropdowns, allowing the dropdown to extend the bottom of the\n   * screen but not otherwise influence or break out of the container.\n   * @option\n   * @type {boolean}\n   * @default true\n   */\n  allowBottomOverlap: true,\n  /**\n   * Number of pixels the positionable should be separated vertically from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  vOffset: 0,\n  /**\n   * Number of pixels the positionable should be separated horizontally from anchor\n   * @option\n   * @type {number}\n   * @default 0\n   */\n  hOffset: 0,\n}\n\nexport {Positionable};\n"]},"hash":"b013221ee07224e34fdfea11e77c9a06bf68dbd8"}
