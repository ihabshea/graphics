{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js","filenameRelative":"packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js.map","sourceFileName":"packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"jsonselect"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */ /*\n                                                       * This is the JSONSelect reference implementation, in javascript.\n                                                       */(function (exports) {\n    var // localize references\n    toString = Object.prototype.toString;\n\n    function jsonParse(str) {\n        try {\n            if (JSON && JSON.parse) {\n                return JSON.parse(str);\n            }\n\n            return new Function(\"return \" + str)();\n        } catch (e) {\n            te(\"ijs\");\n        }\n    } // emitted error codes.\n\n\n    var errorCodes = {\n        \"ijs\": \"invalid json string\",\n        \"mpc\": \"multiple pseudo classes (:xxx) not allowed\",\n        \"mepf\": \"malformed expression in pseudo-function\",\n        \"nmi\": \"multiple ids not allowed\",\n        \"se\": \"selector expected\",\n        \"sra\": \"string required after '.'\",\n        \"uc\": \"unrecognized char\",\n        \"ujs\": \"unclosed json string\",\n        \"upc\": \"unrecognized pseudo class\"\n    }; // throw an error message\n\n    function te(ec) {\n        throw new Error(errorCodes[ec]);\n    } // THE LEXER\n\n\n    var toks = {\n        psc: 1,\n        // pseudo class\n        psf: 2,\n        // pseudo class function\n        typ: 3,\n        // type\n        str: 4 // string\n\n    };\n    var pat = /^(?:([\\r\\n\\t\\ ]+)|([*.,>])|(string|boolean|null|array|object|number)|(:(?:root|first-child|last-child|only-child))|(:(?:nth-child|nth-last-child))|(:\\w+)|(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|(\\\")|((?:[_a-zA-Z]|[^\\0-\\0177]|\\\\[^\\r\\n\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\-]|[^\\u0000-\\u0177]|(?:\\\\[^\\r\\n\\f0-9a-fA-F]))*))/;\n    var exprPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n\n    var lex = function (str, off) {\n        if (!off) off = 0;\n        var m = pat.exec(str.substr(off));\n        if (!m) return undefined;\n        off += m[0].length;\n        var a;\n        if (m[1]) a = [off, \" \"];else if (m[2]) a = [off, m[0]];else if (m[3]) a = [off, toks.typ, m[0]];else if (m[4]) a = [off, toks.psc, m[0]];else if (m[5]) a = [off, toks.psf, m[0]];else if (m[6]) te(\"upc\");else if (m[7]) a = [off, toks.str, jsonParse(m[0])];else if (m[8]) te(\"ujs\");else if (m[9]) a = [off, toks.str, m[0].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g, \"$1\")];\n        return a;\n    }; // THE PARSER\n\n\n    var parse = function (str) {\n        var a = [],\n            off = 0,\n            am;\n\n        while (true) {\n            var s = parse_selector(str, off);\n            a.push(s[1]);\n            s = lex(str, off = s[0]);\n            if (s && s[1] === \" \") s = lex(str, off = s[0]);\n            if (!s) break; // now we've parsed a selector, and have something else...\n\n            if (s[1] === \">\") {\n                a.push(\">\");\n                off = s[0];\n            } else if (s[1] === \",\") {\n                if (am === undefined) am = [\",\", a];else am.push(a);\n                a = [];\n                off = s[0];\n            }\n        }\n\n        if (am) am.push(a);\n        return am ? am : a;\n    };\n\n    var parse_selector = function (str, off) {\n        var soff = off;\n        var s = {};\n        var l = lex(str, off); // skip space\n\n        if (l && l[1] === \" \") {\n            soff = off = l[0];\n            l = lex(str, off);\n        }\n\n        if (l && l[1] === toks.typ) {\n            s.type = l[2];\n            l = lex(str, off = l[0]);\n        } else if (l && l[1] === \"*\") {\n            // don't bother representing the universal sel, '*' in the\n            // parse tree, cause it's the default\n            l = lex(str, off = l[0]);\n        } // now support either an id or a pc\n\n\n        while (true) {\n            if (l === undefined) {\n                break;\n            } else if (l[1] === \".\") {\n                l = lex(str, off = l[0]);\n                if (!l || l[1] !== toks.str) te(\"sra\");\n                if (s.id) te(\"nmi\");\n                s.id = l[2];\n            } else if (l[1] === toks.psc) {\n                if (s.pc || s.pf) te(\"mpc\"); // collapse first-child and last-child into nth-child expressions\n\n                if (l[2] === \":first-child\") {\n                    s.pf = \":nth-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else if (l[2] === \":last-child\") {\n                    s.pf = \":nth-last-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else {\n                    s.pc = l[2];\n                }\n            } else if (l[1] === toks.psf) {\n                if (s.pc || s.pf) te(\"mpc\");\n                s.pf = l[2];\n                var m = exprPat.exec(str.substr(l[0]));\n                if (!m) te(\"mepf\");\n\n                if (m[5]) {\n                    s.a = 2;\n                    s.b = m[5] === \"odd\" ? 1 : 0;\n                } else if (m[6]) {\n                    s.a = 0;\n                    s.b = parseInt(m[6], 10);\n                } else {\n                    s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"), 10);\n                    s.b = m[3] ? parseInt(m[3] + m[4], 10) : 0;\n                }\n\n                l[0] += m[0].length;\n            } else {\n                break;\n            }\n\n            l = lex(str, off = l[0]);\n        } // now if we didn't actually parse anything it's an error\n\n\n        if (soff === off) te(\"se\");\n        return [off, s];\n    }; // THE EVALUATOR\n\n\n    function isArray(o) {\n        return Array.isArray ? Array.isArray(o) : toString.call(o) === \"[object Array]\";\n    }\n\n    function mytypeof(o) {\n        if (o === null) return \"null\";\n        var to = typeof o === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(o);\n        if (to === \"object\" && isArray(o)) to = \"array\";\n        return to;\n    }\n\n    function mn(node, sel, id, num, tot) {\n        var sels = [];\n        var cs = sel[0] === \">\" ? sel[1] : sel[0];\n        var m = true,\n            mod;\n        if (cs.type) m = m && cs.type === mytypeof(node);\n        if (cs.id) m = m && cs.id === id;\n\n        if (m && cs.pf) {\n            if (cs.pf === \":nth-last-child\") num = tot - num;else num++;\n\n            if (cs.a === 0) {\n                m = cs.b === num;\n            } else {\n                mod = (num - cs.b) % cs.a;\n                m = !mod && num * cs.a + cs.b >= 0;\n            }\n        } // should we repeat this selector for descendants?\n\n\n        if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n        if (m) {\n            // is there a fragment that we should pass down?\n            if (sel[0] === \">\") {\n                if (sel.length > 2) {\n                    m = false;\n                    sels.push(sel.slice(2));\n                }\n            } else if (sel.length > 1) {\n                m = false;\n                sels.push(sel.slice(1));\n            }\n        }\n\n        return [m, sels];\n    }\n\n    function forEach(sel, obj, fun, id, num, tot) {\n        var a = sel[0] === \",\" ? sel.slice(1) : [sel],\n            a0 = [],\n            call = false,\n            i = 0,\n            j = 0,\n            l = 0,\n            k,\n            x;\n\n        for (i = 0; i < a.length; i++) {\n            x = mn(obj, a[i], id, num, tot);\n\n            if (x[0]) {\n                call = true;\n            }\n\n            for (j = 0; j < x[1].length; j++) {\n                a0.push(x[1][j]);\n            }\n        }\n\n        if (a0.length && (typeof obj === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(obj)) === \"object\") {\n            if (a0.length >= 1) {\n                a0.unshift(\",\");\n            }\n\n            if (isArray(obj)) {\n                for (i = 0; i < obj.length; i++) {\n                    forEach(a0, obj[i], fun, undefined, i, obj.length);\n                }\n            } else {\n                // it's a shame to do this for :last-child and other\n                // properties which count from the end when we don't\n                // even know if they're present.  Also, the stream\n                // parser is going to be pissed.\n                l = 0;\n\n                for (k in meteorBabelHelpers.sanitizeForInObject(obj)) {\n                    if (obj.hasOwnProperty(k)) {\n                        l++;\n                    }\n                }\n\n                i = 0;\n\n                for (k in meteorBabelHelpers.sanitizeForInObject(obj)) {\n                    if (obj.hasOwnProperty(k)) {\n                        forEach(a0, obj[k], fun, k, i++, l);\n                    }\n                }\n            }\n        }\n\n        if (call && fun) {\n            fun(obj);\n        }\n    }\n\n    function match(sel, obj) {\n        var a = [];\n        forEach(sel, obj, function (x) {\n            a.push(x);\n        });\n        return a;\n    }\n\n    function compile(sel) {\n        return {\n            sel: parse(sel),\n            match: function (obj) {\n                return match(this.sel, obj);\n            },\n            forEach: function (obj, fun) {\n                return forEach(this.sel, obj, fun);\n            }\n        };\n    }\n\n    exports._lex = lex;\n    exports._parse = parse;\n\n    exports.match = function (sel, obj) {\n        return compile(sel).match(obj);\n    };\n\n    exports.forEach = function (sel, obj, fun) {\n        return compile(sel).forEach(obj, fun);\n    };\n\n    exports.compile = compile;\n})(typeof exports === \"undefined\" ? window.JSONSelect = {} : exports);","map":{"version":3,"sources":["packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js"],"names":["exports","toString","Object","prototype","jsonParse","str","JSON","parse","Function","e","te","errorCodes","ec","Error","toks","psc","psf","typ","pat","exprPat","lex","off","m","exec","substr","undefined","length","a","replace","am","s","parse_selector","push","soff","l","type","id","pc","pf","b","parseInt","isArray","o","Array","call","mytypeof","to","mn","node","sel","num","tot","sels","cs","mod","slice","forEach","obj","fun","a0","i","j","k","x","unshift","hasOwnProperty","match","compile","_lex","_parse","window","JSONSelect"],"mappings":"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","file":"packages/zurb:foundation-sites/vendor/modernizr/test/js/lib/jsonselect.js.map","sourcesContent":["/*! Copyright (c) 2011, Lloyd Hilaiel, ISC License */\n/*\n * This is the JSONSelect reference implementation, in javascript.\n */\n(function(exports) {\n\n    var // localize references\n    toString = Object.prototype.toString;\n\n    function jsonParse(str) {\n      try {\n          if(JSON && JSON.parse){\n              return JSON.parse(str);\n          }\n          return (new Function(\"return \" + str))();\n      } catch(e) {\n        te(\"ijs\");\n      }\n    }\n\n    // emitted error codes.\n    var errorCodes = {\n        \"ijs\": \"invalid json string\",\n        \"mpc\": \"multiple pseudo classes (:xxx) not allowed\",\n        \"mepf\": \"malformed expression in pseudo-function\",\n        \"nmi\": \"multiple ids not allowed\",\n        \"se\": \"selector expected\",\n        \"sra\": \"string required after '.'\",\n        \"uc\": \"unrecognized char\",\n        \"ujs\": \"unclosed json string\",\n        \"upc\": \"unrecognized pseudo class\"\n    };\n\n    // throw an error message\n    function te(ec) {\n        throw new Error(errorCodes[ec]);\n    }\n\n    // THE LEXER\n    var toks = {\n        psc: 1, // pseudo class\n        psf: 2, // pseudo class function\n        typ: 3, // type\n        str: 4 // string\n    };\n\n    var pat = /^(?:([\\r\\n\\t\\ ]+)|([*.,>])|(string|boolean|null|array|object|number)|(:(?:root|first-child|last-child|only-child))|(:(?:nth-child|nth-last-child))|(:\\w+)|(\\\"(?:[^\\\\]|\\\\[^\\\"])*\\\")|(\\\")|((?:[_a-zA-Z]|[^\\0-\\0177]|\\\\[^\\r\\n\\f0-9a-fA-F])(?:[_a-zA-Z0-9\\-]|[^\\u0000-\\u0177]|(?:\\\\[^\\r\\n\\f0-9a-fA-F]))*))/;\n    var exprPat = /^\\s*\\(\\s*(?:([+\\-]?)([0-9]*)n\\s*(?:([+\\-])\\s*([0-9]))?|(odd|even)|([+\\-]?[0-9]+))\\s*\\)/;\n    var lex = function (str, off) {\n        if (!off) off = 0;\n        var m = pat.exec(str.substr(off));\n        if (!m) return undefined;\n        off+=m[0].length;\n        var a;\n        if (m[1]) a = [off, \" \"];\n        else if (m[2]) a = [off, m[0]];\n        else if (m[3]) a = [off, toks.typ, m[0]];\n        else if (m[4]) a = [off, toks.psc, m[0]];\n        else if (m[5]) a = [off, toks.psf, m[0]];\n        else if (m[6]) te(\"upc\");\n        else if (m[7]) a = [off, toks.str, jsonParse(m[0])];\n        else if (m[8]) te(\"ujs\");\n        else if (m[9]) a = [off, toks.str, m[0].replace(/\\\\([^\\r\\n\\f0-9a-fA-F])/g,\"$1\")];\n        return a;\n    };\n\n    // THE PARSER\n\n    var parse = function (str) {\n        var a = [], off = 0, am;\n\n        while (true) {\n            var s = parse_selector(str, off);\n            a.push(s[1]);\n            s = lex(str, off = s[0]);\n            if (s && s[1] === \" \") s = lex(str, off = s[0]);\n            if (!s) break;\n            // now we've parsed a selector, and have something else...\n            if (s[1] === \">\") {\n                a.push(\">\");\n                off = s[0];\n            } else if (s[1] === \",\") {\n                if (am === undefined) am = [ \",\", a ];\n                else am.push(a);\n                a = [];\n                off = s[0];\n            }\n        }\n        if (am) am.push(a);\n        return am ? am : a;\n    };\n\n    var parse_selector = function(str, off) {\n        var soff = off;\n        var s = { };\n        var l = lex(str, off);\n        // skip space\n        if (l && l[1] === \" \") { soff = off = l[0]; l = lex(str, off); }\n        if (l && l[1] === toks.typ) {\n            s.type = l[2];\n            l = lex(str, (off = l[0]));\n        } else if (l && l[1] === \"*\") {\n            // don't bother representing the universal sel, '*' in the\n            // parse tree, cause it's the default\n            l = lex(str, (off = l[0]));\n        }\n\n        // now support either an id or a pc\n        while (true) {\n            if (l === undefined) {\n                break;\n            } else if (l[1] === \".\") {\n                l = lex(str, (off = l[0]));\n                if (!l || l[1] !== toks.str) te(\"sra\");\n                if (s.id) te(\"nmi\");\n                s.id = l[2];\n            } else if (l[1] === toks.psc) {\n                if (s.pc || s.pf) te(\"mpc\");\n                // collapse first-child and last-child into nth-child expressions\n                if (l[2] === \":first-child\") {\n                    s.pf = \":nth-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else if (l[2] === \":last-child\") {\n                    s.pf = \":nth-last-child\";\n                    s.a = 0;\n                    s.b = 1;\n                } else {\n                    s.pc = l[2];\n                }\n            } else if (l[1] === toks.psf) {\n                if (s.pc || s.pf ) te(\"mpc\");\n                s.pf = l[2];\n                var m = exprPat.exec(str.substr(l[0]));\n                if (!m) te(\"mepf\");\n                if (m[5]) {\n                    s.a = 2;\n                    s.b = (m[5] === \"odd\") ? 1 : 0;\n                } else if (m[6]) {\n                    s.a = 0;\n                    s.b = parseInt(m[6], 10);\n                } else {\n                    s.a = parseInt((m[1] ? m[1] : \"+\") + (m[2] ? m[2] : \"1\"),10);\n                    s.b = m[3] ? parseInt(m[3] + m[4],10) : 0;\n                }\n                l[0] += m[0].length;\n            } else {\n                break;\n            }\n            l = lex(str, (off = l[0]));\n        }\n\n        // now if we didn't actually parse anything it's an error\n        if (soff === off) te(\"se\");\n\n        return [off, s];\n    };\n\n    // THE EVALUATOR\n\n    function isArray(o) {\n        return Array.isArray ? Array.isArray(o) : \n          toString.call(o) === \"[object Array]\";\n    }\n\n    function mytypeof(o) {\n        if (o === null) return \"null\";\n        var to = typeof o;\n        if (to === \"object\" && isArray(o)) to = \"array\";\n        return to;\n    }\n\n    function mn(node, sel, id, num, tot) {\n        var sels = [];\n        var cs = (sel[0] === \">\") ? sel[1] : sel[0];\n        var m = true, mod;\n        if (cs.type) m = m && (cs.type === mytypeof(node));\n        if (cs.id)   m = m && (cs.id === id);\n        if (m && cs.pf) {\n            if (cs.pf === \":nth-last-child\") num = tot - num;\n            else num++;\n            if (cs.a === 0) {\n                m = cs.b === num;\n            } else {\n                mod = ((num - cs.b) % cs.a);\n\n                m = (!mod && ((num*cs.a + cs.b) >= 0));\n            }\n        }\n\n        // should we repeat this selector for descendants?\n        if (sel[0] !== \">\" && sel[0].pc !== \":root\") sels.push(sel);\n\n        if (m) {\n            // is there a fragment that we should pass down?\n            if (sel[0] === \">\") { if (sel.length > 2) { m = false; sels.push(sel.slice(2)); } }\n            else if (sel.length > 1) { m = false; sels.push(sel.slice(1)); }\n        }\n\n        return [m, sels];\n    }\n\n    function forEach(sel, obj, fun, id, num, tot) {\n        var a = (sel[0] === \",\") ? sel.slice(1) : [sel],\n        a0 = [],\n        call = false,\n        i = 0, j = 0, l = 0, k, x;\n        for (i = 0; i < a.length; i++) {\n            x = mn(obj, a[i], id, num, tot);\n            if (x[0]) {\n                call = true;\n            }\n            for (j = 0; j < x[1].length; j++) {\n                a0.push(x[1][j]);\n            }\n        }\n        if (a0.length && typeof obj === \"object\") {\n            if (a0.length >= 1) {\n                a0.unshift(\",\");\n            }\n            if (isArray(obj)) {\n                for (i = 0; i < obj.length; i++) {\n                    forEach(a0, obj[i], fun, undefined, i, obj.length);\n                }\n            } else {\n                // it's a shame to do this for :last-child and other\n                // properties which count from the end when we don't\n                // even know if they're present.  Also, the stream\n                // parser is going to be pissed.\n                l = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        l++;\n                    }\n                }\n                i = 0;\n                for (k in obj) {\n                    if (obj.hasOwnProperty(k)) {\n                        forEach(a0, obj[k], fun, k, i++, l);\n                    }\n                }\n            }\n        }\n        if (call && fun) {\n            fun(obj);\n        }\n    }\n\n    function match(sel, obj) {\n        var a = [];\n        forEach(sel, obj, function(x) {\n            a.push(x);\n        });\n        return a;\n    }\n\n    function compile(sel) {\n        return {\n            sel: parse(sel),\n            match: function(obj){\n                return match(this.sel, obj);\n            },\n            forEach: function(obj, fun) {\n                return forEach(this.sel, obj, fun);\n            }\n        };\n    }\n\n    exports._lex = lex;\n    exports._parse = parse;\n    exports.match = function (sel, obj) {\n        return compile(sel).match(obj);\n    };\n    exports.forEach = function(sel, obj, fun) {\n        return compile(sel).forEach(obj, fun);\n    };\n    exports.compile = compile;\n})(typeof exports === \"undefined\" ? (window.JSONSelect = {}) : exports);\n\n"]},"hash":"823be8285801a37a7d6610f1e898d6f6c1876875"}
