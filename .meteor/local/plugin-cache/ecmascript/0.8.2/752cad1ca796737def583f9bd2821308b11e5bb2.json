{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/test/javascript/lib/chai.js","filenameRelative":"packages/zurb:foundation-sites/test/javascript/lib/chai.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/test/javascript/lib/chai.js.map","sourceFileName":"packages/zurb:foundation-sites/test/javascript/lib/chai.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"chai"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n;\n\n(function () {\n  /**\n   * Require the module at `name`.\n   *\n   * @param {String} name\n   * @return {Object} exports\n   * @api public\n   */function require(name) {\n    var module = require.modules[name];\n    if (!module) throw new Error('failed to require \"' + name + '\"');\n\n    if (!('exports' in module) && typeof module.definition === 'function') {\n      module.client = module.component = true;\n      module.definition.call(this, module.exports = {}, module);\n      delete module.definition;\n    }\n\n    return module.exports;\n  } /**\n     * Meta info, accessible in the global scope unless you use AMD option.\n     */\n\n  require.loader = 'component'; /**\n                                 * Internal helper object, contains a sorting function for semantiv versioning\n                                 */\n  require.helper = {};\n\n  require.helper.semVerSort = function (a, b) {\n    var aArray = a.version.split('.');\n    var bArray = b.version.split('.');\n\n    for (var i = 0; i < aArray.length; ++i) {\n      var aInt = parseInt(aArray[i], 10);\n      var bInt = parseInt(bArray[i], 10);\n\n      if (aInt === bInt) {\n        var aLex = aArray[i].substr((\"\" + aInt).length);\n        var bLex = bArray[i].substr((\"\" + bInt).length);\n        if (aLex === '' && bLex !== '') return 1;\n        if (aLex !== '' && bLex === '') return -1;\n        if (aLex !== '' && bLex !== '') return aLex > bLex ? 1 : -1;\n        continue;\n      } else if (aInt > bInt) {\n        return 1;\n      } else {\n        return -1;\n      }\n    }\n\n    return 0;\n  }; /**\n      * Find and require a module which name starts with the provided name.\n      * If multiple modules exists, the highest semver is used. \n      * This function can only be used for remote dependencies.\n     \n      * @param {String} name - module name: `user~repo`\n      * @param {Boolean} returnPath - returns the canonical require path if true, \n      *                               otherwise it returns the epxorted module\n      */\n\n  require.latest = function (name, returnPath) {\n    function showError(name) {\n      throw new Error('failed to find latest module of \"' + name + '\"');\n    } // only remotes with semvers, ignore local files conataining a '/'\n\n\n    var versionRegexp = /(.*)~(.*)@v?(\\d+\\.\\d+\\.\\d+[^\\/]*)$/;\n    var remoteRegexp = /(.*)~(.*)/;\n    if (!remoteRegexp.test(name)) showError(name);\n    var moduleNames = Object.keys(require.modules);\n    var semVerCandidates = [];\n    var otherCandidates = []; // for instance: name of the git branch\n\n    for (var i = 0; i < moduleNames.length; i++) {\n      var moduleName = moduleNames[i];\n\n      if (new RegExp(name + '@').test(moduleName)) {\n        var version = moduleName.substr(name.length + 1);\n        var semVerMatch = versionRegexp.exec(moduleName);\n\n        if (semVerMatch != null) {\n          semVerCandidates.push({\n            version: version,\n            name: moduleName\n          });\n        } else {\n          otherCandidates.push({\n            version: version,\n            name: moduleName\n          });\n        }\n      }\n    }\n\n    if (semVerCandidates.concat(otherCandidates).length === 0) {\n      showError(name);\n    }\n\n    if (semVerCandidates.length > 0) {\n      var module = semVerCandidates.sort(require.helper.semVerSort).pop().name;\n\n      if (returnPath === true) {\n        return module;\n      }\n\n      return require(module);\n    } // if the build contains more than one branch of the same module\n    // you should not use this funciton\n\n\n    var module = otherCandidates.sort(function (a, b) {\n      return a.name > b.name;\n    })[0].name;\n\n    if (returnPath === true) {\n      return module;\n    }\n\n    return require(module);\n  }; /**\n      * Registered modules.\n      */\n\n  require.modules = {}; /**\n                         * Register module at `name` with callback `definition`.\n                         *\n                         * @param {String} name\n                         * @param {Function} definition\n                         * @api private\n                         */\n\n  require.register = function (name, definition) {\n    require.modules[name] = {\n      definition: definition\n    };\n  }; /**\n      * Define a module's exports immediately with `exports`.\n      *\n      * @param {String} name\n      * @param {Generic} exports\n      * @api private\n      */\n\n  require.define = function (name, exports) {\n    require.modules[name] = {\n      exports: exports\n    };\n  };\n\n  require.register(\"chaijs~assertion-error@1.0.0\", function (exports, module) {\n    /*!\n     * assertion-error\n     * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n     * MIT Licensed\n     */ /*!\n         * Return a function that will copy properties from\n         * one object to another excluding any originally\n         * listed. Returned function will create a new `{}`.\n         *\n         * @param {String} excluded properties ...\n         * @return {Function}\n         */function exclude() {\n      var excludes = [].slice.call(arguments);\n\n      function excludeProps(res, obj) {\n        Object.keys(obj).forEach(function (key) {\n          if (!~excludes.indexOf(key)) res[key] = obj[key];\n        });\n      }\n\n      return function () {\n        function extendExclude() {\n          var args = [].slice.call(arguments),\n              i = 0,\n              res = {};\n\n          for (; i < args.length; i++) {\n            excludeProps(res, args[i]);\n          }\n\n          return res;\n        }\n\n        return extendExclude;\n      }();\n    }\n\n    ; /*!\n       * Primary Exports\n       */\n    module.exports = AssertionError; /**\n                                      * ### AssertionError\n                                      *\n                                      * An extension of the JavaScript `Error` constructor for\n                                      * assertion and validation scenarios.\n                                      *\n                                      * @param {String} message\n                                      * @param {Object} properties to include (optional)\n                                      * @param {callee} start stack function (optional)\n                                      */\n\n    function AssertionError(message, _props, ssf) {\n      var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON'),\n          props = extend(_props || {}); // default values\n\n      this.message = message || 'Unspecified AssertionError';\n      this.showDiff = false; // copy from properties\n\n      for (var key in meteorBabelHelpers.sanitizeForInObject(props)) {\n        this[key] = props[key];\n      } // capture stack trace\n\n\n      ssf = ssf || arguments.callee;\n\n      if (ssf && Error.captureStackTrace) {\n        Error.captureStackTrace(this, ssf);\n      }\n    } /*!\n       * Inherit from Error.prototype\n       */\n\n    AssertionError.prototype = Object.create(Error.prototype); /*!\n                                                                * Statically set name\n                                                                */\n    AssertionError.prototype.name = 'AssertionError'; /*!\n                                                       * Ensure correct constructor\n                                                       */\n    AssertionError.prototype.constructor = AssertionError; /**\n                                                            * Allow errors to be converted to JSON for static transfer.\n                                                            *\n                                                            * @param {Boolean} include stack (default: `true`)\n                                                            * @return {Object} object that can be `JSON.stringify`\n                                                            */\n\n    AssertionError.prototype.toJSON = function (stack) {\n      var extend = exclude('constructor', 'toJSON', 'stack'),\n          props = extend({\n        name: this.name\n      }, this); // include stack if exists and not turned off\n\n      if (false !== stack && this.stack) {\n        props.stack = this.stack;\n      }\n\n      return props;\n    };\n  });\n\n  require.register(\"chaijs~type-detect@0.1.1\", function (exports, module) {\n    /*!\n     * type-detect\n     * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Primary Exports\n         */var exports = module.exports = getType; /*!\n                                                    * Detectable javascript natives\n                                                    */\n    var natives = {\n      '[object Array]': 'array',\n      '[object RegExp]': 'regexp',\n      '[object Function]': 'function',\n      '[object Arguments]': 'arguments',\n      '[object Date]': 'date'\n    }; /**\n        * ### typeOf (obj)\n        *\n        * Use several different techniques to determine\n        * the type of object being tested.\n        *\n        *\n        * @param {Mixed} object\n        * @return {String} object type\n        * @api public\n        */\n\n    function getType(obj) {\n      var str = Object.prototype.toString.call(obj);\n      if (natives[str]) return natives[str];\n      if (obj === null) return 'null';\n      if (obj === undefined) return 'undefined';\n      if (obj === Object(obj)) return 'object';\n      return typeof obj === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(obj);\n    }\n\n    exports.Library = Library; /**\n                                * ### Library\n                                *\n                                * Create a repository for custom type detection.\n                                *\n                                * ```js\n                                * var lib = new type.Library;\n                                * ```\n                                *\n                                */\n\n    function Library() {\n      this.tests = {};\n    } /**\n       * #### .of (obj)\n       *\n       * Expose replacement `typeof` detection to the library.\n       *\n       * ```js\n       * if ('string' === lib.of('hello world')) {\n       *   // ...\n       * }\n       * ```\n       *\n       * @param {Mixed} object to test\n       * @return {String} type\n       */\n\n    Library.prototype.of = getType; /**\n                                     * #### .define (type, test)\n                                     *\n                                     * Add a test to for the `.test()` assertion.\n                                     *\n                                     * Can be defined as a regular expression:\n                                     *\n                                     * ```js\n                                     * lib.define('int', /^[0-9]+$/);\n                                     * ```\n                                     *\n                                     * ... or as a function:\n                                     *\n                                     * ```js\n                                     * lib.define('bln', function (obj) {\n                                     *   if ('boolean' === lib.of(obj)) return true;\n                                     *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n                                     *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n                                     *   return !! ~blns.indexOf(obj);\n                                     * });\n                                     * ```\n                                     *\n                                     * @param {String} type\n                                     * @param {RegExp|Function} test\n                                     * @api public\n                                     */\n\n    Library.prototype.define = function (type, test) {\n      if (arguments.length === 1) return this.tests[type];\n      this.tests[type] = test;\n      return this;\n    }; /**\n        * #### .test (obj, test)\n        *\n        * Assert that an object is of type. Will first\n        * check natives, and if that does not pass it will\n        * use the user defined custom tests.\n        *\n        * ```js\n        * assert(lib.test('1', 'int'));\n        * assert(lib.test('yes', 'bln'));\n        * ```\n        *\n        * @param {Mixed} object\n        * @param {String} type\n        * @return {Boolean} result\n        * @api public\n        */\n\n    Library.prototype.test = function (obj, type) {\n      if (type === getType(obj)) return true;\n      var test = this.tests[type];\n\n      if (test && 'regexp' === getType(test)) {\n        return test.test(obj);\n      } else if (test && 'function' === getType(test)) {\n        return test(obj);\n      } else {\n        throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n      }\n    };\n  });\n\n  require.register(\"chaijs~deep-eql@0.1.3\", function (exports, module) {\n    /*!\n     * deep-eql\n     * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Module dependencies\n         */var type = require('chaijs~type-detect@0.1.1'); /*!\n                                                            * Buffer.isBuffer browser shim\n                                                            */\n\n    var Buffer;\n\n    try {\n      Buffer = require('buffer').Buffer;\n    } catch (ex) {\n      Buffer = {};\n\n      Buffer.isBuffer = function () {\n        return false;\n      };\n    } /*!\n       * Primary Export\n       */\n\n    module.exports = deepEqual; /**\n                                 * Assert super-strict (egal) equality between\n                                 * two objects of any type.\n                                 *\n                                 * @param {Mixed} a\n                                 * @param {Mixed} b\n                                 * @param {Array} memoised (optional)\n                                 * @return {Boolean} equal match\n                                 */\n\n    function deepEqual(a, b, m) {\n      if (sameValue(a, b)) {\n        return true;\n      } else if ('date' === type(a)) {\n        return dateEqual(a, b);\n      } else if ('regexp' === type(a)) {\n        return regexpEqual(a, b);\n      } else if (Buffer.isBuffer(a)) {\n        return bufferEqual(a, b);\n      } else if ('arguments' === type(a)) {\n        return argumentsEqual(a, b, m);\n      } else if (!typeEqual(a, b)) {\n        return false;\n      } else if ('object' !== type(a) && 'object' !== type(b) && 'array' !== type(a) && 'array' !== type(b)) {\n        return sameValue(a, b);\n      } else {\n        return objectEqual(a, b, m);\n      }\n    } /*!\n       * Strict (egal) equality test. Ensures that NaN always\n       * equals NaN and `-0` does not equal `+0`.\n       *\n       * @param {Mixed} a\n       * @param {Mixed} b\n       * @return {Boolean} equal match\n       */\n\n    function sameValue(a, b) {\n      if (a === b) return a !== 0 || 1 / a === 1 / b;\n      return a !== a && b !== b;\n    } /*!\n       * Compare the types of two given objects and\n       * return if they are equal. Note that an Array\n       * has a type of `array` (not `object`) and arguments\n       * have a type of `arguments` (not `array`/`object`).\n       *\n       * @param {Mixed} a\n       * @param {Mixed} b\n       * @return {Boolean} result\n       */\n\n    function typeEqual(a, b) {\n      return type(a) === type(b);\n    } /*!\n       * Compare two Date objects by asserting that\n       * the time values are equal using `saveValue`.\n       *\n       * @param {Date} a\n       * @param {Date} b\n       * @return {Boolean} result\n       */\n\n    function dateEqual(a, b) {\n      if ('date' !== type(b)) return false;\n      return sameValue(a.getTime(), b.getTime());\n    } /*!\n       * Compare two regular expressions by converting them\n       * to string and checking for `sameValue`.\n       *\n       * @param {RegExp} a\n       * @param {RegExp} b\n       * @return {Boolean} result\n       */\n\n    function regexpEqual(a, b) {\n      if ('regexp' !== type(b)) return false;\n      return sameValue(a.toString(), b.toString());\n    } /*!\n       * Assert deep equality of two `arguments` objects.\n       * Unfortunately, these must be sliced to arrays\n       * prior to test to ensure no bad behavior.\n       *\n       * @param {Arguments} a\n       * @param {Arguments} b\n       * @param {Array} memoize (optional)\n       * @return {Boolean} result\n       */\n\n    function argumentsEqual(a, b, m) {\n      if ('arguments' !== type(b)) return false;\n      a = [].slice.call(a);\n      b = [].slice.call(b);\n      return deepEqual(a, b, m);\n    } /*!\n       * Get enumerable properties of a given object.\n       *\n       * @param {Object} a\n       * @return {Array} property names\n       */\n\n    function enumerable(a) {\n      var res = [];\n\n      for (var key in meteorBabelHelpers.sanitizeForInObject(a)) {\n        res.push(key);\n      }\n\n      return res;\n    } /*!\n       * Simple equality for flat iterable objects\n       * such as Arrays or Node.js buffers.\n       *\n       * @param {Iterable} a\n       * @param {Iterable} b\n       * @return {Boolean} result\n       */\n\n    function iterableEqual(a, b) {\n      if (a.length !== b.length) return false;\n      var i = 0;\n      var match = true;\n\n      for (; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          match = false;\n          break;\n        }\n      }\n\n      return match;\n    } /*!\n       * Extension to `iterableEqual` specifically\n       * for Node.js Buffers.\n       *\n       * @param {Buffer} a\n       * @param {Mixed} b\n       * @return {Boolean} result\n       */\n\n    function bufferEqual(a, b) {\n      if (!Buffer.isBuffer(b)) return false;\n      return iterableEqual(a, b);\n    } /*!\n       * Block for `objectEqual` ensuring non-existing\n       * values don't get in.\n       *\n       * @param {Mixed} object\n       * @return {Boolean} result\n       */\n\n    function isValue(a) {\n      return a !== null && a !== undefined;\n    } /*!\n       * Recursively check the equality of two objects.\n       * Once basic sameness has been established it will\n       * defer to `deepEqual` for each enumerable key\n       * in the object.\n       *\n       * @param {Mixed} a\n       * @param {Mixed} b\n       * @return {Boolean} result\n       */\n\n    function objectEqual(a, b, m) {\n      if (!isValue(a) || !isValue(b)) {\n        return false;\n      }\n\n      if (a.prototype !== b.prototype) {\n        return false;\n      }\n\n      var i;\n\n      if (m) {\n        for (i = 0; i < m.length; i++) {\n          if (m[i][0] === a && m[i][1] === b || m[i][0] === b && m[i][1] === a) {\n            return true;\n          }\n        }\n      } else {\n        m = [];\n      }\n\n      try {\n        var ka = enumerable(a);\n        var kb = enumerable(b);\n      } catch (ex) {\n        return false;\n      }\n\n      ka.sort();\n      kb.sort();\n\n      if (!iterableEqual(ka, kb)) {\n        return false;\n      }\n\n      m.push([a, b]);\n      var key;\n\n      for (i = ka.length - 1; i >= 0; i--) {\n        key = ka[i];\n\n        if (!deepEqual(a[key], b[key], m)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  });\n\n  require.register(\"chai\", function (exports, module) {\n    module.exports = require('chai/lib/chai.js');\n  });\n\n  require.register(\"chai/lib/chai.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */var used = [],\n        exports = module.exports = {}; /*!\n                                        * Chai version\n                                        */\n    exports.version = '2.1.0'; /*!\n                                * Assertion Error\n                                */\n    exports.AssertionError = require('chaijs~assertion-error@1.0.0'); /*!\n                                                                       * Utils for plugins (not exported)\n                                                                       */\n\n    var util = require('chai/lib/chai/utils/index.js'); /**\n                                                         * # .use(function)\n                                                         *\n                                                         * Provides a way to extend the internals of Chai\n                                                         *\n                                                         * @param {Function}\n                                                         * @returns {this} for chaining\n                                                         * @api public\n                                                         */\n\n    exports.use = function (fn) {\n      if (!~used.indexOf(fn)) {\n        fn(this, util);\n        used.push(fn);\n      }\n\n      return this;\n    }; /*!\n        * Utility Functions\n        */\n\n    exports.util = util; /*!\n                          * Configuration\n                          */\n\n    var config = require('chai/lib/chai/config.js');\n\n    exports.config = config; /*!\n                              * Primary `Assertion` prototype\n                              */\n\n    var assertion = require('chai/lib/chai/assertion.js');\n\n    exports.use(assertion); /*!\n                             * Core Assertions\n                             */\n\n    var core = require('chai/lib/chai/core/assertions.js');\n\n    exports.use(core); /*!\n                        * Expect interface\n                        */\n\n    var expect = require('chai/lib/chai/interface/expect.js');\n\n    exports.use(expect); /*!\n                          * Should interface\n                          */\n\n    var should = require('chai/lib/chai/interface/should.js');\n\n    exports.use(should); /*!\n                          * Assert interface\n                          */\n\n    var assert = require('chai/lib/chai/interface/assert.js');\n\n    exports.use(assert);\n  });\n\n  require.register(\"chai/lib/chai/assertion.js\", function (exports, module) {\n    /*!\n     * chai\n     * http://chaijs.com\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */var config = require('chai/lib/chai/config.js');\n\n    module.exports = function (_chai, util) {\n      /*!\n       * Module dependencies.\n       */var AssertionError = _chai.AssertionError,\n          flag = util.flag; /*!\n                             * Module export.\n                             */\n      _chai.Assertion = Assertion; /*!\n                                    * Assertion Constructor\n                                    *\n                                    * Creates object for chaining.\n                                    *\n                                    * @api private\n                                    */\n\n      function Assertion(obj, msg, stack) {\n        flag(this, 'ssfi', stack || arguments.callee);\n        flag(this, 'object', obj);\n        flag(this, 'message', msg);\n      }\n\n      Object.defineProperty(Assertion, 'includeStack', {\n        get: function () {\n          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n          return config.includeStack;\n        },\n        set: function (value) {\n          console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n          config.includeStack = value;\n        }\n      });\n      Object.defineProperty(Assertion, 'showDiff', {\n        get: function () {\n          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n          return config.showDiff;\n        },\n        set: function (value) {\n          console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n          config.showDiff = value;\n        }\n      });\n\n      Assertion.addProperty = function (name, fn) {\n        util.addProperty(this.prototype, name, fn);\n      };\n\n      Assertion.addMethod = function (name, fn) {\n        util.addMethod(this.prototype, name, fn);\n      };\n\n      Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n        util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n      };\n\n      Assertion.overwriteProperty = function (name, fn) {\n        util.overwriteProperty(this.prototype, name, fn);\n      };\n\n      Assertion.overwriteMethod = function (name, fn) {\n        util.overwriteMethod(this.prototype, name, fn);\n      };\n\n      Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n        util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n      }; /*!\n          * ### .assert(expression, message, negateMessage, expected, actual)\n          *\n          * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n          *\n          * @name assert\n          * @param {Philosophical} expression to be tested\n          * @param {String or Function} message or function that returns message to display if fails\n          * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n          * @param {Mixed} expected value (remember to check for negation)\n          * @param {Mixed} actual (optional) will default to `this.obj`\n          * @api private\n          */\n\n      Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n        var ok = util.test(this, arguments);\n        if (true !== showDiff) showDiff = false;\n        if (true !== config.showDiff) showDiff = false;\n\n        if (!ok) {\n          var msg = util.getMessage(this, arguments),\n              actual = util.getActual(this, arguments);\n          throw new AssertionError(msg, {\n            actual: actual,\n            expected: expected,\n            showDiff: showDiff\n          }, config.includeStack ? this.assert : flag(this, 'ssfi'));\n        }\n      }; /*!\n          * ### ._obj\n          *\n          * Quick reference to stored `actual` value for plugin developers.\n          *\n          * @api private\n          */\n\n      Object.defineProperty(Assertion.prototype, '_obj', {\n        get: function () {\n          return flag(this, 'object');\n        },\n        set: function (val) {\n          flag(this, 'object', val);\n        }\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/config.js\", function (exports, module) {\n    module.exports = {\n      /**\n       * ### config.includeStack\n       *\n       * User configurable property, influences whether stack trace\n       * is included in Assertion error message. Default of false\n       * suppresses stack trace in the error message.\n       *\n       *     chai.config.includeStack = true;  // enable stack on error\n       *\n       * @param {Boolean}\n       * @api public\n       */includeStack: false,\n      /**\n       * ### config.showDiff\n       *\n       * User configurable property, influences whether or not\n       * the `showDiff` flag should be included in the thrown\n       * AssertionErrors. `false` will always be `false`; `true`\n       * will be true when the assertion has requested a diff\n       * be shown.\n       *\n       * @param {Boolean}\n       * @api public\n       */showDiff: true,\n      /**\n       * ### config.truncateThreshold\n       *\n       * User configurable property, sets length threshold for actual and\n       * expected values in assertion errors. If this threshold is exceeded,\n       * the value is truncated.\n       *\n       * Set it to zero if you want to disable truncating altogether.\n       *\n       *     chai.config.truncateThreshold = 0;  // disable truncating\n       *\n       * @param {Number}\n       * @api public\n       */truncateThreshold: 40\n    };\n  });\n\n  require.register(\"chai/lib/chai/core/assertions.js\", function (exports, module) {\n    /*!\n     * chai\n     * http://chaijs.com\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */module.exports = function (chai, _) {\n      var Assertion = chai.Assertion,\n          toString = Object.prototype.toString,\n          flag = _.flag; /**\n                          * ### Language Chains\n                          *\n                          * The following are provided as chainable getters to\n                          * improve the readability of your assertions. They\n                          * do not provide testing capabilities unless they\n                          * have been overwritten by a plugin.\n                          *\n                          * **Chains**\n                          *\n                          * - to\n                          * - be\n                          * - been\n                          * - is\n                          * - that\n                          * - which\n                          * - and\n                          * - has\n                          * - have\n                          * - with\n                          * - at\n                          * - of\n                          * - same\n                          *\n                          * @name language chains\n                          * @api public\n                          */\n      ['to', 'be', 'been', 'is', 'and', 'has', 'have', 'with', 'that', 'which', 'at', 'of', 'same'].forEach(function (chain) {\n        Assertion.addProperty(chain, function () {\n          return this;\n        });\n      }); /**\n           * ### .not\n           *\n           * Negates any of assertions following in the chain.\n           *\n           *     expect(foo).to.not.equal('bar');\n           *     expect(goodFn).to.not.throw(Error);\n           *     expect({ foo: 'baz' }).to.have.property('foo')\n           *       .and.not.equal('bar');\n           *\n           * @name not\n           * @api public\n           */\n      Assertion.addProperty('not', function () {\n        flag(this, 'negate', true);\n      }); /**\n           * ### .deep\n           *\n           * Sets the `deep` flag, later used by the `equal` and\n           * `property` assertions.\n           *\n           *     expect(foo).to.deep.equal({ bar: 'baz' });\n           *     expect({ foo: { bar: { baz: 'quux' } } })\n           *       .to.have.deep.property('foo.bar.baz', 'quux');\n           *\n           * @name deep\n           * @api public\n           */\n      Assertion.addProperty('deep', function () {\n        flag(this, 'deep', true);\n      }); /**\n           * ### .any\n           *\n           * Sets the `any` flag, (opposite of the `all` flag)\n           * later used in the `keys` assertion. \n           *\n           *     expect(foo).to.have.any.keys('bar', 'baz');\n           *\n           * @name any\n           * @api public\n           */\n      Assertion.addProperty('any', function () {\n        flag(this, 'any', true);\n        flag(this, 'all', false);\n      }); /**\n           * ### .all\n           *\n           * Sets the `all` flag (opposite of the `any` flag) \n           * later used by the `keys` assertion.\n           *\n           *     expect(foo).to.have.all.keys('bar', 'baz');\n           *\n           * @name all\n           * @api public\n           */\n      Assertion.addProperty('all', function () {\n        flag(this, 'all', true);\n        flag(this, 'any', false);\n      }); /**\n           * ### .a(type)\n           *\n           * The `a` and `an` assertions are aliases that can be\n           * used either as language chains or to assert a value's\n           * type.\n           *\n           *     // typeof\n           *     expect('test').to.be.a('string');\n           *     expect({ foo: 'bar' }).to.be.an('object');\n           *     expect(null).to.be.a('null');\n           *     expect(undefined).to.be.an('undefined');\n           *\n           *     // language chain\n           *     expect(foo).to.be.an.instanceof(Foo);\n           *\n           * @name a\n           * @alias an\n           * @param {String} type\n           * @param {String} message _optional_\n           * @api public\n           */\n\n      function an(type, msg) {\n        if (msg) flag(this, 'message', msg);\n        type = type.toLowerCase();\n        var obj = flag(this, 'object'),\n            article = ~['a', 'e', 'i', 'o', 'u'].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n        this.assert(type === _.type(obj), 'expected #{this} to be ' + article + type, 'expected #{this} not to be ' + article + type);\n      }\n\n      Assertion.addChainableMethod('an', an);\n      Assertion.addChainableMethod('a', an); /**\n                                              * ### .include(value)\n                                              *\n                                              * The `include` and `contain` assertions can be used as either property\n                                              * based language chains or as methods to assert the inclusion of an object\n                                              * in an array or a substring in a string. When used as language chains,\n                                              * they toggle the `contains` flag for the `keys` assertion.\n                                              *\n                                              *     expect([1,2,3]).to.include(2);\n                                              *     expect('foobar').to.contain('foo');\n                                              *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n                                              *\n                                              * @name include\n                                              * @alias contain\n                                              * @alias includes\n                                              * @alias contains\n                                              * @param {Object|String|Number} obj\n                                              * @param {String} message _optional_\n                                              * @api public\n                                              */\n\n      function includeChainingBehavior() {\n        flag(this, 'contains', true);\n      }\n\n      function include(val, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        var expected = false;\n\n        if (_.type(obj) === 'array' && _.type(val) === 'object') {\n          for (var i in meteorBabelHelpers.sanitizeForInObject(obj)) {\n            if (_.eql(obj[i], val)) {\n              expected = true;\n              break;\n            }\n          }\n        } else if (_.type(val) === 'object') {\n          if (!flag(this, 'negate')) {\n            for (var k in meteorBabelHelpers.sanitizeForInObject(val)) {\n              new Assertion(obj).property(k, val[k]);\n            }\n\n            return;\n          }\n\n          var subset = {};\n\n          for (var k in meteorBabelHelpers.sanitizeForInObject(val)) {\n            subset[k] = obj[k];\n          }\n\n          expected = _.eql(subset, val);\n        } else {\n          expected = obj && ~obj.indexOf(val);\n        }\n\n        this.assert(expected, 'expected #{this} to include ' + _.inspect(val), 'expected #{this} to not include ' + _.inspect(val));\n      }\n\n      Assertion.addChainableMethod('include', include, includeChainingBehavior);\n      Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n      Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n      Assertion.addChainableMethod('includes', include, includeChainingBehavior); /**\n                                                                                   * ### .ok\n                                                                                   *\n                                                                                   * Asserts that the target is truthy.\n                                                                                   *\n                                                                                   *     expect('everthing').to.be.ok;\n                                                                                   *     expect(1).to.be.ok;\n                                                                                   *     expect(false).to.not.be.ok;\n                                                                                   *     expect(undefined).to.not.be.ok;\n                                                                                   *     expect(null).to.not.be.ok;\n                                                                                   *\n                                                                                   * @name ok\n                                                                                   * @api public\n                                                                                   */\n      Assertion.addProperty('ok', function () {\n        this.assert(flag(this, 'object'), 'expected #{this} to be truthy', 'expected #{this} to be falsy');\n      }); /**\n           * ### .true\n           *\n           * Asserts that the target is `true`.\n           *\n           *     expect(true).to.be.true;\n           *     expect(1).to.not.be.true;\n           *\n           * @name true\n           * @api public\n           */\n      Assertion.addProperty('true', function () {\n        this.assert(true === flag(this, 'object'), 'expected #{this} to be true', 'expected #{this} to be false', this.negate ? false : true);\n      }); /**\n           * ### .false\n           *\n           * Asserts that the target is `false`.\n           *\n           *     expect(false).to.be.false;\n           *     expect(0).to.not.be.false;\n           *\n           * @name false\n           * @api public\n           */\n      Assertion.addProperty('false', function () {\n        this.assert(false === flag(this, 'object'), 'expected #{this} to be false', 'expected #{this} to be true', this.negate ? true : false);\n      }); /**\n           * ### .null\n           *\n           * Asserts that the target is `null`.\n           *\n           *     expect(null).to.be.null;\n           *     expect(undefined).not.to.be.null;\n           *\n           * @name null\n           * @api public\n           */\n      Assertion.addProperty('null', function () {\n        this.assert(null === flag(this, 'object'), 'expected #{this} to be null', 'expected #{this} not to be null');\n      }); /**\n           * ### .undefined\n           *\n           * Asserts that the target is `undefined`.\n           *\n           *     expect(undefined).to.be.undefined;\n           *     expect(null).to.not.be.undefined;\n           *\n           * @name undefined\n           * @api public\n           */\n      Assertion.addProperty('undefined', function () {\n        this.assert(undefined === flag(this, 'object'), 'expected #{this} to be undefined', 'expected #{this} not to be undefined');\n      }); /**\n           * ### .exist\n           *\n           * Asserts that the target is neither `null` nor `undefined`.\n           *\n           *     var foo = 'hi'\n           *       , bar = null\n           *       , baz;\n           *\n           *     expect(foo).to.exist;\n           *     expect(bar).to.not.exist;\n           *     expect(baz).to.not.exist;\n           *\n           * @name exist\n           * @api public\n           */\n      Assertion.addProperty('exist', function () {\n        this.assert(null != flag(this, 'object'), 'expected #{this} to exist', 'expected #{this} to not exist');\n      }); /**\n           * ### .empty\n           *\n           * Asserts that the target's length is `0`. For arrays, it checks\n           * the `length` property. For objects, it gets the count of\n           * enumerable keys.\n           *\n           *     expect([]).to.be.empty;\n           *     expect('').to.be.empty;\n           *     expect({}).to.be.empty;\n           *\n           * @name empty\n           * @api public\n           */\n      Assertion.addProperty('empty', function () {\n        var obj = flag(this, 'object'),\n            expected = obj;\n\n        if (Array.isArray(obj) || 'string' === typeof object) {\n          expected = obj.length;\n        } else if ((typeof obj === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(obj)) === 'object') {\n          expected = Object.keys(obj).length;\n        }\n\n        this.assert(!expected, 'expected #{this} to be empty', 'expected #{this} not to be empty');\n      }); /**\n           * ### .arguments\n           *\n           * Asserts that the target is an arguments object.\n           *\n           *     function test () {\n           *       expect(arguments).to.be.arguments;\n           *     }\n           *\n           * @name arguments\n           * @alias Arguments\n           * @api public\n           */\n\n      function checkArguments() {\n        var obj = flag(this, 'object'),\n            type = Object.prototype.toString.call(obj);\n        this.assert('[object Arguments]' === type, 'expected #{this} to be arguments but got ' + type, 'expected #{this} to not be arguments');\n      }\n\n      Assertion.addProperty('arguments', checkArguments);\n      Assertion.addProperty('Arguments', checkArguments); /**\n                                                           * ### .equal(value)\n                                                           *\n                                                           * Asserts that the target is strictly equal (`===`) to `value`.\n                                                           * Alternately, if the `deep` flag is set, asserts that\n                                                           * the target is deeply equal to `value`.\n                                                           *\n                                                           *     expect('hello').to.equal('hello');\n                                                           *     expect(42).to.equal(42);\n                                                           *     expect(1).to.not.equal(true);\n                                                           *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n                                                           *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n                                                           *\n                                                           * @name equal\n                                                           * @alias equals\n                                                           * @alias eq\n                                                           * @alias deep.equal\n                                                           * @param {Mixed} value\n                                                           * @param {String} message _optional_\n                                                           * @api public\n                                                           */\n\n      function assertEqual(val, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        if (flag(this, 'deep')) {\n          return this.eql(val);\n        } else {\n          this.assert(val === obj, 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{exp}', val, this._obj, true);\n        }\n      }\n\n      Assertion.addMethod('equal', assertEqual);\n      Assertion.addMethod('equals', assertEqual);\n      Assertion.addMethod('eq', assertEqual); /**\n                                               * ### .eql(value)\n                                               *\n                                               * Asserts that the target is deeply equal to `value`.\n                                               *\n                                               *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n                                               *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n                                               *\n                                               * @name eql\n                                               * @alias eqls\n                                               * @param {Mixed} value\n                                               * @param {String} message _optional_\n                                               * @api public\n                                               */\n\n      function assertEql(obj, msg) {\n        if (msg) flag(this, 'message', msg);\n        this.assert(_.eql(obj, flag(this, 'object')), 'expected #{this} to deeply equal #{exp}', 'expected #{this} to not deeply equal #{exp}', obj, this._obj, true);\n      }\n\n      Assertion.addMethod('eql', assertEql);\n      Assertion.addMethod('eqls', assertEql); /**\n                                               * ### .above(value)\n                                               *\n                                               * Asserts that the target is greater than `value`.\n                                               *\n                                               *     expect(10).to.be.above(5);\n                                               *\n                                               * Can also be used in conjunction with `length` to\n                                               * assert a minimum length. The benefit being a\n                                               * more informative error message than if the length\n                                               * was supplied directly.\n                                               *\n                                               *     expect('foo').to.have.length.above(2);\n                                               *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n                                               *\n                                               * @name above\n                                               * @alias gt\n                                               * @alias greaterThan\n                                               * @param {Number} value\n                                               * @param {String} message _optional_\n                                               * @api public\n                                               */\n\n      function assertAbove(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len > n, 'expected #{this} to have a length above #{exp} but got #{act}', 'expected #{this} to not have a length above #{exp}', n, len);\n        } else {\n          this.assert(obj > n, 'expected #{this} to be above ' + n, 'expected #{this} to be at most ' + n);\n        }\n      }\n\n      Assertion.addMethod('above', assertAbove);\n      Assertion.addMethod('gt', assertAbove);\n      Assertion.addMethod('greaterThan', assertAbove); /**\n                                                        * ### .least(value)\n                                                        *\n                                                        * Asserts that the target is greater than or equal to `value`.\n                                                        *\n                                                        *     expect(10).to.be.at.least(10);\n                                                        *\n                                                        * Can also be used in conjunction with `length` to\n                                                        * assert a minimum length. The benefit being a\n                                                        * more informative error message than if the length\n                                                        * was supplied directly.\n                                                        *\n                                                        *     expect('foo').to.have.length.of.at.least(2);\n                                                        *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n                                                        *\n                                                        * @name least\n                                                        * @alias gte\n                                                        * @param {Number} value\n                                                        * @param {String} message _optional_\n                                                        * @api public\n                                                        */\n\n      function assertLeast(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len >= n, 'expected #{this} to have a length at least #{exp} but got #{act}', 'expected #{this} to have a length below #{exp}', n, len);\n        } else {\n          this.assert(obj >= n, 'expected #{this} to be at least ' + n, 'expected #{this} to be below ' + n);\n        }\n      }\n\n      Assertion.addMethod('least', assertLeast);\n      Assertion.addMethod('gte', assertLeast); /**\n                                                * ### .below(value)\n                                                *\n                                                * Asserts that the target is less than `value`.\n                                                *\n                                                *     expect(5).to.be.below(10);\n                                                *\n                                                * Can also be used in conjunction with `length` to\n                                                * assert a maximum length. The benefit being a\n                                                * more informative error message than if the length\n                                                * was supplied directly.\n                                                *\n                                                *     expect('foo').to.have.length.below(4);\n                                                *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n                                                *\n                                                * @name below\n                                                * @alias lt\n                                                * @alias lessThan\n                                                * @param {Number} value\n                                                * @param {String} message _optional_\n                                                * @api public\n                                                */\n\n      function assertBelow(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len < n, 'expected #{this} to have a length below #{exp} but got #{act}', 'expected #{this} to not have a length below #{exp}', n, len);\n        } else {\n          this.assert(obj < n, 'expected #{this} to be below ' + n, 'expected #{this} to be at least ' + n);\n        }\n      }\n\n      Assertion.addMethod('below', assertBelow);\n      Assertion.addMethod('lt', assertBelow);\n      Assertion.addMethod('lessThan', assertBelow); /**\n                                                     * ### .most(value)\n                                                     *\n                                                     * Asserts that the target is less than or equal to `value`.\n                                                     *\n                                                     *     expect(5).to.be.at.most(5);\n                                                     *\n                                                     * Can also be used in conjunction with `length` to\n                                                     * assert a maximum length. The benefit being a\n                                                     * more informative error message than if the length\n                                                     * was supplied directly.\n                                                     *\n                                                     *     expect('foo').to.have.length.of.at.most(4);\n                                                     *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n                                                     *\n                                                     * @name most\n                                                     * @alias lte\n                                                     * @param {Number} value\n                                                     * @param {String} message _optional_\n                                                     * @api public\n                                                     */\n\n      function assertMost(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len <= n, 'expected #{this} to have a length at most #{exp} but got #{act}', 'expected #{this} to have a length above #{exp}', n, len);\n        } else {\n          this.assert(obj <= n, 'expected #{this} to be at most ' + n, 'expected #{this} to be above ' + n);\n        }\n      }\n\n      Assertion.addMethod('most', assertMost);\n      Assertion.addMethod('lte', assertMost); /**\n                                               * ### .within(start, finish)\n                                               *\n                                               * Asserts that the target is within a range.\n                                               *\n                                               *     expect(7).to.be.within(5,10);\n                                               *\n                                               * Can also be used in conjunction with `length` to\n                                               * assert a length range. The benefit being a\n                                               * more informative error message than if the length\n                                               * was supplied directly.\n                                               *\n                                               *     expect('foo').to.have.length.within(2,4);\n                                               *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n                                               *\n                                               * @name within\n                                               * @param {Number} start lowerbound inclusive\n                                               * @param {Number} finish upperbound inclusive\n                                               * @param {String} message _optional_\n                                               * @api public\n                                               */\n      Assertion.addMethod('within', function (start, finish, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object'),\n            range = start + '..' + finish;\n\n        if (flag(this, 'doLength')) {\n          new Assertion(obj, msg).to.have.property('length');\n          var len = obj.length;\n          this.assert(len >= start && len <= finish, 'expected #{this} to have a length within ' + range, 'expected #{this} to not have a length within ' + range);\n        } else {\n          this.assert(obj >= start && obj <= finish, 'expected #{this} to be within ' + range, 'expected #{this} to not be within ' + range);\n        }\n      }); /**\n           * ### .instanceof(constructor)\n           *\n           * Asserts that the target is an instance of `constructor`.\n           *\n           *     var Tea = function (name) { this.name = name; }\n           *       , Chai = new Tea('chai');\n           *\n           *     expect(Chai).to.be.an.instanceof(Tea);\n           *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n           *\n           * @name instanceof\n           * @param {Constructor} constructor\n           * @param {String} message _optional_\n           * @alias instanceOf\n           * @api public\n           */\n\n      function assertInstanceOf(constructor, msg) {\n        if (msg) flag(this, 'message', msg);\n\n        var name = _.getName(constructor);\n\n        this.assert(flag(this, 'object') instanceof constructor, 'expected #{this} to be an instance of ' + name, 'expected #{this} to not be an instance of ' + name);\n      }\n\n      ;\n      Assertion.addMethod('instanceof', assertInstanceOf);\n      Assertion.addMethod('instanceOf', assertInstanceOf); /**\n                                                            * ### .property(name, [value])\n                                                            *\n                                                            * Asserts that the target has a property `name`, optionally asserting that\n                                                            * the value of that property is strictly equal to  `value`.\n                                                            * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n                                                            * references into objects and arrays.\n                                                            *\n                                                            *     // simple referencing\n                                                            *     var obj = { foo: 'bar' };\n                                                            *     expect(obj).to.have.property('foo');\n                                                            *     expect(obj).to.have.property('foo', 'bar');\n                                                            *\n                                                            *     // deep referencing\n                                                            *     var deepObj = {\n                                                            *         green: { tea: 'matcha' }\n                                                            *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n                                                            *     };\n                                                             *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n                                                            *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n                                                            *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n                                                            *\n                                                            * You can also use an array as the starting point of a `deep.property`\n                                                            * assertion, or traverse nested arrays.\n                                                            *\n                                                            *     var arr = [\n                                                            *         [ 'chai', 'matcha', 'konacha' ]\n                                                            *       , [ { tea: 'chai' }\n                                                            *         , { tea: 'matcha' }\n                                                            *         , { tea: 'konacha' } ]\n                                                            *     ];\n                                                            *\n                                                            *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n                                                            *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n                                                            *\n                                                            * Furthermore, `property` changes the subject of the assertion\n                                                            * to be the value of that property from the original object. This\n                                                            * permits for further chainable assertions on that property.\n                                                            *\n                                                            *     expect(obj).to.have.property('foo')\n                                                            *       .that.is.a('string');\n                                                            *     expect(deepObj).to.have.property('green')\n                                                            *       .that.is.an('object')\n                                                            *       .that.deep.equals({ tea: 'matcha' });\n                                                            *     expect(deepObj).to.have.property('teas')\n                                                            *       .that.is.an('array')\n                                                            *       .with.deep.property('[2]')\n                                                            *         .that.deep.equals({ tea: 'konacha' });\n                                                            *\n                                                            * @name property\n                                                            * @alias deep.property\n                                                            * @param {String} name\n                                                            * @param {Mixed} value (optional)\n                                                            * @param {String} message _optional_\n                                                            * @returns value of property for chaining\n                                                            * @api public\n                                                            */\n      Assertion.addMethod('property', function (name, val, msg) {\n        if (msg) flag(this, 'message', msg);\n        var isDeep = !!flag(this, 'deep'),\n            descriptor = isDeep ? 'deep property ' : 'property ',\n            negate = flag(this, 'negate'),\n            obj = flag(this, 'object'),\n            pathInfo = isDeep ? _.getPathInfo(name, obj) : null,\n            hasProperty = isDeep ? pathInfo.exists : _.hasProperty(name, obj),\n            value = isDeep ? pathInfo.value : obj[name];\n\n        if (negate && undefined !== val) {\n          if (undefined === value) {\n            msg = msg != null ? msg + ': ' : '';\n            throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n          }\n        } else {\n          this.assert(hasProperty, 'expected #{this} to have a ' + descriptor + _.inspect(name), 'expected #{this} to not have ' + descriptor + _.inspect(name));\n        }\n\n        if (undefined !== val) {\n          this.assert(val === value, 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}', 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}', val, value);\n        }\n\n        flag(this, 'object', value);\n      }); /**\n           * ### .ownProperty(name)\n           *\n           * Asserts that the target has an own property `name`.\n           *\n           *     expect('test').to.have.ownProperty('length');\n           *\n           * @name ownProperty\n           * @alias haveOwnProperty\n           * @param {String} name\n           * @param {String} message _optional_\n           * @api public\n           */\n\n      function assertOwnProperty(name, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        this.assert(obj.hasOwnProperty(name), 'expected #{this} to have own property ' + _.inspect(name), 'expected #{this} to not have own property ' + _.inspect(name));\n      }\n\n      Assertion.addMethod('ownProperty', assertOwnProperty);\n      Assertion.addMethod('haveOwnProperty', assertOwnProperty); /**\n                                                                  * ### .length(value)\n                                                                  *\n                                                                  * Asserts that the target's `length` property has\n                                                                  * the expected value.\n                                                                  *\n                                                                  *     expect([ 1, 2, 3]).to.have.length(3);\n                                                                  *     expect('foobar').to.have.length(6);\n                                                                  *\n                                                                  * Can also be used as a chain precursor to a value\n                                                                  * comparison for the length property.\n                                                                  *\n                                                                  *     expect('foo').to.have.length.above(2);\n                                                                  *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n                                                                  *     expect('foo').to.have.length.below(4);\n                                                                  *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n                                                                  *     expect('foo').to.have.length.within(2,4);\n                                                                  *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n                                                                  *\n                                                                  * @name length\n                                                                  * @alias lengthOf\n                                                                  * @param {Number} length\n                                                                  * @param {String} message _optional_\n                                                                  * @api public\n                                                                  */\n\n      function assertLengthChain() {\n        flag(this, 'doLength', true);\n      }\n\n      function assertLength(n, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).to.have.property('length');\n        var len = obj.length;\n        this.assert(len == n, 'expected #{this} to have a length of #{exp} but got #{act}', 'expected #{this} to not have a length of #{act}', n, len);\n      }\n\n      Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n      Assertion.addMethod('lengthOf', assertLength); /**\n                                                      * ### .match(regexp)\n                                                      *\n                                                      * Asserts that the target matches a regular expression.\n                                                      *\n                                                      *     expect('foobar').to.match(/^foo/);\n                                                      *\n                                                      * @name match\n                                                      * @param {RegExp} RegularExpression\n                                                      * @param {String} message _optional_\n                                                      * @api public\n                                                      */\n      Assertion.addMethod('match', function (re, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        this.assert(re.exec(obj), 'expected #{this} to match ' + re, 'expected #{this} not to match ' + re);\n      }); /**\n           * ### .string(string)\n           *\n           * Asserts that the string target contains another string.\n           *\n           *     expect('foobar').to.have.string('bar');\n           *\n           * @name string\n           * @param {String} string\n           * @param {String} message _optional_\n           * @api public\n           */\n      Assertion.addMethod('string', function (str, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).is.a('string');\n        this.assert(~obj.indexOf(str), 'expected #{this} to contain ' + _.inspect(str), 'expected #{this} to not contain ' + _.inspect(str));\n      }); /**\n           * ### .keys(key1, [key2], [...])\n           *\n           * Asserts that the target contains any or all of the passed-in keys.\n           * Use in combination with `any`, `all`, `contains`, or `have` will affect \n           * what will pass.\n           * \n           * When used in conjunction with `any`, at least one key that is passed \n           * in must exist in the target object. This is regardless whether or not \n           * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n           * should be used in the assertion. If neither are used, the assertion is\n           * defaulted to `all`.\n           * \n           * When both `all` and `contain` are used, the target object must have at \n           * least all of the passed-in keys but may have more keys not listed.\n           * \n           * When both `all` and `have` are used, the target object must both contain\n           * all of the passed-in keys AND the number of keys in the target object must\n           * match the number of keys passed in (in other words, a target object must \n           * have all and only all of the passed-in keys).\n           * \n           *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n           *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n           *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n           *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n           *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n           *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n           *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo', 7});\n           *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n           *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([{'bar': 6}}]);\n           *\n           *\n           * @name keys\n           * @alias key\n           * @param {String...|Array|Object} keys\n           * @api public\n           */\n\n      function assertKeys(keys) {\n        var obj = flag(this, 'object'),\n            str,\n            ok = true,\n            mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n        switch (_.type(keys)) {\n          case \"array\":\n            if (arguments.length > 1) throw new Error(mixedArgsMsg);\n            break;\n\n          case \"object\":\n            if (arguments.length > 1) throw new Error(mixedArgsMsg);\n            keys = Object.keys(keys);\n            break;\n\n          default:\n            keys = Array.prototype.slice.call(arguments);\n        }\n\n        if (!keys.length) throw new Error('keys required');\n        var actual = Object.keys(obj),\n            expected = keys,\n            len = keys.length,\n            any = flag(this, 'any'),\n            all = flag(this, 'all');\n\n        if (!any && !all) {\n          all = true;\n        } // Has any\n\n\n        if (any) {\n          var intersection = expected.filter(function (key) {\n            return ~actual.indexOf(key);\n          });\n          ok = intersection.length > 0;\n        } // Has all\n\n\n        if (all) {\n          ok = keys.every(function (key) {\n            return ~actual.indexOf(key);\n          });\n\n          if (!flag(this, 'negate') && !flag(this, 'contains')) {\n            ok = ok && keys.length == actual.length;\n          }\n        } // Key string\n\n\n        if (len > 1) {\n          keys = keys.map(function (key) {\n            return _.inspect(key);\n          });\n          var last = keys.pop();\n\n          if (all) {\n            str = keys.join(', ') + ', and ' + last;\n          }\n\n          if (any) {\n            str = keys.join(', ') + ', or ' + last;\n          }\n        } else {\n          str = _.inspect(keys[0]);\n        } // Form\n\n\n        str = (len > 1 ? 'keys ' : 'key ') + str; // Have / include\n\n        str = (flag(this, 'contains') ? 'contain ' : 'have ') + str; // Assertion\n\n        this.assert(ok, 'expected #{this} to ' + str, 'expected #{this} to not ' + str, expected.slice(0).sort(), actual.sort(), true);\n      }\n\n      Assertion.addMethod('keys', assertKeys);\n      Assertion.addMethod('key', assertKeys); /**\n                                               * ### .throw(constructor)\n                                               *\n                                               * Asserts that the function target will throw a specific error, or specific type of error\n                                               * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n                                               * for the error's message.\n                                               *\n                                               *     var err = new ReferenceError('This is a bad function.');\n                                               *     var fn = function () { throw err; }\n                                               *     expect(fn).to.throw(ReferenceError);\n                                               *     expect(fn).to.throw(Error);\n                                               *     expect(fn).to.throw(/bad function/);\n                                               *     expect(fn).to.not.throw('good function');\n                                               *     expect(fn).to.throw(ReferenceError, /bad function/);\n                                               *     expect(fn).to.throw(err);\n                                               *     expect(fn).to.not.throw(new RangeError('Out of range.'));\n                                               *\n                                               * Please note that when a throw expectation is negated, it will check each\n                                               * parameter independently, starting with error constructor type. The appropriate way\n                                               * to check for the existence of a type of error but for a message that does not match\n                                               * is to use `and`.\n                                               *\n                                               *     expect(fn).to.throw(ReferenceError)\n                                               *        .and.not.throw(/good function/);\n                                               *\n                                               * @name throw\n                                               * @alias throws\n                                               * @alias Throw\n                                               * @param {ErrorConstructor} constructor\n                                               * @param {String|RegExp} expected error message\n                                               * @param {String} message _optional_\n                                               * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n                                               * @returns error for chaining (null if no error)\n                                               * @api public\n                                               */\n\n      function assertThrows(constructor, errMsg, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).is.a('function');\n        var thrown = false,\n            desiredError = null,\n            name = null,\n            thrownError = null;\n\n        if (arguments.length === 0) {\n          errMsg = null;\n          constructor = null;\n        } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n          errMsg = constructor;\n          constructor = null;\n        } else if (constructor && constructor instanceof Error) {\n          desiredError = constructor;\n          constructor = null;\n          errMsg = null;\n        } else if (typeof constructor === 'function') {\n          name = constructor.prototype.name || constructor.name;\n\n          if (name === 'Error' && constructor !== Error) {\n            name = new constructor().name;\n          }\n        } else {\n          constructor = null;\n        }\n\n        try {\n          obj();\n        } catch (err) {\n          // first, check desired error\n          if (desiredError) {\n            this.assert(err === desiredError, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp}', desiredError instanceof Error ? desiredError.toString() : desiredError, err instanceof Error ? err.toString() : err);\n            flag(this, 'object', err);\n            return this;\n          } // next, check constructor\n\n\n          if (constructor) {\n            this.assert(err instanceof constructor, 'expected #{this} to throw #{exp} but #{act} was thrown', 'expected #{this} to not throw #{exp} but #{act} was thrown', name, err instanceof Error ? err.toString() : err);\n\n            if (!errMsg) {\n              flag(this, 'object', err);\n              return this;\n            }\n          } // next, check message\n\n\n          var message = 'object' === _.type(err) && \"message\" in err ? err.message : '' + err;\n\n          if (message != null && errMsg && errMsg instanceof RegExp) {\n            this.assert(errMsg.exec(message), 'expected #{this} to throw error matching #{exp} but got #{act}', 'expected #{this} to throw error not matching #{exp}', errMsg, message);\n            flag(this, 'object', err);\n            return this;\n          } else if (message != null && errMsg && 'string' === typeof errMsg) {\n            this.assert(~message.indexOf(errMsg), 'expected #{this} to throw error including #{exp} but got #{act}', 'expected #{this} to throw error not including #{act}', errMsg, message);\n            flag(this, 'object', err);\n            return this;\n          } else {\n            thrown = true;\n            thrownError = err;\n          }\n        }\n\n        var actuallyGot = '',\n            expectedThrown = name !== null ? name : desiredError ? '#{exp}' //_.inspect(desiredError)\n        : 'an error';\n\n        if (thrown) {\n          actuallyGot = ' but #{act} was thrown';\n        }\n\n        this.assert(thrown === true, 'expected #{this} to throw ' + expectedThrown + actuallyGot, 'expected #{this} to not throw ' + expectedThrown + actuallyGot, desiredError instanceof Error ? desiredError.toString() : desiredError, thrownError instanceof Error ? thrownError.toString() : thrownError);\n        flag(this, 'object', thrownError);\n      }\n\n      ;\n      Assertion.addMethod('throw', assertThrows);\n      Assertion.addMethod('throws', assertThrows);\n      Assertion.addMethod('Throw', assertThrows); /**\n                                                   * ### .respondTo(method)\n                                                   *\n                                                   * Asserts that the object or class target will respond to a method.\n                                                   *\n                                                   *     Klass.prototype.bar = function(){};\n                                                   *     expect(Klass).to.respondTo('bar');\n                                                   *     expect(obj).to.respondTo('bar');\n                                                   *\n                                                   * To check if a constructor will respond to a static function,\n                                                   * set the `itself` flag.\n                                                   *\n                                                   *     Klass.baz = function(){};\n                                                   *     expect(Klass).itself.to.respondTo('baz');\n                                                   *\n                                                   * @name respondTo\n                                                   * @param {String} method\n                                                   * @param {String} message _optional_\n                                                   * @api public\n                                                   */\n      Assertion.addMethod('respondTo', function (method, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object'),\n            itself = flag(this, 'itself'),\n            context = 'function' === _.type(obj) && !itself ? obj.prototype[method] : obj[method];\n        this.assert('function' === typeof context, 'expected #{this} to respond to ' + _.inspect(method), 'expected #{this} to not respond to ' + _.inspect(method));\n      }); /**\n           * ### .itself\n           *\n           * Sets the `itself` flag, later used by the `respondTo` assertion.\n           *\n           *     function Foo() {}\n           *     Foo.bar = function() {}\n           *     Foo.prototype.baz = function() {}\n           *\n           *     expect(Foo).itself.to.respondTo('bar');\n           *     expect(Foo).itself.not.to.respondTo('baz');\n           *\n           * @name itself\n           * @api public\n           */\n      Assertion.addProperty('itself', function () {\n        flag(this, 'itself', true);\n      }); /**\n           * ### .satisfy(method)\n           *\n           * Asserts that the target passes a given truth test.\n           *\n           *     expect(1).to.satisfy(function(num) { return num > 0; });\n           *\n           * @name satisfy\n           * @param {Function} matcher\n           * @param {String} message _optional_\n           * @api public\n           */\n      Assertion.addMethod('satisfy', function (matcher, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        var result = matcher(obj);\n        this.assert(result, 'expected #{this} to satisfy ' + _.objDisplay(matcher), 'expected #{this} to not satisfy' + _.objDisplay(matcher), this.negate ? false : true, result);\n      }); /**\n           * ### .closeTo(expected, delta)\n           *\n           * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n           *\n           *     expect(1.5).to.be.closeTo(1, 0.5);\n           *\n           * @name closeTo\n           * @param {Number} expected\n           * @param {Number} delta\n           * @param {String} message _optional_\n           * @api public\n           */\n      Assertion.addMethod('closeTo', function (expected, delta, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj, msg).is.a('number');\n\n        if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n          throw new Error('the arguments to closeTo must be numbers');\n        }\n\n        this.assert(Math.abs(obj - expected) <= delta, 'expected #{this} to be close to ' + expected + ' +/- ' + delta, 'expected #{this} not to be close to ' + expected + ' +/- ' + delta);\n      });\n\n      function isSubsetOf(subset, superset, cmp) {\n        return subset.every(function (elem) {\n          if (!cmp) return superset.indexOf(elem) !== -1;\n          return superset.some(function (elem2) {\n            return cmp(elem, elem2);\n          });\n        });\n      } /**\n         * ### .members(set)\n         *\n         * Asserts that the target is a superset of `set`,\n         * or that the target and `set` have the same strictly-equal (===) members.\n         * Alternately, if the `deep` flag is set, set members are compared for deep\n         * equality.\n         *\n         *     expect([1, 2, 3]).to.include.members([3, 2]);\n         *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n         *\n         *     expect([4, 2]).to.have.members([2, 4]);\n         *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n         *\n         *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n         *\n         * @name members\n         * @param {Array} set\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      Assertion.addMethod('members', function (subset, msg) {\n        if (msg) flag(this, 'message', msg);\n        var obj = flag(this, 'object');\n        new Assertion(obj).to.be.an('array');\n        new Assertion(subset).to.be.an('array');\n        var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n        if (flag(this, 'contains')) {\n          return this.assert(isSubsetOf(subset, obj, cmp), 'expected #{this} to be a superset of #{act}', 'expected #{this} to not be a superset of #{act}', obj, subset);\n        }\n\n        this.assert(isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp), 'expected #{this} to have the same members as #{act}', 'expected #{this} to not have the same members as #{act}', obj, subset);\n      }); /**\n           * ### .change(function)\n           *\n           * Asserts that a function changes an object property\n           *\n           *     var obj = { val: 10 };\n           *     var fn = function() { obj.val += 3 };\n           *     var noChangeFn = function() { return 'foo' + 'bar'; }\n           *     expect(fn).to.change(obj, 'val');\n           *     expect(noChangFn).to.not.change(obj, 'val')\n           *\n           * @name change\n           * @alias changes\n           * @alias Change\n           * @param {String} object\n           * @param {String} property name\n           * @param {String} message _optional_\n           * @api public\n           */\n\n      function assertChanges(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n        var initial = object[prop];\n        fn();\n        this.assert(initial !== object[prop], 'expected .' + prop + ' to change', 'expected .' + prop + ' to not change');\n      }\n\n      Assertion.addChainableMethod('change', assertChanges);\n      Assertion.addChainableMethod('changes', assertChanges); /**\n                                                               * ### .increase(function)\n                                                               *\n                                                               * Asserts that a function increases an object property\n                                                               *\n                                                               *     var obj = { val: 10 };\n                                                               *     var fn = function() { obj.val = 15 };\n                                                               *     expect(fn).to.increase(obj, 'val');\n                                                               *\n                                                               * @name increase\n                                                               * @alias increases\n                                                               * @alias Increase\n                                                               * @param {String} object\n                                                               * @param {String} property name\n                                                               * @param {String} message _optional_\n                                                               * @api public\n                                                               */\n\n      function assertIncreases(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n        var initial = object[prop];\n        fn();\n        this.assert(object[prop] - initial > 0, 'expected .' + prop + ' to increase', 'expected .' + prop + ' to not increase');\n      }\n\n      Assertion.addChainableMethod('increase', assertIncreases);\n      Assertion.addChainableMethod('increases', assertIncreases); /**\n                                                                   * ### .decrease(function)\n                                                                   *\n                                                                   * Asserts that a function decreases an object property\n                                                                   *\n                                                                   *     var obj = { val: 10 };\n                                                                   *     var fn = function() { obj.val = 5 };\n                                                                   *     expect(fn).to.decrease(obj, 'val');\n                                                                   *\n                                                                   * @name decrease\n                                                                   * @alias decreases\n                                                                   * @alias Decrease\n                                                                   * @param {String} object\n                                                                   * @param {String} property name\n                                                                   * @param {String} message _optional_\n                                                                   * @api public\n                                                                   */\n\n      function assertDecreases(object, prop, msg) {\n        if (msg) flag(this, 'message', msg);\n        var fn = flag(this, 'object');\n        new Assertion(object, msg).to.have.property(prop);\n        new Assertion(fn).is.a('function');\n        var initial = object[prop];\n        fn();\n        this.assert(object[prop] - initial < 0, 'expected .' + prop + ' to decrease', 'expected .' + prop + ' to not decrease');\n      }\n\n      Assertion.addChainableMethod('decrease', assertDecreases);\n      Assertion.addChainableMethod('decreases', assertDecreases);\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/assert.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */module.exports = function (chai, util) {\n      /*!\n       * Chai dependencies.\n       */var Assertion = chai.Assertion,\n          flag = util.flag; /*!\n                             * Module export.\n                             */ /**\n                                 * ### assert(expression, message)\n                                 *\n                                 * Write your own test expressions.\n                                 *\n                                 *     assert('foo' !== 'bar', 'foo is not bar');\n                                 *     assert(Array.isArray([]), 'empty arrays are arrays');\n                                 *\n                                 * @param {Mixed} expression to test for truthiness\n                                 * @param {String} message to display on error\n                                 * @name assert\n                                 * @api public\n                                 */\n\n      var assert = chai.assert = function (express, errmsg) {\n        var test = new Assertion(null, null, chai.assert);\n        test.assert(express, errmsg, '[ negation message unavailable ]');\n      }; /**\n          * ### .fail(actual, expected, [message], [operator])\n          *\n          * Throw a failure. Node.js `assert` module-compatible.\n          *\n          * @name fail\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @param {String} operator\n          * @api public\n          */\n\n      assert.fail = function (actual, expected, message, operator) {\n        message = message || 'assert.fail()';\n        throw new chai.AssertionError(message, {\n          actual: actual,\n          expected: expected,\n          operator: operator\n        }, assert.fail);\n      }; /**\n          * ### .ok(object, [message])\n          *\n          * Asserts that `object` is truthy.\n          *\n          *     assert.ok('everything', 'everything is ok');\n          *     assert.ok(false, 'this will fail');\n          *\n          * @name ok\n          * @param {Mixed} object to test\n          * @param {String} message\n          * @api public\n          */\n\n      assert.ok = function (val, msg) {\n        new Assertion(val, msg).is.ok;\n      }; /**\n          * ### .notOk(object, [message])\n          *\n          * Asserts that `object` is falsy.\n          *\n          *     assert.notOk('everything', 'this will fail');\n          *     assert.notOk(false, 'this will pass');\n          *\n          * @name notOk\n          * @param {Mixed} object to test\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notOk = function (val, msg) {\n        new Assertion(val, msg).is.not.ok;\n      }; /**\n          * ### .equal(actual, expected, [message])\n          *\n          * Asserts non-strict equality (`==`) of `actual` and `expected`.\n          *\n          *     assert.equal(3, '3', '== coerces values to strings');\n          *\n          * @name equal\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.equal = function (act, exp, msg) {\n        var test = new Assertion(act, msg, assert.equal);\n        test.assert(exp == flag(test, 'object'), 'expected #{this} to equal #{exp}', 'expected #{this} to not equal #{act}', exp, act);\n      }; /**\n          * ### .notEqual(actual, expected, [message])\n          *\n          * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n          *\n          *     assert.notEqual(3, 4, 'these numbers are not equal');\n          *\n          * @name notEqual\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notEqual = function (act, exp, msg) {\n        var test = new Assertion(act, msg, assert.notEqual);\n        test.assert(exp != flag(test, 'object'), 'expected #{this} to not equal #{exp}', 'expected #{this} to equal #{act}', exp, act);\n      }; /**\n          * ### .strictEqual(actual, expected, [message])\n          *\n          * Asserts strict equality (`===`) of `actual` and `expected`.\n          *\n          *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n          *\n          * @name strictEqual\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.strictEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.equal(exp);\n      }; /**\n          * ### .notStrictEqual(actual, expected, [message])\n          *\n          * Asserts strict inequality (`!==`) of `actual` and `expected`.\n          *\n          *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n          *\n          * @name notStrictEqual\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notStrictEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.not.equal(exp);\n      }; /**\n          * ### .deepEqual(actual, expected, [message])\n          *\n          * Asserts that `actual` is deeply equal to `expected`.\n          *\n          *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n          *\n          * @name deepEqual\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.deepEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.eql(exp);\n      }; /**\n          * ### .notDeepEqual(actual, expected, [message])\n          *\n          * Assert that `actual` is not deeply equal to `expected`.\n          *\n          *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n          *\n          * @name notDeepEqual\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notDeepEqual = function (act, exp, msg) {\n        new Assertion(act, msg).to.not.eql(exp);\n      }; /**\n          * ### .isTrue(value, [message])\n          *\n          * Asserts that `value` is true.\n          *\n          *     var teaServed = true;\n          *     assert.isTrue(teaServed, 'the tea has been served');\n          *\n          * @name isTrue\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isAbove = function (val, abv, msg) {\n        new Assertion(val, msg).to.be.above(abv);\n      }; /**\n         * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n         *\n         * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n         *\n         *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n         *\n         * @name isAbove\n         * @param {Mixed} valueToCheck\n         * @param {Mixed} valueToBeAbove\n         * @param {String} message\n         * @api public\n         */\n\n      assert.isBelow = function (val, blw, msg) {\n        new Assertion(val, msg).to.be.below(blw);\n      }; /**\n         * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n         *\n         * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n         *\n         *     assert.isBelow(3, 6, '3 is strictly less than 6');\n         *\n         * @name isBelow\n         * @param {Mixed} valueToCheck\n         * @param {Mixed} valueToBeBelow\n         * @param {String} message\n         * @api public\n         */\n\n      assert.isTrue = function (val, msg) {\n        new Assertion(val, msg).is['true'];\n      }; /**\n          * ### .isFalse(value, [message])\n          *\n          * Asserts that `value` is false.\n          *\n          *     var teaServed = false;\n          *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n          *\n          * @name isFalse\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isFalse = function (val, msg) {\n        new Assertion(val, msg).is['false'];\n      }; /**\n          * ### .isNull(value, [message])\n          *\n          * Asserts that `value` is null.\n          *\n          *     assert.isNull(err, 'there was no error');\n          *\n          * @name isNull\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNull = function (val, msg) {\n        new Assertion(val, msg).to.equal(null);\n      }; /**\n          * ### .isNotNull(value, [message])\n          *\n          * Asserts that `value` is not null.\n          *\n          *     var tea = 'tasty chai';\n          *     assert.isNotNull(tea, 'great, time for tea!');\n          *\n          * @name isNotNull\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotNull = function (val, msg) {\n        new Assertion(val, msg).to.not.equal(null);\n      }; /**\n          * ### .isUndefined(value, [message])\n          *\n          * Asserts that `value` is `undefined`.\n          *\n          *     var tea;\n          *     assert.isUndefined(tea, 'no tea defined');\n          *\n          * @name isUndefined\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isUndefined = function (val, msg) {\n        new Assertion(val, msg).to.equal(undefined);\n      }; /**\n          * ### .isDefined(value, [message])\n          *\n          * Asserts that `value` is not `undefined`.\n          *\n          *     var tea = 'cup of chai';\n          *     assert.isDefined(tea, 'tea has been defined');\n          *\n          * @name isDefined\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isDefined = function (val, msg) {\n        new Assertion(val, msg).to.not.equal(undefined);\n      }; /**\n          * ### .isFunction(value, [message])\n          *\n          * Asserts that `value` is a function.\n          *\n          *     function serveTea() { return 'cup of tea'; };\n          *     assert.isFunction(serveTea, 'great, we can have tea now');\n          *\n          * @name isFunction\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isFunction = function (val, msg) {\n        new Assertion(val, msg).to.be.a('function');\n      }; /**\n          * ### .isNotFunction(value, [message])\n          *\n          * Asserts that `value` is _not_ a function.\n          *\n          *     var serveTea = [ 'heat', 'pour', 'sip' ];\n          *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n          *\n          * @name isNotFunction\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotFunction = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('function');\n      }; /**\n          * ### .isObject(value, [message])\n          *\n          * Asserts that `value` is an object (as revealed by\n          * `Object.prototype.toString`).\n          *\n          *     var selection = { name: 'Chai', serve: 'with spices' };\n          *     assert.isObject(selection, 'tea selection is an object');\n          *\n          * @name isObject\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isObject = function (val, msg) {\n        new Assertion(val, msg).to.be.a('object');\n      }; /**\n          * ### .isNotObject(value, [message])\n          *\n          * Asserts that `value` is _not_ an object.\n          *\n          *     var selection = 'chai'\n          *     assert.isNotObject(selection, 'tea selection is not an object');\n          *     assert.isNotObject(null, 'null is not an object');\n          *\n          * @name isNotObject\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotObject = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('object');\n      }; /**\n          * ### .isArray(value, [message])\n          *\n          * Asserts that `value` is an array.\n          *\n          *     var menu = [ 'green', 'chai', 'oolong' ];\n          *     assert.isArray(menu, 'what kind of tea do we want?');\n          *\n          * @name isArray\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isArray = function (val, msg) {\n        new Assertion(val, msg).to.be.an('array');\n      }; /**\n          * ### .isNotArray(value, [message])\n          *\n          * Asserts that `value` is _not_ an array.\n          *\n          *     var menu = 'green|chai|oolong';\n          *     assert.isNotArray(menu, 'what kind of tea do we want?');\n          *\n          * @name isNotArray\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotArray = function (val, msg) {\n        new Assertion(val, msg).to.not.be.an('array');\n      }; /**\n          * ### .isString(value, [message])\n          *\n          * Asserts that `value` is a string.\n          *\n          *     var teaOrder = 'chai';\n          *     assert.isString(teaOrder, 'order placed');\n          *\n          * @name isString\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isString = function (val, msg) {\n        new Assertion(val, msg).to.be.a('string');\n      }; /**\n          * ### .isNotString(value, [message])\n          *\n          * Asserts that `value` is _not_ a string.\n          *\n          *     var teaOrder = 4;\n          *     assert.isNotString(teaOrder, 'order placed');\n          *\n          * @name isNotString\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotString = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('string');\n      }; /**\n          * ### .isNumber(value, [message])\n          *\n          * Asserts that `value` is a number.\n          *\n          *     var cups = 2;\n          *     assert.isNumber(cups, 'how many cups');\n          *\n          * @name isNumber\n          * @param {Number} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNumber = function (val, msg) {\n        new Assertion(val, msg).to.be.a('number');\n      }; /**\n          * ### .isNotNumber(value, [message])\n          *\n          * Asserts that `value` is _not_ a number.\n          *\n          *     var cups = '2 cups please';\n          *     assert.isNotNumber(cups, 'how many cups');\n          *\n          * @name isNotNumber\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotNumber = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('number');\n      }; /**\n          * ### .isBoolean(value, [message])\n          *\n          * Asserts that `value` is a boolean.\n          *\n          *     var teaReady = true\n          *       , teaServed = false;\n          *\n          *     assert.isBoolean(teaReady, 'is the tea ready');\n          *     assert.isBoolean(teaServed, 'has tea been served');\n          *\n          * @name isBoolean\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isBoolean = function (val, msg) {\n        new Assertion(val, msg).to.be.a('boolean');\n      }; /**\n          * ### .isNotBoolean(value, [message])\n          *\n          * Asserts that `value` is _not_ a boolean.\n          *\n          *     var teaReady = 'yep'\n          *       , teaServed = 'nope';\n          *\n          *     assert.isNotBoolean(teaReady, 'is the tea ready');\n          *     assert.isNotBoolean(teaServed, 'has tea been served');\n          *\n          * @name isNotBoolean\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.isNotBoolean = function (val, msg) {\n        new Assertion(val, msg).to.not.be.a('boolean');\n      }; /**\n          * ### .typeOf(value, name, [message])\n          *\n          * Asserts that `value`'s type is `name`, as determined by\n          * `Object.prototype.toString`.\n          *\n          *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n          *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n          *     assert.typeOf('tea', 'string', 'we have a string');\n          *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n          *     assert.typeOf(null, 'null', 'we have a null');\n          *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n          *\n          * @name typeOf\n          * @param {Mixed} value\n          * @param {String} name\n          * @param {String} message\n          * @api public\n          */\n\n      assert.typeOf = function (val, type, msg) {\n        new Assertion(val, msg).to.be.a(type);\n      }; /**\n          * ### .notTypeOf(value, name, [message])\n          *\n          * Asserts that `value`'s type is _not_ `name`, as determined by\n          * `Object.prototype.toString`.\n          *\n          *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n          *\n          * @name notTypeOf\n          * @param {Mixed} value\n          * @param {String} typeof name\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notTypeOf = function (val, type, msg) {\n        new Assertion(val, msg).to.not.be.a(type);\n      }; /**\n          * ### .instanceOf(object, constructor, [message])\n          *\n          * Asserts that `value` is an instance of `constructor`.\n          *\n          *     var Tea = function (name) { this.name = name; }\n          *       , chai = new Tea('chai');\n          *\n          *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n          *\n          * @name instanceOf\n          * @param {Object} object\n          * @param {Constructor} constructor\n          * @param {String} message\n          * @api public\n          */\n\n      assert.instanceOf = function (val, type, msg) {\n        new Assertion(val, msg).to.be.instanceOf(type);\n      }; /**\n          * ### .notInstanceOf(object, constructor, [message])\n          *\n          * Asserts `value` is not an instance of `constructor`.\n          *\n          *     var Tea = function (name) { this.name = name; }\n          *       , chai = new String('chai');\n          *\n          *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n          *\n          * @name notInstanceOf\n          * @param {Object} object\n          * @param {Constructor} constructor\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notInstanceOf = function (val, type, msg) {\n        new Assertion(val, msg).to.not.be.instanceOf(type);\n      }; /**\n          * ### .include(haystack, needle, [message])\n          *\n          * Asserts that `haystack` includes `needle`. Works\n          * for strings and arrays.\n          *\n          *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n          *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n          *\n          * @name include\n          * @param {Array|String} haystack\n          * @param {Mixed} needle\n          * @param {String} message\n          * @api public\n          */\n\n      assert.include = function (exp, inc, msg) {\n        new Assertion(exp, msg, assert.include).include(inc);\n      }; /**\n          * ### .notInclude(haystack, needle, [message])\n          *\n          * Asserts that `haystack` does not include `needle`. Works\n          * for strings and arrays.\n          *i\n          *     assert.notInclude('foobar', 'baz', 'string not include substring');\n          *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n          *\n          * @name notInclude\n          * @param {Array|String} haystack\n          * @param {Mixed} needle\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notInclude = function (exp, inc, msg) {\n        new Assertion(exp, msg, assert.notInclude).not.include(inc);\n      }; /**\n          * ### .match(value, regexp, [message])\n          *\n          * Asserts that `value` matches the regular expression `regexp`.\n          *\n          *     assert.match('foobar', /^foo/, 'regexp matches');\n          *\n          * @name match\n          * @param {Mixed} value\n          * @param {RegExp} regexp\n          * @param {String} message\n          * @api public\n          */\n\n      assert.match = function (exp, re, msg) {\n        new Assertion(exp, msg).to.match(re);\n      }; /**\n          * ### .notMatch(value, regexp, [message])\n          *\n          * Asserts that `value` does not match the regular expression `regexp`.\n          *\n          *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n          *\n          * @name notMatch\n          * @param {Mixed} value\n          * @param {RegExp} regexp\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notMatch = function (exp, re, msg) {\n        new Assertion(exp, msg).to.not.match(re);\n      }; /**\n          * ### .property(object, property, [message])\n          *\n          * Asserts that `object` has a property named by `property`.\n          *\n          *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n          *\n          * @name property\n          * @param {Object} object\n          * @param {String} property\n          * @param {String} message\n          * @api public\n          */\n\n      assert.property = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.have.property(prop);\n      }; /**\n          * ### .notProperty(object, property, [message])\n          *\n          * Asserts that `object` does _not_ have a property named by `property`.\n          *\n          *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n          *\n          * @name notProperty\n          * @param {Object} object\n          * @param {String} property\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.not.have.property(prop);\n      }; /**\n          * ### .deepProperty(object, property, [message])\n          *\n          * Asserts that `object` has a property named by `property`, which can be a\n          * string using dot- and bracket-notation for deep reference.\n          *\n          *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n          *\n          * @name deepProperty\n          * @param {Object} object\n          * @param {String} property\n          * @param {String} message\n          * @api public\n          */\n\n      assert.deepProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.have.deep.property(prop);\n      }; /**\n          * ### .notDeepProperty(object, property, [message])\n          *\n          * Asserts that `object` does _not_ have a property named by `property`, which\n          * can be a string using dot- and bracket-notation for deep reference.\n          *\n          *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n          *\n          * @name notDeepProperty\n          * @param {Object} object\n          * @param {String} property\n          * @param {String} message\n          * @api public\n          */\n\n      assert.notDeepProperty = function (obj, prop, msg) {\n        new Assertion(obj, msg).to.not.have.deep.property(prop);\n      }; /**\n          * ### .propertyVal(object, property, value, [message])\n          *\n          * Asserts that `object` has a property named by `property` with value given\n          * by `value`.\n          *\n          *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n          *\n          * @name propertyVal\n          * @param {Object} object\n          * @param {String} property\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.propertyVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.have.property(prop, val);\n      }; /**\n          * ### .propertyNotVal(object, property, value, [message])\n          *\n          * Asserts that `object` has a property named by `property`, but with a value\n          * different from that given by `value`.\n          *\n          *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n          *\n          * @name propertyNotVal\n          * @param {Object} object\n          * @param {String} property\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.propertyNotVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.not.have.property(prop, val);\n      }; /**\n          * ### .deepPropertyVal(object, property, value, [message])\n          *\n          * Asserts that `object` has a property named by `property` with value given\n          * by `value`. `property` can use dot- and bracket-notation for deep\n          * reference.\n          *\n          *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n          *\n          * @name deepPropertyVal\n          * @param {Object} object\n          * @param {String} property\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.deepPropertyVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.have.deep.property(prop, val);\n      }; /**\n          * ### .deepPropertyNotVal(object, property, value, [message])\n          *\n          * Asserts that `object` has a property named by `property`, but with a value\n          * different from that given by `value`. `property` can use dot- and\n          * bracket-notation for deep reference.\n          *\n          *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n          *\n          * @name deepPropertyNotVal\n          * @param {Object} object\n          * @param {String} property\n          * @param {Mixed} value\n          * @param {String} message\n          * @api public\n          */\n\n      assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n        new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n      }; /**\n          * ### .lengthOf(object, length, [message])\n          *\n          * Asserts that `object` has a `length` property with the expected value.\n          *\n          *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n          *     assert.lengthOf('foobar', 5, 'string has length of 6');\n          *\n          * @name lengthOf\n          * @param {Mixed} object\n          * @param {Number} length\n          * @param {String} message\n          * @api public\n          */\n\n      assert.lengthOf = function (exp, len, msg) {\n        new Assertion(exp, msg).to.have.length(len);\n      }; /**\n          * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n          *\n          * Asserts that `function` will throw an error that is an instance of\n          * `constructor`, or alternately that it will throw an error with message\n          * matching `regexp`.\n          *\n          *     assert.throw(fn, 'function throws a reference error');\n          *     assert.throw(fn, /function throws a reference error/);\n          *     assert.throw(fn, ReferenceError);\n          *     assert.throw(fn, ReferenceError, 'function throws a reference error');\n          *     assert.throw(fn, ReferenceError, /function throws a reference error/);\n          *\n          * @name throws\n          * @alias throw\n          * @alias Throw\n          * @param {Function} function\n          * @param {ErrorConstructor} constructor\n          * @param {RegExp} regexp\n          * @param {String} message\n          * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n          * @api public\n          */\n\n      assert.Throw = function (fn, errt, errs, msg) {\n        if ('string' === typeof errt || errt instanceof RegExp) {\n          errs = errt;\n          errt = null;\n        }\n\n        var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);\n        return flag(assertErr, 'object');\n      }; /**\n          * ### .doesNotThrow(function, [constructor/regexp], [message])\n          *\n          * Asserts that `function` will _not_ throw an error that is an instance of\n          * `constructor`, or alternately that it will not throw an error with message\n          * matching `regexp`.\n          *\n          *     assert.doesNotThrow(fn, Error, 'function does not throw');\n          *\n          * @name doesNotThrow\n          * @param {Function} function\n          * @param {ErrorConstructor} constructor\n          * @param {RegExp} regexp\n          * @param {String} message\n          * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n          * @api public\n          */\n\n      assert.doesNotThrow = function (fn, type, msg) {\n        if ('string' === typeof type) {\n          msg = type;\n          type = null;\n        }\n\n        new Assertion(fn, msg).to.not.Throw(type);\n      }; /**\n          * ### .operator(val1, operator, val2, [message])\n          *\n          * Compares two values using `operator`.\n          *\n          *     assert.operator(1, '<', 2, 'everything is ok');\n          *     assert.operator(1, '>', 2, 'this will fail');\n          *\n          * @name operator\n          * @param {Mixed} val1\n          * @param {String} operator\n          * @param {Mixed} val2\n          * @param {String} message\n          * @api public\n          */\n\n      assert.operator = function (val, operator, val2, msg) {\n        if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\n          throw new Error('Invalid operator \"' + operator + '\"');\n        }\n\n        var test = new Assertion(eval(val + operator + val2), msg);\n        test.assert(true === flag(test, 'object'), 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2), 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2));\n      }; /**\n          * ### .closeTo(actual, expected, delta, [message])\n          *\n          * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n          *\n          *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n          *\n          * @name closeTo\n          * @param {Number} actual\n          * @param {Number} expected\n          * @param {Number} delta\n          * @param {String} message\n          * @api public\n          */\n\n      assert.closeTo = function (act, exp, delta, msg) {\n        new Assertion(act, msg).to.be.closeTo(exp, delta);\n      }; /**\n          * ### .sameMembers(set1, set2, [message])\n          *\n          * Asserts that `set1` and `set2` have the same members.\n          * Order is not taken into account.\n          *\n          *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n          *\n          * @name sameMembers\n          * @param {Array} set1\n          * @param {Array} set2\n          * @param {String} message\n          * @api public\n          */\n\n      assert.sameMembers = function (set1, set2, msg) {\n        new Assertion(set1, msg).to.have.same.members(set2);\n      }; /**\n          * ### .sameDeepMembers(set1, set2, [message])\n          *\n          * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n          * Order is not taken into account.\n          *\n          *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n          *\n          * @name sameDeepMembers\n          * @param {Array} set1\n          * @param {Array} set2\n          * @param {String} message\n          * @api public\n          */\n\n      assert.sameDeepMembers = function (set1, set2, msg) {\n        new Assertion(set1, msg).to.have.same.deep.members(set2);\n      }; /**\n          * ### .includeMembers(superset, subset, [message])\n          *\n          * Asserts that `subset` is included in `superset`.\n          * Order is not taken into account.\n          *\n          *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n          *\n          * @name includeMembers\n          * @param {Array} superset\n          * @param {Array} subset\n          * @param {String} message\n          * @api public\n          */\n\n      assert.includeMembers = function (superset, subset, msg) {\n        new Assertion(superset, msg).to.include.members(subset);\n      }; /**\n         * ### .changes(function, object, property)\n         *\n         * Asserts that a function changes the value of a property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { obj.val = 22 };\n         *     assert.changes(fn, obj, 'val');\n         *\n         * @name changes\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.changes = function (fn, obj, prop) {\n        new Assertion(fn).to.change(obj, prop);\n      }; /**\n         * ### .doesNotChange(function, object, property)\n         *\n         * Asserts that a function does not changes the value of a property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { console.log('foo'); };\n         *     assert.doesNotChange(fn, obj, 'val');\n         *\n         * @name doesNotChange\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.doesNotChange = function (fn, obj, prop) {\n        new Assertion(fn).to.not.change(obj, prop);\n      }; /**\n         * ### .increases(function, object, property)\n         *\n         * Asserts that a function increases an object property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { obj.val = 13 };\n         *     assert.increases(fn, obj, 'val');\n         *\n         * @name increases\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.increases = function (fn, obj, prop) {\n        new Assertion(fn).to.increase(obj, prop);\n      }; /**\n         * ### .doesNotIncrease(function, object, property)\n         *\n         * Asserts that a function does not increase object property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { obj.val = 8 };\n         *     assert.doesNotIncrease(fn, obj, 'val');\n         *\n         * @name doesNotIncrease\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.doesNotIncrease = function (fn, obj, prop) {\n        new Assertion(fn).to.not.increase(obj, prop);\n      }; /**\n         * ### .decreases(function, object, property)\n         *\n         * Asserts that a function decreases an object property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { obj.val = 5 };\n         *     assert.decreases(fn, obj, 'val');\n         *\n         * @name decreases\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.decreases = function (fn, obj, prop) {\n        new Assertion(fn).to.decrease(obj, prop);\n      }; /**\n         * ### .doesNotDecrease(function, object, property)\n         *\n         * Asserts that a function does not decreases an object property\n         *\n         *     var obj = { val: 10 };\n         *     var fn = function() { obj.val = 15 };\n         *     assert.doesNotDecrease(fn, obj, 'val');\n         *\n         * @name doesNotDecrease\n         * @param {Function} modifier function\n         * @param {Object} object\n         * @param {String} property name\n         * @param {String} message _optional_\n         * @api public\n         */\n\n      assert.doesNotDecrease = function (fn, obj, prop) {\n        new Assertion(fn).to.not.decrease(obj, prop);\n      }; /*!\n          * Undocumented / untested\n          */\n\n      assert.ifError = function (val, msg) {\n        new Assertion(val, msg).to.not.be.ok;\n      }; /*!\n          * Aliases.\n          */\n\n      (function () {\n        function alias(name, as) {\n          assert[as] = assert[name];\n          return alias;\n        }\n\n        return alias;\n      })()('Throw', 'throw')('Throw', 'throws');\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/expect.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */module.exports = function (chai, util) {\n      chai.expect = function (val, message) {\n        return new chai.Assertion(val, message);\n      }; /**\n          * ### .fail(actual, expected, [message], [operator])\n          *\n          * Throw a failure.\n          *\n          * @name fail\n          * @param {Mixed} actual\n          * @param {Mixed} expected\n          * @param {String} message\n          * @param {String} operator\n          * @api public\n          */\n\n      chai.expect.fail = function (actual, expected, message, operator) {\n        message = message || 'expect.fail()';\n        throw new chai.AssertionError(message, {\n          actual: actual,\n          expected: expected,\n          operator: operator\n        }, chai.expect.fail);\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/interface/should.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */module.exports = function (chai, util) {\n      var Assertion = chai.Assertion;\n\n      function loadShould() {\n        // explicitly define this method as function as to have it's name to include as `ssfi`\n        function shouldGetter() {\n          if (this instanceof String || this instanceof Number) {\n            return new Assertion(this.constructor(this), null, shouldGetter);\n          } else if (this instanceof Boolean) {\n            return new Assertion(this == true, null, shouldGetter);\n          }\n\n          return new Assertion(this, null, shouldGetter);\n        }\n\n        function shouldSetter(value) {\n          // See https://github.com/chaijs/chai/issues/86: this makes\n          // `whatever.should = someValue` actually set `someValue`, which is\n          // especially useful for `global.should = require('chai').should()`.\n          //\n          // Note that we have to use [[DefineProperty]] instead of [[Put]]\n          // since otherwise we would trigger this very setter!\n          Object.defineProperty(this, 'should', {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n          });\n        } // modify Object.prototype to have `should`\n\n\n        Object.defineProperty(Object.prototype, 'should', {\n          set: shouldSetter,\n          get: shouldGetter,\n          configurable: true\n        });\n        var should = {}; /**\n                          * ### .fail(actual, expected, [message], [operator])\n                          *\n                          * Throw a failure.\n                          *\n                          * @name fail\n                          * @param {Mixed} actual\n                          * @param {Mixed} expected\n                          * @param {String} message\n                          * @param {String} operator\n                          * @api public\n                          */\n\n        should.fail = function (actual, expected, message, operator) {\n          message = message || 'should.fail()';\n          throw new chai.AssertionError(message, {\n            actual: actual,\n            expected: expected,\n            operator: operator\n          }, should.fail);\n        };\n\n        should.equal = function (val1, val2, msg) {\n          new Assertion(val1, msg).to.equal(val2);\n        };\n\n        should.Throw = function (fn, errt, errs, msg) {\n          new Assertion(fn, msg).to.Throw(errt, errs);\n        };\n\n        should.exist = function (val, msg) {\n          new Assertion(val, msg).to.exist;\n        }; // negation\n\n\n        should.not = {};\n\n        should.not.equal = function (val1, val2, msg) {\n          new Assertion(val1, msg).to.not.equal(val2);\n        };\n\n        should.not.Throw = function (fn, errt, errs, msg) {\n          new Assertion(fn, msg).to.not.Throw(errt, errs);\n        };\n\n        should.not.exist = function (val, msg) {\n          new Assertion(val, msg).to.not.exist;\n        };\n\n        should['throw'] = should['Throw'];\n        should.not['throw'] = should.not['Throw'];\n        return should;\n      }\n\n      ;\n      chai.should = loadShould;\n      chai.Should = loadShould;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addChainableMethod.js\", function (exports, module) {\n    /*!\n     * Chai - addChainingMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Module dependencies\n         */var transferFlags = require('chai/lib/chai/utils/transferFlags.js');\n\n    var flag = require('chai/lib/chai/utils/flag.js');\n\n    var config = require('chai/lib/chai/config.js'); /*!\n                                                      * Module variables\n                                                      */ // Check whether `__proto__` is supported\n\n\n    var hasProtoSupport = '__proto__' in Object; // Without `__proto__` support, this module will need to add properties to a function.\n    // However, some Function.prototype methods cannot be overwritten,\n    // and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\n\n    var excludeNames = /^(?:length|name|arguments|caller)$/; // Cache `Function` properties\n\n    var call = Function.prototype.call,\n        apply = Function.prototype.apply; /**\n                                           * ### addChainableMethod (ctx, name, method, chainingBehavior)\n                                           *\n                                           * Adds a method to an object, such that the method can also be chained.\n                                           *\n                                           *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n                                           *       var obj = utils.flag(this, 'object');\n                                           *       new chai.Assertion(obj).to.be.equal(str);\n                                           *     });\n                                           *\n                                           * Can also be accessed directly from `chai.Assertion`.\n                                           *\n                                           *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n                                           *\n                                           * The result can then be used as both a method assertion, executing both `method` and\n                                           * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n                                           *\n                                           *     expect(fooStr).to.be.foo('bar');\n                                           *     expect(fooStr).to.be.foo.equal('foo');\n                                           *\n                                           * @param {Object} ctx object to which the method is added\n                                           * @param {String} name of method to add\n                                           * @param {Function} method function to be used for `name`, when called\n                                           * @param {Function} chainingBehavior function to be called every time the property is accessed\n                                           * @name addChainableMethod\n                                           * @api public\n                                           */\n\n    module.exports = function (ctx, name, method, chainingBehavior) {\n      if (typeof chainingBehavior !== 'function') {\n        chainingBehavior = function () {};\n      }\n\n      var chainableBehavior = {\n        method: method,\n        chainingBehavior: chainingBehavior\n      }; // save the methods so we can overwrite them later, if we need to.\n\n      if (!ctx.__methods) {\n        ctx.__methods = {};\n      }\n\n      ctx.__methods[name] = chainableBehavior;\n      Object.defineProperty(ctx, name, {\n        get: function () {\n          chainableBehavior.chainingBehavior.call(this);\n\n          var assert = function () {\n            function assert() {\n              var old_ssfi = flag(this, 'ssfi');\n              if (old_ssfi && config.includeStack === false) flag(this, 'ssfi', assert);\n              var result = chainableBehavior.method.apply(this, arguments);\n              return result === undefined ? this : result;\n            }\n\n            return assert;\n          }(); // Use `__proto__` if available\n\n\n          if (hasProtoSupport) {\n            // Inherit all properties from the object by replacing the `Function` prototype\n            var prototype = assert.__proto__ = Object.create(this); // Restore the `call` and `apply` methods from `Function`\n\n            prototype.call = call;\n            prototype.apply = apply;\n          } // Otherwise, redefine all properties (slow!)\n          else {\n              var asserterNames = Object.getOwnPropertyNames(ctx);\n              asserterNames.forEach(function (asserterName) {\n                if (!excludeNames.test(asserterName)) {\n                  var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n                  Object.defineProperty(assert, asserterName, pd);\n                }\n              });\n            }\n\n          transferFlags(this, assert);\n          return assert;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addMethod.js\", function (exports, module) {\n    /*!\n     * Chai - addMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */var config = require('chai/lib/chai/config.js'); /**\n                                                         * ### .addMethod (ctx, name, method)\n                                                         *\n                                                         * Adds a method to the prototype of an object.\n                                                         *\n                                                         *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n                                                         *       var obj = utils.flag(this, 'object');\n                                                         *       new chai.Assertion(obj).to.be.equal(str);\n                                                         *     });\n                                                         *\n                                                         * Can also be accessed directly from `chai.Assertion`.\n                                                         *\n                                                         *     chai.Assertion.addMethod('foo', fn);\n                                                         *\n                                                         * Then can be used as any other assertion.\n                                                         *\n                                                         *     expect(fooStr).to.be.foo('bar');\n                                                         *\n                                                         * @param {Object} ctx object to which the method is added\n                                                         * @param {String} name of method to add\n                                                         * @param {Function} method function to be used for name\n                                                         * @name addMethod\n                                                         * @api public\n                                                         */\n\n    var flag = require('chai/lib/chai/utils/flag.js');\n\n    module.exports = function (ctx, name, method) {\n      ctx[name] = function () {\n        var old_ssfi = flag(this, 'ssfi');\n        if (old_ssfi && config.includeStack === false) flag(this, 'ssfi', ctx[name]);\n        var result = method.apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/addProperty.js\", function (exports, module) {\n    /*!\n     * Chai - addProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### addProperty (ctx, name, getter)\n         *\n         * Adds a property to the prototype of an object.\n         *\n         *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n         *       var obj = utils.flag(this, 'object');\n         *       new chai.Assertion(obj).to.be.instanceof(Foo);\n         *     });\n         *\n         * Can also be accessed directly from `chai.Assertion`.\n         *\n         *     chai.Assertion.addProperty('foo', fn);\n         *\n         * Then can be used as any other assertion.\n         *\n         *     expect(myFoo).to.be.foo;\n         *\n         * @param {Object} ctx object to which the property is added\n         * @param {String} name of property to add\n         * @param {Function} getter function to be used for name\n         * @name addProperty\n         * @api public\n         */module.exports = function (ctx, name, getter) {\n      Object.defineProperty(ctx, name, {\n        get: function () {\n          var result = getter.call(this);\n          return result === undefined ? this : result;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/flag.js\", function (exports, module) {\n    /*!\n     * Chai - flag utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### flag(object, key, [value])\n         *\n         * Get or set a flag value on an object. If a\n         * value is provided it will be set, else it will\n         * return the currently set value or `undefined` if\n         * the value is not set.\n         *\n         *     utils.flag(this, 'foo', 'bar'); // setter\n         *     utils.flag(this, 'foo'); // getter, returns `bar`\n         *\n         * @param {Object} object constructed Assertion\n         * @param {String} key\n         * @param {Mixed} value (optional)\n         * @name flag\n         * @api private\n         */module.exports = function (obj, key, value) {\n      var flags = obj.__flags || (obj.__flags = Object.create(null));\n\n      if (arguments.length === 3) {\n        flags[key] = value;\n      } else {\n        return flags[key];\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getActual.js\", function (exports, module) {\n    /*!\n     * Chai - getActual utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * # getActual(object, [actual])\n         *\n         * Returns the `actual` value for an Assertion\n         *\n         * @param {Object} object (constructed Assertion)\n         * @param {Arguments} chai.Assertion.prototype.assert arguments\n         */module.exports = function (obj, args) {\n      return args.length > 4 ? args[4] : obj._obj;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function (exports, module) {\n    /*!\n     * Chai - getEnumerableProperties utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### .getEnumerableProperties(object)\n         *\n         * This allows the retrieval of enumerable property names of an object,\n         * inherited or not.\n         *\n         * @param {Object} object\n         * @returns {Array}\n         * @name getEnumerableProperties\n         * @api public\n         */module.exports = function () {\n      function getEnumerableProperties(object) {\n        var result = [];\n\n        for (var name in meteorBabelHelpers.sanitizeForInObject(object)) {\n          result.push(name);\n        }\n\n        return result;\n      }\n\n      return getEnumerableProperties;\n    }();\n  });\n\n  require.register(\"chai/lib/chai/utils/getMessage.js\", function (exports, module) {\n    /*!\n     * Chai - message composition utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Module dependancies\n         */var flag = require('chai/lib/chai/utils/flag.js'),\n        getActual = require('chai/lib/chai/utils/getActual.js'),\n        inspect = require('chai/lib/chai/utils/inspect.js'),\n        objDisplay = require('chai/lib/chai/utils/objDisplay.js'); /**\n                                                                    * ### .getMessage(object, message, negateMessage)\n                                                                    *\n                                                                    * Construct the error message based on flags\n                                                                    * and template tags. Template tags will return\n                                                                    * a stringified inspection of the object referenced.\n                                                                    *\n                                                                    * Message template tags:\n                                                                    * - `#{this}` current asserted object\n                                                                    * - `#{act}` actual value\n                                                                    * - `#{exp}` expected value\n                                                                    *\n                                                                    * @param {Object} object (constructed Assertion)\n                                                                    * @param {Arguments} chai.Assertion.prototype.assert arguments\n                                                                    * @name getMessage\n                                                                    * @api public\n                                                                    */\n\n    module.exports = function (obj, args) {\n      var negate = flag(obj, 'negate'),\n          val = flag(obj, 'object'),\n          expected = args[3],\n          actual = getActual(obj, args),\n          msg = negate ? args[2] : args[1],\n          flagMsg = flag(obj, 'message');\n      if (typeof msg === \"function\") msg = msg();\n      msg = msg || '';\n      msg = msg.replace(/#{this}/g, objDisplay(val)).replace(/#{act}/g, objDisplay(actual)).replace(/#{exp}/g, objDisplay(expected));\n      return flagMsg ? flagMsg + ': ' + msg : msg;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getName.js\", function (exports, module) {\n    /*!\n     * Chai - getName utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * # getName(func)\n         *\n         * Gets the name of a function, in a cross-browser way.\n         *\n         * @param {Function} a function (usually a constructor)\n         */module.exports = function (func) {\n      if (func.name) return func.name;\n      var match = /^\\s?function ([^(]*)\\(/.exec(func);\n      return match && match[1] ? match[1] : \"\";\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getPathValue.js\", function (exports, module) {\n    /*!\n     * Chai - getPathValue utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * @see https://github.com/logicalparadox/filtr\n     * MIT Licensed\n     */var getPathInfo = require('chai/lib/chai/utils/getPathInfo.js'); /**\n                                                                         * ### .getPathValue(path, object)\n                                                                         *\n                                                                         * This allows the retrieval of values in an\n                                                                         * object given a string path.\n                                                                         *\n                                                                         *     var obj = {\n                                                                         *         prop1: {\n                                                                         *             arr: ['a', 'b', 'c']\n                                                                         *           , str: 'Hello'\n                                                                         *         }\n                                                                         *       , prop2: {\n                                                                         *             arr: [ { nested: 'Universe' } ]\n                                                                         *           , str: 'Hello again!'\n                                                                         *         }\n                                                                         *     }\n                                                                         *\n                                                                         * The following would be the results.\n                                                                         *\n                                                                         *     getPathValue('prop1.str', obj); // Hello\n                                                                         *     getPathValue('prop1.att[2]', obj); // b\n                                                                         *     getPathValue('prop2.arr[0].nested', obj); // Universe\n                                                                         *\n                                                                         * @param {String} path\n                                                                         * @param {Object} object\n                                                                         * @returns {Object} value or `undefined`\n                                                                         * @name getPathValue\n                                                                         * @api public\n                                                                         */\n\n    module.exports = function (path, obj) {\n      var info = getPathInfo(path, obj);\n      return info.value;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/getPathInfo.js\", function (exports, module) {\n    /*!\n     * Chai - getPathInfo utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */var hasProperty = require('chai/lib/chai/utils/hasProperty.js'); /**\n                                                                         * ### .getPathInfo(path, object)\n                                                                         *\n                                                                         * This allows the retrieval of property info in an\n                                                                         * object given a string path.\n                                                                         *\n                                                                         * The path info consists of an object with the\n                                                                         * following properties:\n                                                                         *\n                                                                         * * parent - The parent object of the property referenced by `path`\n                                                                         * * name - The name of the final property, a number if it was an array indexer\n                                                                         * * value - The value of the property, if it exists, otherwise `undefined`\n                                                                         * * exists - Whether the property exists or not\n                                                                         *\n                                                                         * @param {String} path\n                                                                         * @param {Object} object\n                                                                         * @returns {Object} info\n                                                                         * @name getPathInfo\n                                                                         * @api public\n                                                                         */\n\n    module.exports = function () {\n      function getPathInfo(path, obj) {\n        var parsed = parsePath(path),\n            last = parsed[parsed.length - 1];\n        var info = {\n          parent: _getPathValue(parsed, obj, parsed.length - 1),\n          name: last.p || last.i,\n          value: _getPathValue(parsed, obj)\n        };\n        info.exists = hasProperty(info.name, info.parent);\n        return info;\n      }\n\n      return getPathInfo;\n    }(); /*!\n          * ## parsePath(path)\n          *\n          * Helper function used to parse string object\n          * paths. Use in conjunction with `_getPathValue`.\n          *\n          *      var parsed = parsePath('myobject.property.subprop');\n          *\n          * ### Paths:\n          *\n          * * Can be as near infinitely deep and nested\n          * * Arrays are also valid using the formal `myobject.document[3].property`.\n          *\n          * @param {String} path\n          * @returns {Object} parsed\n          * @api private\n          */\n\n    function parsePath(path) {\n      var str = path.replace(/\\[/g, '.['),\n          parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n      return parts.map(function (value) {\n        var re = /\\[(\\d+)\\]$/,\n            mArr = re.exec(value);\n        if (mArr) return {\n          i: parseFloat(mArr[1])\n        };else return {\n          p: value\n        };\n      });\n    } /*!\n       * ## _getPathValue(parsed, obj)\n       *\n       * Helper companion function for `.parsePath` that returns\n       * the value located at the parsed address.\n       *\n       *      var value = getPathValue(parsed, obj);\n       *\n       * @param {Object} parsed definition from `parsePath`.\n       * @param {Object} object to search against\n       * @param {Number} object to search against\n       * @returns {Object|Undefined} value\n       * @api private\n       */\n\n    function _getPathValue(parsed, obj, index) {\n      var tmp = obj,\n          res;\n      index = index === undefined ? parsed.length : index;\n\n      for (var i = 0, l = index; i < l; i++) {\n        var part = parsed[i];\n\n        if (tmp) {\n          if ('undefined' !== typeof part.p) tmp = tmp[part.p];else if ('undefined' !== typeof part.i) tmp = tmp[part.i];\n          if (i == l - 1) res = tmp;\n        } else {\n          res = undefined;\n        }\n      }\n\n      return res;\n    }\n  });\n\n  require.register(\"chai/lib/chai/utils/hasProperty.js\", function (exports, module) {\n    /*!\n     * Chai - hasProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */var type = require('chai/lib/chai/utils/type.js'); /**\n                                                           * ### .hasProperty(object, name)\n                                                           *\n                                                           * This allows checking whether an object has\n                                                           * named property or numeric array index.\n                                                           *\n                                                           * Basically does the same thing as the `in`\n                                                           * operator but works properly with natives\n                                                           * and null/undefined values.\n                                                           *\n                                                           *     var obj = {\n                                                           *         arr: ['a', 'b', 'c']\n                                                           *       , str: 'Hello'\n                                                           *     }\n                                                           *\n                                                           * The following would be the results.\n                                                           *\n                                                           *     hasProperty('str', obj);  // true\n                                                           *     hasProperty('constructor', obj);  // true\n                                                           *     hasProperty('bar', obj);  // false\n                                                           *     \n                                                           *     hasProperty('length', obj.str); // true\n                                                           *     hasProperty(1, obj.str);  // true\n                                                           *     hasProperty(5, obj.str);  // false\n                                                           *\n                                                           *     hasProperty('length', obj.arr);  // true\n                                                           *     hasProperty(2, obj.arr);  // true\n                                                           *     hasProperty(3, obj.arr);  // false\n                                                           *\n                                                           * @param {Objuect} object\n                                                           * @param {String|Number} name\n                                                           * @returns {Boolean} whether it exists\n                                                           * @name getPathInfo\n                                                           * @api public\n                                                           */\n\n    var literals = {\n      'number': Number,\n      'string': String\n    };\n\n    module.exports = function () {\n      function hasProperty(name, obj) {\n        var ot = type(obj); // Bad Object, obviously no props at all\n\n        if (ot === 'null' || ot === 'undefined') return false; // The `in` operator does not work with certain literals\n        // box these before the check\n\n        if (literals[ot] && (typeof obj === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(obj)) !== 'object') obj = new literals[ot](obj);\n        return name in obj;\n      }\n\n      return hasProperty;\n    }();\n  });\n\n  require.register(\"chai/lib/chai/utils/getProperties.js\", function (exports, module) {\n    /*!\n     * Chai - getProperties utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### .getProperties(object)\n         *\n         * This allows the retrieval of property names of an object, enumerable or not,\n         * inherited or not.\n         *\n         * @param {Object} object\n         * @returns {Array}\n         * @name getProperties\n         * @api public\n         */module.exports = function () {\n      function getProperties(object) {\n        var result = Object.getOwnPropertyNames(subject);\n\n        function addProperty(property) {\n          if (result.indexOf(property) === -1) {\n            result.push(property);\n          }\n        }\n\n        var proto = Object.getPrototypeOf(subject);\n\n        while (proto !== null) {\n          Object.getOwnPropertyNames(proto).forEach(addProperty);\n          proto = Object.getPrototypeOf(proto);\n        }\n\n        return result;\n      }\n\n      return getProperties;\n    }();\n  });\n\n  require.register(\"chai/lib/chai/utils/index.js\", function (exports, module) {\n    /*!\n     * chai\n     * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Main exports\n         */var exports = module.exports = {}; /*!\n                                               * test utility\n                                               */\n    exports.test = require('chai/lib/chai/utils/test.js'); /*!\n                                                            * type utility\n                                                            */\n    exports.type = require('chai/lib/chai/utils/type.js'); /*!\n                                                            * message utility\n                                                            */\n    exports.getMessage = require('chai/lib/chai/utils/getMessage.js'); /*!\n                                                                        * actual utility\n                                                                        */\n    exports.getActual = require('chai/lib/chai/utils/getActual.js'); /*!\n                                                                      * Inspect util\n                                                                      */\n    exports.inspect = require('chai/lib/chai/utils/inspect.js'); /*!\n                                                                  * Object Display util\n                                                                  */\n    exports.objDisplay = require('chai/lib/chai/utils/objDisplay.js'); /*!\n                                                                        * Flag utility\n                                                                        */\n    exports.flag = require('chai/lib/chai/utils/flag.js'); /*!\n                                                            * Flag transferring utility\n                                                            */\n    exports.transferFlags = require('chai/lib/chai/utils/transferFlags.js'); /*!\n                                                                              * Deep equal utility\n                                                                              */\n    exports.eql = require('chaijs~deep-eql@0.1.3'); /*!\n                                                     * Deep path value\n                                                     */\n    exports.getPathValue = require('chai/lib/chai/utils/getPathValue.js'); /*!\n                                                                            * Deep path info\n                                                                            */\n    exports.getPathInfo = require('chai/lib/chai/utils/getPathInfo.js'); /*!\n                                                                          * Check if a property exists\n                                                                          */\n    exports.hasProperty = require('chai/lib/chai/utils/hasProperty.js'); /*!\n                                                                          * Function name\n                                                                          */\n    exports.getName = require('chai/lib/chai/utils/getName.js'); /*!\n                                                                  * add Property\n                                                                  */\n    exports.addProperty = require('chai/lib/chai/utils/addProperty.js'); /*!\n                                                                          * add Method\n                                                                          */\n    exports.addMethod = require('chai/lib/chai/utils/addMethod.js'); /*!\n                                                                      * overwrite Property\n                                                                      */\n    exports.overwriteProperty = require('chai/lib/chai/utils/overwriteProperty.js'); /*!\n                                                                                      * overwrite Method\n                                                                                      */\n    exports.overwriteMethod = require('chai/lib/chai/utils/overwriteMethod.js'); /*!\n                                                                                  * Add a chainable method\n                                                                                  */\n    exports.addChainableMethod = require('chai/lib/chai/utils/addChainableMethod.js'); /*!\n                                                                                        * Overwrite chainable method\n                                                                                        */\n    exports.overwriteChainableMethod = require('chai/lib/chai/utils/overwriteChainableMethod.js');\n  });\n\n  require.register(\"chai/lib/chai/utils/inspect.js\", function (exports, module) {\n    // This is (almost) directly from Node.js utils\n    // https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n    var getName = require('chai/lib/chai/utils/getName.js');\n\n    var getProperties = require('chai/lib/chai/utils/getProperties.js');\n\n    var getEnumerableProperties = require('chai/lib/chai/utils/getEnumerableProperties.js');\n\n    module.exports = inspect; /**\n                               * Echos the value of a value. Trys to print the value out\n                               * in the best way possible given the different types.\n                               *\n                               * @param {Object} obj The object to print out.\n                               * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n                               *    properties of objects.\n                               * @param {Number} depth Depth in which to descend in object. Default is 2.\n                               * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n                               *    output. Default is false (no coloring).\n                               */\n\n    function inspect(obj, showHidden, depth, colors) {\n      var ctx = {\n        showHidden: showHidden,\n        seen: [],\n        stylize: function (str) {\n          return str;\n        }\n      };\n      return formatValue(ctx, obj, typeof depth === 'undefined' ? 2 : depth);\n    } // Returns true if object is a DOM element.\n\n\n    var isDOMElement = function (object) {\n      if ((typeof HTMLElement === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(HTMLElement)) === 'object') {\n        return object instanceof HTMLElement;\n      } else {\n        return object && (typeof object === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(object)) === 'object' && object.nodeType === 1 && typeof object.nodeName === 'string';\n      }\n    };\n\n    function formatValue(ctx, value, recurseTimes) {\n      // Provide a hook for user-specified inspect functions.\n      // Check that value is an object with an inspect function on it\n      if (value && typeof value.inspect === 'function' && // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n        var ret = value.inspect(recurseTimes);\n\n        if (typeof ret !== 'string') {\n          ret = formatValue(ctx, ret, recurseTimes);\n        }\n\n        return ret;\n      } // Primitive types cannot have properties\n\n\n      var primitive = formatPrimitive(ctx, value);\n\n      if (primitive) {\n        return primitive;\n      } // If this is a DOM element, try to get the outer HTML.\n\n\n      if (isDOMElement(value)) {\n        if ('outerHTML' in value) {\n          return value.outerHTML; // This value does not have an outerHTML attribute,\n          //   it could still be an XML element\n        } else {\n          // Attempt to serialize it\n          try {\n            if (document.xmlVersion) {\n              var xmlSerializer = new XMLSerializer();\n              return xmlSerializer.serializeToString(value);\n            } else {\n              // Firefox 11- do not support outerHTML\n              //   It does, however, support innerHTML\n              //   Use the following to render the element\n              var ns = \"http://www.w3.org/1999/xhtml\";\n              var container = document.createElementNS(ns, '_');\n              container.appendChild(value.cloneNode(false));\n              html = container.innerHTML.replace('><', '>' + value.innerHTML + '<');\n              container.innerHTML = '';\n              return html;\n            }\n          } catch (err) {// This could be a non-native DOM implementation,\n            //   continue with the normal flow:\n            //   printing the element as if it is an object.\n          }\n        }\n      } // Look up the keys of the object.\n\n\n      var visibleKeys = getEnumerableProperties(value);\n      var keys = ctx.showHidden ? getProperties(value) : visibleKeys; // Some type of object without properties can be shortcutted.\n      // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n      // a `stack` plus `description` property; ignore those for consistency.\n\n      if (keys.length === 0 || isError(value) && (keys.length === 1 && keys[0] === 'stack' || keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')) {\n        if (typeof value === 'function') {\n          var name = getName(value);\n          var nameSuffix = name ? ': ' + name : '';\n          return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n        }\n\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        }\n\n        if (isDate(value)) {\n          return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n        }\n\n        if (isError(value)) {\n          return formatError(value);\n        }\n      }\n\n      var base = '',\n          array = false,\n          braces = ['{', '}']; // Make Array say that they are Array\n\n      if (isArray(value)) {\n        array = true;\n        braces = ['[', ']'];\n      } // Make functions say that they are functions\n\n\n      if (typeof value === 'function') {\n        var name = getName(value);\n        var nameSuffix = name ? ': ' + name : '';\n        base = ' [Function' + nameSuffix + ']';\n      } // Make RegExps say that they are RegExps\n\n\n      if (isRegExp(value)) {\n        base = ' ' + RegExp.prototype.toString.call(value);\n      } // Make dates with properties first say the date\n\n\n      if (isDate(value)) {\n        base = ' ' + Date.prototype.toUTCString.call(value);\n      } // Make error with message first say the error\n\n\n      if (isError(value)) {\n        return formatError(value);\n      }\n\n      if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n      }\n\n      if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n        } else {\n          return ctx.stylize('[Object]', 'special');\n        }\n      }\n\n      ctx.seen.push(value);\n      var output;\n\n      if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n      } else {\n        output = keys.map(function (key) {\n          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n      }\n\n      ctx.seen.pop();\n      return reduceToSingleString(output, base, braces);\n    }\n\n    function formatPrimitive(ctx, value) {\n      switch (typeof value === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(value)) {\n        case 'undefined':\n          return ctx.stylize('undefined', 'undefined');\n\n        case 'string':\n          var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '').replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"') + '\\'';\n          return ctx.stylize(simple, 'string');\n\n        case 'number':\n          if (value === 0 && 1 / value === -Infinity) {\n            return ctx.stylize('-0', 'number');\n          }\n\n          return ctx.stylize('' + value, 'number');\n\n        case 'boolean':\n          return ctx.stylize('' + value, 'boolean');\n      } // For some reason typeof null is \"object\", so special case here.\n\n\n      if (value === null) {\n        return ctx.stylize('null', 'null');\n      }\n    }\n\n    function formatError(value) {\n      return '[' + Error.prototype.toString.call(value) + ']';\n    }\n\n    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n      var output = [];\n\n      for (var i = 0, l = value.length; i < l; ++i) {\n        if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        } else {\n          output.push('');\n        }\n      }\n\n      keys.forEach(function (key) {\n        if (!key.match(/^\\d+$/)) {\n          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n      });\n      return output;\n    }\n\n    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n      var name, str;\n\n      if (value.__lookupGetter__) {\n        if (value.__lookupGetter__(key)) {\n          if (value.__lookupSetter__(key)) {\n            str = ctx.stylize('[Getter/Setter]', 'special');\n          } else {\n            str = ctx.stylize('[Getter]', 'special');\n          }\n        } else {\n          if (value.__lookupSetter__(key)) {\n            str = ctx.stylize('[Setter]', 'special');\n          }\n        }\n      }\n\n      if (visibleKeys.indexOf(key) < 0) {\n        name = '[' + key + ']';\n      }\n\n      if (!str) {\n        if (ctx.seen.indexOf(value[key]) < 0) {\n          if (recurseTimes === null) {\n            str = formatValue(ctx, value[key], null);\n          } else {\n            str = formatValue(ctx, value[key], recurseTimes - 1);\n          }\n\n          if (str.indexOf('\\n') > -1) {\n            if (array) {\n              str = str.split('\\n').map(function (line) {\n                return '  ' + line;\n              }).join('\\n').substr(2);\n            } else {\n              str = '\\n' + str.split('\\n').map(function (line) {\n                return '   ' + line;\n              }).join('\\n');\n            }\n          }\n        } else {\n          str = ctx.stylize('[Circular]', 'special');\n        }\n      }\n\n      if (typeof name === 'undefined') {\n        if (array && key.match(/^\\d+$/)) {\n          return str;\n        }\n\n        name = JSON.stringify('' + key);\n\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n          name = name.substr(1, name.length - 2);\n          name = ctx.stylize(name, 'name');\n        } else {\n          name = name.replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, '\"').replace(/(^\"|\"$)/g, \"'\");\n          name = ctx.stylize(name, 'string');\n        }\n      }\n\n      return name + ': ' + str;\n    }\n\n    function reduceToSingleString(output, base, braces) {\n      var numLinesEst = 0;\n      var length = output.reduce(function (prev, cur) {\n        numLinesEst++;\n        if (cur.indexOf('\\n') >= 0) numLinesEst++;\n        return prev + cur.length + 1;\n      }, 0);\n\n      if (length > 60) {\n        return braces[0] + (base === '' ? '' : base + '\\n ') + ' ' + output.join(',\\n  ') + ' ' + braces[1];\n      }\n\n      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n    }\n\n    function isArray(ar) {\n      return Array.isArray(ar) || (typeof ar === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(ar)) === 'object' && objectToString(ar) === '[object Array]';\n    }\n\n    function isRegExp(re) {\n      return (typeof re === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(re)) === 'object' && objectToString(re) === '[object RegExp]';\n    }\n\n    function isDate(d) {\n      return (typeof d === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(d)) === 'object' && objectToString(d) === '[object Date]';\n    }\n\n    function isError(e) {\n      return (typeof e === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(e)) === 'object' && objectToString(e) === '[object Error]';\n    }\n\n    function objectToString(o) {\n      return Object.prototype.toString.call(o);\n    }\n  });\n\n  require.register(\"chai/lib/chai/utils/objDisplay.js\", function (exports, module) {\n    /*!\n     * Chai - flag utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Module dependancies\n         */var inspect = require('chai/lib/chai/utils/inspect.js');\n\n    var config = require('chai/lib/chai/config.js'); /**\n                                                      * ### .objDisplay (object)\n                                                      *\n                                                      * Determines if an object or an array matches\n                                                      * criteria to be inspected in-line for error\n                                                      * messages or should be truncated.\n                                                      *\n                                                      * @param {Mixed} javascript object to inspect\n                                                      * @name objDisplay\n                                                      * @api public\n                                                      */\n\n    module.exports = function (obj) {\n      var str = inspect(obj),\n          type = Object.prototype.toString.call(obj);\n\n      if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n        if (type === '[object Function]') {\n          return !obj.name || obj.name === '' ? '[Function]' : '[Function: ' + obj.name + ']';\n        } else if (type === '[object Array]') {\n          return '[ Array(' + obj.length + ') ]';\n        } else if (type === '[object Object]') {\n          var keys = Object.keys(obj),\n              kstr = keys.length > 2 ? keys.splice(0, 2).join(', ') + ', ...' : keys.join(', ');\n          return '{ Object (' + kstr + ') }';\n        } else {\n          return str;\n        }\n      } else {\n        return str;\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteMethod.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### overwriteMethod (ctx, name, fn)\n         *\n         * Overwites an already existing method and provides\n         * access to previous function. Must return function\n         * to be used for name.\n         *\n         *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n         *       return function (str) {\n         *         var obj = utils.flag(this, 'object');\n         *         if (obj instanceof Foo) {\n         *           new chai.Assertion(obj.value).to.equal(str);\n         *         } else {\n         *           _super.apply(this, arguments);\n         *         }\n         *       }\n         *     });\n         *\n         * Can also be accessed directly from `chai.Assertion`.\n         *\n         *     chai.Assertion.overwriteMethod('foo', fn);\n         *\n         * Then can be used as any other assertion.\n         *\n         *     expect(myFoo).to.equal('bar');\n         *\n         * @param {Object} ctx object whose method is to be overwritten\n         * @param {String} name of method to overwrite\n         * @param {Function} method function that returns a function to be used for name\n         * @name overwriteMethod\n         * @api public\n         */module.exports = function (ctx, name, method) {\n      var _method = ctx[name],\n          _super = function () {\n        return this;\n      };\n\n      if (_method && 'function' === typeof _method) _super = _method;\n\n      ctx[name] = function () {\n        var result = method(_super).apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteProperty.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteProperty utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### overwriteProperty (ctx, name, fn)\n         *\n         * Overwites an already existing property getter and provides\n         * access to previous value. Must return function to use as getter.\n         *\n         *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n         *       return function () {\n         *         var obj = utils.flag(this, 'object');\n         *         if (obj instanceof Foo) {\n         *           new chai.Assertion(obj.name).to.equal('bar');\n         *         } else {\n         *           _super.call(this);\n         *         }\n         *       }\n         *     });\n         *\n         *\n         * Can also be accessed directly from `chai.Assertion`.\n         *\n         *     chai.Assertion.overwriteProperty('foo', fn);\n         *\n         * Then can be used as any other assertion.\n         *\n         *     expect(myFoo).to.be.ok;\n         *\n         * @param {Object} ctx object whose property is to be overwritten\n         * @param {String} name of property to overwrite\n         * @param {Function} getter function that returns a getter function to be used for name\n         * @name overwriteProperty\n         * @api public\n         */module.exports = function (ctx, name, getter) {\n      var _get = Object.getOwnPropertyDescriptor(ctx, name),\n          _super = function () {};\n\n      if (_get && 'function' === typeof _get.get) _super = _get.get;\n      Object.defineProperty(ctx, name, {\n        get: function () {\n          var result = getter(_super).call(this);\n          return result === undefined ? this : result;\n        },\n        configurable: true\n      });\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/overwriteChainableMethod.js\", function (exports, module) {\n    /*!\n     * Chai - overwriteChainableMethod utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n         *\n         * Overwites an already existing chainable method\n         * and provides access to the previous function or\n         * property.  Must return functions to be used for\n         * name.\n         *\n         *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n         *       function (_super) {\n         *       }\n         *     , function (_super) {\n         *       }\n         *     );\n         *\n         * Can also be accessed directly from `chai.Assertion`.\n         *\n         *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n         *\n         * Then can be used as any other assertion.\n         *\n         *     expect(myFoo).to.have.length(3);\n         *     expect(myFoo).to.have.length.above(3);\n         *\n         * @param {Object} ctx object whose method / property is to be overwritten\n         * @param {String} name of method / property to overwrite\n         * @param {Function} method function that returns a function to be used for name\n         * @param {Function} chainingBehavior function that returns a function to be used for property\n         * @name overwriteChainableMethod\n         * @api public\n         */module.exports = function (ctx, name, method, chainingBehavior) {\n      var chainableBehavior = ctx.__methods[name];\n      var _chainingBehavior = chainableBehavior.chainingBehavior;\n\n      chainableBehavior.chainingBehavior = function () {\n        var result = chainingBehavior(_chainingBehavior).call(this);\n        return result === undefined ? this : result;\n      };\n\n      var _method = chainableBehavior.method;\n\n      chainableBehavior.method = function () {\n        var result = method(_method).apply(this, arguments);\n        return result === undefined ? this : result;\n      };\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/test.js\", function (exports, module) {\n    /*!\n     * Chai - test utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Module dependancies\n         */var flag = require('chai/lib/chai/utils/flag.js'); /**\n                                                               * # test(object, expression)\n                                                               *\n                                                               * Test and object for expression.\n                                                               *\n                                                               * @param {Object} object (constructed Assertion)\n                                                               * @param {Arguments} chai.Assertion.prototype.assert arguments\n                                                               */\n\n    module.exports = function (obj, args) {\n      var negate = flag(obj, 'negate'),\n          expr = args[0];\n      return negate ? !expr : expr;\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/transferFlags.js\", function (exports, module) {\n    /*!\n     * Chai - transferFlags utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /**\n         * ### transferFlags(assertion, object, includeAll = true)\n         *\n         * Transfer all the flags for `assertion` to `object`. If\n         * `includeAll` is set to `false`, then the base Chai\n         * assertion flags (namely `object`, `ssfi`, and `message`)\n         * will not be transferred.\n         *\n         *\n         *     var newAssertion = new Assertion();\n         *     utils.transferFlags(assertion, newAssertion);\n         *\n         *     var anotherAsseriton = new Assertion(myObj);\n         *     utils.transferFlags(assertion, anotherAssertion, false);\n         *\n         * @param {Assertion} assertion the assertion to transfer the flags from\n         * @param {Object} object the object to transfer the flags to; usually a new assertion\n         * @param {Boolean} includeAll\n         * @name transferFlags\n         * @api private\n         */module.exports = function (assertion, object, includeAll) {\n      var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n      if (!object.__flags) {\n        object.__flags = Object.create(null);\n      }\n\n      includeAll = arguments.length === 3 ? includeAll : true;\n\n      for (var flag in meteorBabelHelpers.sanitizeForInObject(flags)) {\n        if (includeAll || flag !== 'object' && flag !== 'ssfi' && flag != 'message') {\n          object.__flags[flag] = flags[flag];\n        }\n      }\n    };\n  });\n\n  require.register(\"chai/lib/chai/utils/type.js\", function (exports, module) {\n    /*!\n     * Chai - type utility\n     * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n     * MIT Licensed\n     */ /*!\n         * Detectable javascript natives\n         */var natives = {\n      '[object Arguments]': 'arguments',\n      '[object Array]': 'array',\n      '[object Date]': 'date',\n      '[object Function]': 'function',\n      '[object Number]': 'number',\n      '[object RegExp]': 'regexp',\n      '[object String]': 'string'\n    }; /**\n        * ### type(object)\n        *\n        * Better implementation of `typeof` detection that can\n        * be used cross-browser. Handles the inconsistencies of\n        * Array, `null`, and `undefined` detection.\n        *\n        *     utils.type({}) // 'object'\n        *     utils.type(null) // `null'\n        *     utils.type(undefined) // `undefined`\n        *     utils.type([]) // `array`\n        *\n        * @param {Mixed} object to detect type of\n        * @name type\n        * @api private\n        */\n\n    module.exports = function (obj) {\n      var str = Object.prototype.toString.call(obj);\n      if (natives[str]) return natives[str];\n      if (obj === null) return 'null';\n      if (obj === undefined) return 'undefined';\n      if (obj === Object(obj)) return 'object';\n      return typeof obj === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(obj);\n    };\n  });\n\n  if ((typeof exports === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(exports)) == \"object\") {\n    module.exports = require(\"chai\");\n  } else if (typeof define == \"function\" && define.amd) {\n    define(\"chai\", [], function () {\n      return require(\"chai\");\n    });\n  } else {\n    (this || window)[\"chai\"] = require(\"chai\");\n  }\n})();","map":{"version":3,"sources":["packages/zurb:foundation-sites/test/javascript/lib/chai.js"],"names":["require","name","module","modules","Error","definition","client","component","call","exports","loader","helper","semVerSort","a","b","aArray","version","split","bArray","i","length","aInt","parseInt","bInt","aLex","substr","bLex","latest","returnPath","showError","versionRegexp","remoteRegexp","test","moduleNames","Object","keys","semVerCandidates","otherCandidates","moduleName","RegExp","semVerMatch","exec","push","concat","sort","pop","register","define","exclude","excludes","slice","arguments","excludeProps","res","obj","forEach","key","indexOf","extendExclude","args","AssertionError","message","_props","ssf","extend","props","showDiff","callee","captureStackTrace","prototype","create","constructor","toJSON","stack","getType","natives","str","toString","undefined","Library","tests","of","type","ReferenceError","Buffer","ex","isBuffer","deepEqual","m","sameValue","dateEqual","regexpEqual","bufferEqual","argumentsEqual","typeEqual","objectEqual","getTime","enumerable","iterableEqual","match","isValue","ka","kb","used","util","use","fn","config","assertion","core","expect","should","assert","_chai","flag","Assertion","msg","defineProperty","get","console","warn","includeStack","set","value","addProperty","addMethod","addChainableMethod","chainingBehavior","overwriteProperty","overwriteMethod","overwriteChainableMethod","expr","negateMsg","expected","_actual","ok","getMessage","actual","getActual","val","truncateThreshold","chai","_","chain","an","toLowerCase","article","charAt","includeChainingBehavior","include","eql","k","property","subset","inspect","negate","Array","isArray","object","checkArguments","assertEqual","_obj","assertEql","assertAbove","n","to","have","len","assertLeast","assertBelow","assertMost","start","finish","range","assertInstanceOf","getName","isDeep","descriptor","pathInfo","getPathInfo","hasProperty","exists","assertOwnProperty","hasOwnProperty","assertLengthChain","assertLength","re","is","assertKeys","mixedArgsMsg","any","all","intersection","filter","every","map","last","join","assertThrows","errMsg","thrown","desiredError","thrownError","err","actuallyGot","expectedThrown","method","itself","context","matcher","result","objDisplay","delta","Math","abs","isSubsetOf","superset","cmp","elem","some","elem2","be","assertChanges","prop","initial","assertIncreases","assertDecreases","express","errmsg","fail","operator","notOk","not","equal","act","exp","notEqual","strictEqual","notStrictEqual","notDeepEqual","isAbove","abv","above","isBelow","blw","below","isTrue","isFalse","isNull","isNotNull","isUndefined","isDefined","isFunction","isNotFunction","isObject","isNotObject","isNotArray","isString","isNotString","isNumber","isNotNumber","isBoolean","isNotBoolean","typeOf","notTypeOf","instanceOf","notInstanceOf","inc","notInclude","notMatch","notProperty","deepProperty","deep","notDeepProperty","propertyVal","propertyNotVal","deepPropertyVal","deepPropertyNotVal","lengthOf","Throw","errt","errs","assertErr","doesNotThrow","val2","eval","closeTo","sameMembers","set1","set2","same","members","sameDeepMembers","includeMembers","changes","change","doesNotChange","increases","increase","doesNotIncrease","decreases","decrease","doesNotDecrease","ifError","alias","as","loadShould","shouldGetter","String","Number","Boolean","shouldSetter","configurable","writable","val1","exist","Should","transferFlags","hasProtoSupport","excludeNames","Function","apply","ctx","chainableBehavior","__methods","old_ssfi","__proto__","asserterNames","getOwnPropertyNames","asserterName","pd","getOwnPropertyDescriptor","getter","flags","__flags","getEnumerableProperties","flagMsg","replace","func","path","info","parsed","parsePath","parent","_getPathValue","p","parts","mArr","parseFloat","index","tmp","l","part","literals","ot","getProperties","subject","proto","getPrototypeOf","getPathValue","showHidden","depth","colors","seen","stylize","formatValue","isDOMElement","HTMLElement","nodeType","nodeName","recurseTimes","ret","primitive","formatPrimitive","outerHTML","document","xmlVersion","xmlSerializer","XMLSerializer","serializeToString","ns","container","createElementNS","appendChild","cloneNode","html","innerHTML","visibleKeys","isError","nameSuffix","isRegExp","isDate","Date","toUTCString","formatError","base","array","braces","output","formatArray","formatProperty","reduceToSingleString","simple","JSON","stringify","Infinity","__lookupGetter__","__lookupSetter__","line","numLinesEst","reduce","prev","cur","ar","objectToString","d","e","o","kstr","splice","_method","_super","_get","_chainingBehavior","includeAll","amd","window"],"mappings":"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","file":"packages/zurb:foundation-sites/test/javascript/lib/chai.js.map","sourcesContent":["\n;(function(){\n\n/**\n * Require the module at `name`.\n *\n * @param {String} name\n * @return {Object} exports\n * @api public\n */\n\nfunction require(name) {\n  var module = require.modules[name];\n  if (!module) throw new Error('failed to require \"' + name + '\"');\n\n  if (!('exports' in module) && typeof module.definition === 'function') {\n    module.client = module.component = true;\n    module.definition.call(this, module.exports = {}, module);\n    delete module.definition;\n  }\n\n  return module.exports;\n}\n\n/**\n * Meta info, accessible in the global scope unless you use AMD option.\n */\n\nrequire.loader = 'component';\n\n/**\n * Internal helper object, contains a sorting function for semantiv versioning\n */\nrequire.helper = {};\nrequire.helper.semVerSort = function(a, b) {\n  var aArray = a.version.split('.');\n  var bArray = b.version.split('.');\n  for (var i=0; i<aArray.length; ++i) {\n    var aInt = parseInt(aArray[i], 10);\n    var bInt = parseInt(bArray[i], 10);\n    if (aInt === bInt) {\n      var aLex = aArray[i].substr((\"\"+aInt).length);\n      var bLex = bArray[i].substr((\"\"+bInt).length);\n      if (aLex === '' && bLex !== '') return 1;\n      if (aLex !== '' && bLex === '') return -1;\n      if (aLex !== '' && bLex !== '') return aLex > bLex ? 1 : -1;\n      continue;\n    } else if (aInt > bInt) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n  return 0;\n}\n\n/**\n * Find and require a module which name starts with the provided name.\n * If multiple modules exists, the highest semver is used. \n * This function can only be used for remote dependencies.\n\n * @param {String} name - module name: `user~repo`\n * @param {Boolean} returnPath - returns the canonical require path if true, \n *                               otherwise it returns the epxorted module\n */\nrequire.latest = function (name, returnPath) {\n  function showError(name) {\n    throw new Error('failed to find latest module of \"' + name + '\"');\n  }\n  // only remotes with semvers, ignore local files conataining a '/'\n  var versionRegexp = /(.*)~(.*)@v?(\\d+\\.\\d+\\.\\d+[^\\/]*)$/;\n  var remoteRegexp = /(.*)~(.*)/;\n  if (!remoteRegexp.test(name)) showError(name);\n  var moduleNames = Object.keys(require.modules);\n  var semVerCandidates = [];\n  var otherCandidates = []; // for instance: name of the git branch\n  for (var i=0; i<moduleNames.length; i++) {\n    var moduleName = moduleNames[i];\n    if (new RegExp(name + '@').test(moduleName)) {\n        var version = moduleName.substr(name.length+1);\n        var semVerMatch = versionRegexp.exec(moduleName);\n        if (semVerMatch != null) {\n          semVerCandidates.push({version: version, name: moduleName});\n        } else {\n          otherCandidates.push({version: version, name: moduleName});\n        } \n    }\n  }\n  if (semVerCandidates.concat(otherCandidates).length === 0) {\n    showError(name);\n  }\n  if (semVerCandidates.length > 0) {\n    var module = semVerCandidates.sort(require.helper.semVerSort).pop().name;\n    if (returnPath === true) {\n      return module;\n    }\n    return require(module);\n  }\n  // if the build contains more than one branch of the same module\n  // you should not use this funciton\n  var module = otherCandidates.sort(function(a, b) {return a.name > b.name})[0].name;\n  if (returnPath === true) {\n    return module;\n  }\n  return require(module);\n}\n\n/**\n * Registered modules.\n */\n\nrequire.modules = {};\n\n/**\n * Register module at `name` with callback `definition`.\n *\n * @param {String} name\n * @param {Function} definition\n * @api private\n */\n\nrequire.register = function (name, definition) {\n  require.modules[name] = {\n    definition: definition\n  };\n};\n\n/**\n * Define a module's exports immediately with `exports`.\n *\n * @param {String} name\n * @param {Generic} exports\n * @api private\n */\n\nrequire.define = function (name, exports) {\n  require.modules[name] = {\n    exports: exports\n  };\n};\nrequire.register(\"chaijs~assertion-error@1.0.0\", function (exports, module) {\n/*!\n * assertion-error\n * Copyright(c) 2013 Jake Luer <jake@qualiancy.com>\n * MIT Licensed\n */\n\n/*!\n * Return a function that will copy properties from\n * one object to another excluding any originally\n * listed. Returned function will create a new `{}`.\n *\n * @param {String} excluded properties ...\n * @return {Function}\n */\n\nfunction exclude () {\n  var excludes = [].slice.call(arguments);\n\n  function excludeProps (res, obj) {\n    Object.keys(obj).forEach(function (key) {\n      if (!~excludes.indexOf(key)) res[key] = obj[key];\n    });\n  }\n\n  return function extendExclude () {\n    var args = [].slice.call(arguments)\n      , i = 0\n      , res = {};\n\n    for (; i < args.length; i++) {\n      excludeProps(res, args[i]);\n    }\n\n    return res;\n  };\n};\n\n/*!\n * Primary Exports\n */\n\nmodule.exports = AssertionError;\n\n/**\n * ### AssertionError\n *\n * An extension of the JavaScript `Error` constructor for\n * assertion and validation scenarios.\n *\n * @param {String} message\n * @param {Object} properties to include (optional)\n * @param {callee} start stack function (optional)\n */\n\nfunction AssertionError (message, _props, ssf) {\n  var extend = exclude('name', 'message', 'stack', 'constructor', 'toJSON')\n    , props = extend(_props || {});\n\n  // default values\n  this.message = message || 'Unspecified AssertionError';\n  this.showDiff = false;\n\n  // copy from properties\n  for (var key in props) {\n    this[key] = props[key];\n  }\n\n  // capture stack trace\n  ssf = ssf || arguments.callee;\n  if (ssf && Error.captureStackTrace) {\n    Error.captureStackTrace(this, ssf);\n  }\n}\n\n/*!\n * Inherit from Error.prototype\n */\n\nAssertionError.prototype = Object.create(Error.prototype);\n\n/*!\n * Statically set name\n */\n\nAssertionError.prototype.name = 'AssertionError';\n\n/*!\n * Ensure correct constructor\n */\n\nAssertionError.prototype.constructor = AssertionError;\n\n/**\n * Allow errors to be converted to JSON for static transfer.\n *\n * @param {Boolean} include stack (default: `true`)\n * @return {Object} object that can be `JSON.stringify`\n */\n\nAssertionError.prototype.toJSON = function (stack) {\n  var extend = exclude('constructor', 'toJSON', 'stack')\n    , props = extend({ name: this.name }, this);\n\n  // include stack if exists and not turned off\n  if (false !== stack && this.stack) {\n    props.stack = this.stack;\n  }\n\n  return props;\n};\n\n});\n\nrequire.register(\"chaijs~type-detect@0.1.1\", function (exports, module) {\n/*!\n * type-detect\n * Copyright(c) 2013 jake luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Primary Exports\n */\n\nvar exports = module.exports = getType;\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Array]': 'array'\n  , '[object RegExp]': 'regexp'\n  , '[object Function]': 'function'\n  , '[object Arguments]': 'arguments'\n  , '[object Date]': 'date'\n};\n\n/**\n * ### typeOf (obj)\n *\n * Use several different techniques to determine\n * the type of object being tested.\n *\n *\n * @param {Mixed} object\n * @return {String} object type\n * @api public\n */\n\nfunction getType (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n}\n\nexports.Library = Library;\n\n/**\n * ### Library\n *\n * Create a repository for custom type detection.\n *\n * ```js\n * var lib = new type.Library;\n * ```\n *\n */\n\nfunction Library () {\n  this.tests = {};\n}\n\n/**\n * #### .of (obj)\n *\n * Expose replacement `typeof` detection to the library.\n *\n * ```js\n * if ('string' === lib.of('hello world')) {\n *   // ...\n * }\n * ```\n *\n * @param {Mixed} object to test\n * @return {String} type\n */\n\nLibrary.prototype.of = getType;\n\n/**\n * #### .define (type, test)\n *\n * Add a test to for the `.test()` assertion.\n *\n * Can be defined as a regular expression:\n *\n * ```js\n * lib.define('int', /^[0-9]+$/);\n * ```\n *\n * ... or as a function:\n *\n * ```js\n * lib.define('bln', function (obj) {\n *   if ('boolean' === lib.of(obj)) return true;\n *   var blns = [ 'yes', 'no', 'true', 'false', 1, 0 ];\n *   if ('string' === lib.of(obj)) obj = obj.toLowerCase();\n *   return !! ~blns.indexOf(obj);\n * });\n * ```\n *\n * @param {String} type\n * @param {RegExp|Function} test\n * @api public\n */\n\nLibrary.prototype.define = function (type, test) {\n  if (arguments.length === 1) return this.tests[type];\n  this.tests[type] = test;\n  return this;\n};\n\n/**\n * #### .test (obj, test)\n *\n * Assert that an object is of type. Will first\n * check natives, and if that does not pass it will\n * use the user defined custom tests.\n *\n * ```js\n * assert(lib.test('1', 'int'));\n * assert(lib.test('yes', 'bln'));\n * ```\n *\n * @param {Mixed} object\n * @param {String} type\n * @return {Boolean} result\n * @api public\n */\n\nLibrary.prototype.test = function (obj, type) {\n  if (type === getType(obj)) return true;\n  var test = this.tests[type];\n\n  if (test && 'regexp' === getType(test)) {\n    return test.test(obj);\n  } else if (test && 'function' === getType(test)) {\n    return test(obj);\n  } else {\n    throw new ReferenceError('Type test \"' + type + '\" not defined or invalid.');\n  }\n};\n\n});\n\nrequire.register(\"chaijs~deep-eql@0.1.3\", function (exports, module) {\n/*!\n * deep-eql\n * Copyright(c) 2013 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar type = require('chaijs~type-detect@0.1.1');\n\n/*!\n * Buffer.isBuffer browser shim\n */\n\nvar Buffer;\ntry { Buffer = require('buffer').Buffer; }\ncatch(ex) {\n  Buffer = {};\n  Buffer.isBuffer = function() { return false; }\n}\n\n/*!\n * Primary Export\n */\n\nmodule.exports = deepEqual;\n\n/**\n * Assert super-strict (egal) equality between\n * two objects of any type.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @param {Array} memoised (optional)\n * @return {Boolean} equal match\n */\n\nfunction deepEqual(a, b, m) {\n  if (sameValue(a, b)) {\n    return true;\n  } else if ('date' === type(a)) {\n    return dateEqual(a, b);\n  } else if ('regexp' === type(a)) {\n    return regexpEqual(a, b);\n  } else if (Buffer.isBuffer(a)) {\n    return bufferEqual(a, b);\n  } else if ('arguments' === type(a)) {\n    return argumentsEqual(a, b, m);\n  } else if (!typeEqual(a, b)) {\n    return false;\n  } else if (('object' !== type(a) && 'object' !== type(b))\n  && ('array' !== type(a) && 'array' !== type(b))) {\n    return sameValue(a, b);\n  } else {\n    return objectEqual(a, b, m);\n  }\n}\n\n/*!\n * Strict (egal) equality test. Ensures that NaN always\n * equals NaN and `-0` does not equal `+0`.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} equal match\n */\n\nfunction sameValue(a, b) {\n  if (a === b) return a !== 0 || 1 / a === 1 / b;\n  return a !== a && b !== b;\n}\n\n/*!\n * Compare the types of two given objects and\n * return if they are equal. Note that an Array\n * has a type of `array` (not `object`) and arguments\n * have a type of `arguments` (not `array`/`object`).\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction typeEqual(a, b) {\n  return type(a) === type(b);\n}\n\n/*!\n * Compare two Date objects by asserting that\n * the time values are equal using `saveValue`.\n *\n * @param {Date} a\n * @param {Date} b\n * @return {Boolean} result\n */\n\nfunction dateEqual(a, b) {\n  if ('date' !== type(b)) return false;\n  return sameValue(a.getTime(), b.getTime());\n}\n\n/*!\n * Compare two regular expressions by converting them\n * to string and checking for `sameValue`.\n *\n * @param {RegExp} a\n * @param {RegExp} b\n * @return {Boolean} result\n */\n\nfunction regexpEqual(a, b) {\n  if ('regexp' !== type(b)) return false;\n  return sameValue(a.toString(), b.toString());\n}\n\n/*!\n * Assert deep equality of two `arguments` objects.\n * Unfortunately, these must be sliced to arrays\n * prior to test to ensure no bad behavior.\n *\n * @param {Arguments} a\n * @param {Arguments} b\n * @param {Array} memoize (optional)\n * @return {Boolean} result\n */\n\nfunction argumentsEqual(a, b, m) {\n  if ('arguments' !== type(b)) return false;\n  a = [].slice.call(a);\n  b = [].slice.call(b);\n  return deepEqual(a, b, m);\n}\n\n/*!\n * Get enumerable properties of a given object.\n *\n * @param {Object} a\n * @return {Array} property names\n */\n\nfunction enumerable(a) {\n  var res = [];\n  for (var key in a) res.push(key);\n  return res;\n}\n\n/*!\n * Simple equality for flat iterable objects\n * such as Arrays or Node.js buffers.\n *\n * @param {Iterable} a\n * @param {Iterable} b\n * @return {Boolean} result\n */\n\nfunction iterableEqual(a, b) {\n  if (a.length !==  b.length) return false;\n\n  var i = 0;\n  var match = true;\n\n  for (; i < a.length; i++) {\n    if (a[i] !== b[i]) {\n      match = false;\n      break;\n    }\n  }\n\n  return match;\n}\n\n/*!\n * Extension to `iterableEqual` specifically\n * for Node.js Buffers.\n *\n * @param {Buffer} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction bufferEqual(a, b) {\n  if (!Buffer.isBuffer(b)) return false;\n  return iterableEqual(a, b);\n}\n\n/*!\n * Block for `objectEqual` ensuring non-existing\n * values don't get in.\n *\n * @param {Mixed} object\n * @return {Boolean} result\n */\n\nfunction isValue(a) {\n  return a !== null && a !== undefined;\n}\n\n/*!\n * Recursively check the equality of two objects.\n * Once basic sameness has been established it will\n * defer to `deepEqual` for each enumerable key\n * in the object.\n *\n * @param {Mixed} a\n * @param {Mixed} b\n * @return {Boolean} result\n */\n\nfunction objectEqual(a, b, m) {\n  if (!isValue(a) || !isValue(b)) {\n    return false;\n  }\n\n  if (a.prototype !== b.prototype) {\n    return false;\n  }\n\n  var i;\n  if (m) {\n    for (i = 0; i < m.length; i++) {\n      if ((m[i][0] === a && m[i][1] === b)\n      ||  (m[i][0] === b && m[i][1] === a)) {\n        return true;\n      }\n    }\n  } else {\n    m = [];\n  }\n\n  try {\n    var ka = enumerable(a);\n    var kb = enumerable(b);\n  } catch (ex) {\n    return false;\n  }\n\n  ka.sort();\n  kb.sort();\n\n  if (!iterableEqual(ka, kb)) {\n    return false;\n  }\n\n  m.push([ a, b ]);\n\n  var key;\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], m)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n});\n\nrequire.register(\"chai\", function (exports, module) {\nmodule.exports = require('chai/lib/chai.js');\n\n});\n\nrequire.register(\"chai/lib/chai.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar used = []\n  , exports = module.exports = {};\n\n/*!\n * Chai version\n */\n\nexports.version = '2.1.0';\n\n/*!\n * Assertion Error\n */\n\nexports.AssertionError = require('chaijs~assertion-error@1.0.0');\n\n/*!\n * Utils for plugins (not exported)\n */\n\nvar util = require('chai/lib/chai/utils/index.js');\n\n/**\n * # .use(function)\n *\n * Provides a way to extend the internals of Chai\n *\n * @param {Function}\n * @returns {this} for chaining\n * @api public\n */\n\nexports.use = function (fn) {\n  if (!~used.indexOf(fn)) {\n    fn(this, util);\n    used.push(fn);\n  }\n\n  return this;\n};\n\n/*!\n * Utility Functions\n */\n\nexports.util = util;\n\n/*!\n * Configuration\n */\n\nvar config = require('chai/lib/chai/config.js');\nexports.config = config;\n\n/*!\n * Primary `Assertion` prototype\n */\n\nvar assertion = require('chai/lib/chai/assertion.js');\nexports.use(assertion);\n\n/*!\n * Core Assertions\n */\n\nvar core = require('chai/lib/chai/core/assertions.js');\nexports.use(core);\n\n/*!\n * Expect interface\n */\n\nvar expect = require('chai/lib/chai/interface/expect.js');\nexports.use(expect);\n\n/*!\n * Should interface\n */\n\nvar should = require('chai/lib/chai/interface/should.js');\nexports.use(should);\n\n/*!\n * Assert interface\n */\n\nvar assert = require('chai/lib/chai/interface/assert.js');\nexports.use(assert);\n\n});\n\nrequire.register(\"chai/lib/chai/assertion.js\", function (exports, module) {\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('chai/lib/chai/config.js');\n\nmodule.exports = function (_chai, util) {\n  /*!\n   * Module dependencies.\n   */\n\n  var AssertionError = _chai.AssertionError\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  _chai.Assertion = Assertion;\n\n  /*!\n   * Assertion Constructor\n   *\n   * Creates object for chaining.\n   *\n   * @api private\n   */\n\n  function Assertion (obj, msg, stack) {\n    flag(this, 'ssfi', stack || arguments.callee);\n    flag(this, 'object', obj);\n    flag(this, 'message', msg);\n  }\n\n  Object.defineProperty(Assertion, 'includeStack', {\n    get: function() {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      return config.includeStack;\n    },\n    set: function(value) {\n      console.warn('Assertion.includeStack is deprecated, use chai.config.includeStack instead.');\n      config.includeStack = value;\n    }\n  });\n\n  Object.defineProperty(Assertion, 'showDiff', {\n    get: function() {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      return config.showDiff;\n    },\n    set: function(value) {\n      console.warn('Assertion.showDiff is deprecated, use chai.config.showDiff instead.');\n      config.showDiff = value;\n    }\n  });\n\n  Assertion.addProperty = function (name, fn) {\n    util.addProperty(this.prototype, name, fn);\n  };\n\n  Assertion.addMethod = function (name, fn) {\n    util.addMethod(this.prototype, name, fn);\n  };\n\n  Assertion.addChainableMethod = function (name, fn, chainingBehavior) {\n    util.addChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  Assertion.overwriteProperty = function (name, fn) {\n    util.overwriteProperty(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteMethod = function (name, fn) {\n    util.overwriteMethod(this.prototype, name, fn);\n  };\n\n  Assertion.overwriteChainableMethod = function (name, fn, chainingBehavior) {\n    util.overwriteChainableMethod(this.prototype, name, fn, chainingBehavior);\n  };\n\n  /*!\n   * ### .assert(expression, message, negateMessage, expected, actual)\n   *\n   * Executes an expression and check expectations. Throws AssertionError for reporting if test doesn't pass.\n   *\n   * @name assert\n   * @param {Philosophical} expression to be tested\n   * @param {String or Function} message or function that returns message to display if fails\n   * @param {String or Function} negatedMessage or function that returns negatedMessage to display if negated expression fails\n   * @param {Mixed} expected value (remember to check for negation)\n   * @param {Mixed} actual (optional) will default to `this.obj`\n   * @api private\n   */\n\n  Assertion.prototype.assert = function (expr, msg, negateMsg, expected, _actual, showDiff) {\n    var ok = util.test(this, arguments);\n    if (true !== showDiff) showDiff = false;\n    if (true !== config.showDiff) showDiff = false;\n\n    if (!ok) {\n      var msg = util.getMessage(this, arguments)\n        , actual = util.getActual(this, arguments);\n      throw new AssertionError(msg, {\n          actual: actual\n        , expected: expected\n        , showDiff: showDiff\n      }, (config.includeStack) ? this.assert : flag(this, 'ssfi'));\n    }\n  };\n\n  /*!\n   * ### ._obj\n   *\n   * Quick reference to stored `actual` value for plugin developers.\n   *\n   * @api private\n   */\n\n  Object.defineProperty(Assertion.prototype, '_obj',\n    { get: function () {\n        return flag(this, 'object');\n      }\n    , set: function (val) {\n        flag(this, 'object', val);\n      }\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/config.js\", function (exports, module) {\nmodule.exports = {\n\n  /**\n   * ### config.includeStack\n   *\n   * User configurable property, influences whether stack trace\n   * is included in Assertion error message. Default of false\n   * suppresses stack trace in the error message.\n   *\n   *     chai.config.includeStack = true;  // enable stack on error\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n   includeStack: false,\n\n  /**\n   * ### config.showDiff\n   *\n   * User configurable property, influences whether or not\n   * the `showDiff` flag should be included in the thrown\n   * AssertionErrors. `false` will always be `false`; `true`\n   * will be true when the assertion has requested a diff\n   * be shown.\n   *\n   * @param {Boolean}\n   * @api public\n   */\n\n  showDiff: true,\n\n  /**\n   * ### config.truncateThreshold\n   *\n   * User configurable property, sets length threshold for actual and\n   * expected values in assertion errors. If this threshold is exceeded,\n   * the value is truncated.\n   *\n   * Set it to zero if you want to disable truncating altogether.\n   *\n   *     chai.config.truncateThreshold = 0;  // disable truncating\n   *\n   * @param {Number}\n   * @api public\n   */\n\n  truncateThreshold: 40\n\n};\n\n});\n\nrequire.register(\"chai/lib/chai/core/assertions.js\", function (exports, module) {\n/*!\n * chai\n * http://chaijs.com\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, _) {\n  var Assertion = chai.Assertion\n    , toString = Object.prototype.toString\n    , flag = _.flag;\n\n  /**\n   * ### Language Chains\n   *\n   * The following are provided as chainable getters to\n   * improve the readability of your assertions. They\n   * do not provide testing capabilities unless they\n   * have been overwritten by a plugin.\n   *\n   * **Chains**\n   *\n   * - to\n   * - be\n   * - been\n   * - is\n   * - that\n   * - which\n   * - and\n   * - has\n   * - have\n   * - with\n   * - at\n   * - of\n   * - same\n   *\n   * @name language chains\n   * @api public\n   */\n\n  [ 'to', 'be', 'been'\n  , 'is', 'and', 'has', 'have'\n  , 'with', 'that', 'which', 'at'\n  , 'of', 'same' ].forEach(function (chain) {\n    Assertion.addProperty(chain, function () {\n      return this;\n    });\n  });\n\n  /**\n   * ### .not\n   *\n   * Negates any of assertions following in the chain.\n   *\n   *     expect(foo).to.not.equal('bar');\n   *     expect(goodFn).to.not.throw(Error);\n   *     expect({ foo: 'baz' }).to.have.property('foo')\n   *       .and.not.equal('bar');\n   *\n   * @name not\n   * @api public\n   */\n\n  Assertion.addProperty('not', function () {\n    flag(this, 'negate', true);\n  });\n\n  /**\n   * ### .deep\n   *\n   * Sets the `deep` flag, later used by the `equal` and\n   * `property` assertions.\n   *\n   *     expect(foo).to.deep.equal({ bar: 'baz' });\n   *     expect({ foo: { bar: { baz: 'quux' } } })\n   *       .to.have.deep.property('foo.bar.baz', 'quux');\n   *\n   * @name deep\n   * @api public\n   */\n\n  Assertion.addProperty('deep', function () {\n    flag(this, 'deep', true);\n  });\n\n  /**\n   * ### .any\n   *\n   * Sets the `any` flag, (opposite of the `all` flag)\n   * later used in the `keys` assertion. \n   *\n   *     expect(foo).to.have.any.keys('bar', 'baz');\n   *\n   * @name any\n   * @api public\n   */\n\n  Assertion.addProperty('any', function () {\n    flag(this, 'any', true);\n    flag(this, 'all', false)\n  });\n\n\n  /**\n   * ### .all\n   *\n   * Sets the `all` flag (opposite of the `any` flag) \n   * later used by the `keys` assertion.\n   *\n   *     expect(foo).to.have.all.keys('bar', 'baz');\n   *\n   * @name all\n   * @api public\n   */\n\n  Assertion.addProperty('all', function () {\n    flag(this, 'all', true);\n    flag(this, 'any', false);\n  });\n\n  /**\n   * ### .a(type)\n   *\n   * The `a` and `an` assertions are aliases that can be\n   * used either as language chains or to assert a value's\n   * type.\n   *\n   *     // typeof\n   *     expect('test').to.be.a('string');\n   *     expect({ foo: 'bar' }).to.be.an('object');\n   *     expect(null).to.be.a('null');\n   *     expect(undefined).to.be.an('undefined');\n   *\n   *     // language chain\n   *     expect(foo).to.be.an.instanceof(Foo);\n   *\n   * @name a\n   * @alias an\n   * @param {String} type\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function an (type, msg) {\n    if (msg) flag(this, 'message', msg);\n    type = type.toLowerCase();\n    var obj = flag(this, 'object')\n      , article = ~[ 'a', 'e', 'i', 'o', 'u' ].indexOf(type.charAt(0)) ? 'an ' : 'a ';\n\n    this.assert(\n        type === _.type(obj)\n      , 'expected #{this} to be ' + article + type\n      , 'expected #{this} not to be ' + article + type\n    );\n  }\n\n  Assertion.addChainableMethod('an', an);\n  Assertion.addChainableMethod('a', an);\n\n  /**\n   * ### .include(value)\n   *\n   * The `include` and `contain` assertions can be used as either property\n   * based language chains or as methods to assert the inclusion of an object\n   * in an array or a substring in a string. When used as language chains,\n   * they toggle the `contains` flag for the `keys` assertion.\n   *\n   *     expect([1,2,3]).to.include(2);\n   *     expect('foobar').to.contain('foo');\n   *     expect({ foo: 'bar', hello: 'universe' }).to.include.keys('foo');\n   *\n   * @name include\n   * @alias contain\n   * @alias includes\n   * @alias contains\n   * @param {Object|String|Number} obj\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function includeChainingBehavior () {\n    flag(this, 'contains', true);\n  }\n\n  function include (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var expected = false;\n    if (_.type(obj) === 'array' && _.type(val) === 'object') {\n      for (var i in obj) {\n        if (_.eql(obj[i], val)) {\n          expected = true;\n          break;\n        }\n      }\n    } else if (_.type(val) === 'object') {\n      if (!flag(this, 'negate')) {\n        for (var k in val) new Assertion(obj).property(k, val[k]);\n        return;\n      }\n      var subset = {};\n      for (var k in val) subset[k] = obj[k];\n      expected = _.eql(subset, val);\n    } else {\n      expected = obj && ~obj.indexOf(val);\n    }\n    this.assert(\n        expected\n      , 'expected #{this} to include ' + _.inspect(val)\n      , 'expected #{this} to not include ' + _.inspect(val));\n  }\n\n  Assertion.addChainableMethod('include', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contain', include, includeChainingBehavior);\n  Assertion.addChainableMethod('contains', include, includeChainingBehavior);\n  Assertion.addChainableMethod('includes', include, includeChainingBehavior);\n\n  /**\n   * ### .ok\n   *\n   * Asserts that the target is truthy.\n   *\n   *     expect('everthing').to.be.ok;\n   *     expect(1).to.be.ok;\n   *     expect(false).to.not.be.ok;\n   *     expect(undefined).to.not.be.ok;\n   *     expect(null).to.not.be.ok;\n   *\n   * @name ok\n   * @api public\n   */\n\n  Assertion.addProperty('ok', function () {\n    this.assert(\n        flag(this, 'object')\n      , 'expected #{this} to be truthy'\n      , 'expected #{this} to be falsy');\n  });\n\n  /**\n   * ### .true\n   *\n   * Asserts that the target is `true`.\n   *\n   *     expect(true).to.be.true;\n   *     expect(1).to.not.be.true;\n   *\n   * @name true\n   * @api public\n   */\n\n  Assertion.addProperty('true', function () {\n    this.assert(\n        true === flag(this, 'object')\n      , 'expected #{this} to be true'\n      , 'expected #{this} to be false'\n      , this.negate ? false : true\n    );\n  });\n\n  /**\n   * ### .false\n   *\n   * Asserts that the target is `false`.\n   *\n   *     expect(false).to.be.false;\n   *     expect(0).to.not.be.false;\n   *\n   * @name false\n   * @api public\n   */\n\n  Assertion.addProperty('false', function () {\n    this.assert(\n        false === flag(this, 'object')\n      , 'expected #{this} to be false'\n      , 'expected #{this} to be true'\n      , this.negate ? true : false\n    );\n  });\n\n  /**\n   * ### .null\n   *\n   * Asserts that the target is `null`.\n   *\n   *     expect(null).to.be.null;\n   *     expect(undefined).not.to.be.null;\n   *\n   * @name null\n   * @api public\n   */\n\n  Assertion.addProperty('null', function () {\n    this.assert(\n        null === flag(this, 'object')\n      , 'expected #{this} to be null'\n      , 'expected #{this} not to be null'\n    );\n  });\n\n  /**\n   * ### .undefined\n   *\n   * Asserts that the target is `undefined`.\n   *\n   *     expect(undefined).to.be.undefined;\n   *     expect(null).to.not.be.undefined;\n   *\n   * @name undefined\n   * @api public\n   */\n\n  Assertion.addProperty('undefined', function () {\n    this.assert(\n        undefined === flag(this, 'object')\n      , 'expected #{this} to be undefined'\n      , 'expected #{this} not to be undefined'\n    );\n  });\n\n  /**\n   * ### .exist\n   *\n   * Asserts that the target is neither `null` nor `undefined`.\n   *\n   *     var foo = 'hi'\n   *       , bar = null\n   *       , baz;\n   *\n   *     expect(foo).to.exist;\n   *     expect(bar).to.not.exist;\n   *     expect(baz).to.not.exist;\n   *\n   * @name exist\n   * @api public\n   */\n\n  Assertion.addProperty('exist', function () {\n    this.assert(\n        null != flag(this, 'object')\n      , 'expected #{this} to exist'\n      , 'expected #{this} to not exist'\n    );\n  });\n\n\n  /**\n   * ### .empty\n   *\n   * Asserts that the target's length is `0`. For arrays, it checks\n   * the `length` property. For objects, it gets the count of\n   * enumerable keys.\n   *\n   *     expect([]).to.be.empty;\n   *     expect('').to.be.empty;\n   *     expect({}).to.be.empty;\n   *\n   * @name empty\n   * @api public\n   */\n\n  Assertion.addProperty('empty', function () {\n    var obj = flag(this, 'object')\n      , expected = obj;\n\n    if (Array.isArray(obj) || 'string' === typeof object) {\n      expected = obj.length;\n    } else if (typeof obj === 'object') {\n      expected = Object.keys(obj).length;\n    }\n\n    this.assert(\n        !expected\n      , 'expected #{this} to be empty'\n      , 'expected #{this} not to be empty'\n    );\n  });\n\n  /**\n   * ### .arguments\n   *\n   * Asserts that the target is an arguments object.\n   *\n   *     function test () {\n   *       expect(arguments).to.be.arguments;\n   *     }\n   *\n   * @name arguments\n   * @alias Arguments\n   * @api public\n   */\n\n  function checkArguments () {\n    var obj = flag(this, 'object')\n      , type = Object.prototype.toString.call(obj);\n    this.assert(\n        '[object Arguments]' === type\n      , 'expected #{this} to be arguments but got ' + type\n      , 'expected #{this} to not be arguments'\n    );\n  }\n\n  Assertion.addProperty('arguments', checkArguments);\n  Assertion.addProperty('Arguments', checkArguments);\n\n  /**\n   * ### .equal(value)\n   *\n   * Asserts that the target is strictly equal (`===`) to `value`.\n   * Alternately, if the `deep` flag is set, asserts that\n   * the target is deeply equal to `value`.\n   *\n   *     expect('hello').to.equal('hello');\n   *     expect(42).to.equal(42);\n   *     expect(1).to.not.equal(true);\n   *     expect({ foo: 'bar' }).to.not.equal({ foo: 'bar' });\n   *     expect({ foo: 'bar' }).to.deep.equal({ foo: 'bar' });\n   *\n   * @name equal\n   * @alias equals\n   * @alias eq\n   * @alias deep.equal\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEqual (val, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'deep')) {\n      return this.eql(val);\n    } else {\n      this.assert(\n          val === obj\n        , 'expected #{this} to equal #{exp}'\n        , 'expected #{this} to not equal #{exp}'\n        , val\n        , this._obj\n        , true\n      );\n    }\n  }\n\n  Assertion.addMethod('equal', assertEqual);\n  Assertion.addMethod('equals', assertEqual);\n  Assertion.addMethod('eq', assertEqual);\n\n  /**\n   * ### .eql(value)\n   *\n   * Asserts that the target is deeply equal to `value`.\n   *\n   *     expect({ foo: 'bar' }).to.eql({ foo: 'bar' });\n   *     expect([ 1, 2, 3 ]).to.eql([ 1, 2, 3 ]);\n   *\n   * @name eql\n   * @alias eqls\n   * @param {Mixed} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertEql(obj, msg) {\n    if (msg) flag(this, 'message', msg);\n    this.assert(\n        _.eql(obj, flag(this, 'object'))\n      , 'expected #{this} to deeply equal #{exp}'\n      , 'expected #{this} to not deeply equal #{exp}'\n      , obj\n      , this._obj\n      , true\n    );\n  }\n\n  Assertion.addMethod('eql', assertEql);\n  Assertion.addMethod('eqls', assertEql);\n\n  /**\n   * ### .above(value)\n   *\n   * Asserts that the target is greater than `value`.\n   *\n   *     expect(10).to.be.above(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *\n   * @name above\n   * @alias gt\n   * @alias greaterThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertAbove (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len > n\n        , 'expected #{this} to have a length above #{exp} but got #{act}'\n        , 'expected #{this} to not have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj > n\n        , 'expected #{this} to be above ' + n\n        , 'expected #{this} to be at most ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('above', assertAbove);\n  Assertion.addMethod('gt', assertAbove);\n  Assertion.addMethod('greaterThan', assertAbove);\n\n  /**\n   * ### .least(value)\n   *\n   * Asserts that the target is greater than or equal to `value`.\n   *\n   *     expect(10).to.be.at.least(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a minimum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.least(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.least(3);\n   *\n   * @name least\n   * @alias gte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLeast (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= n\n        , 'expected #{this} to have a length at least #{exp} but got #{act}'\n        , 'expected #{this} to have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj >= n\n        , 'expected #{this} to be at least ' + n\n        , 'expected #{this} to be below ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('least', assertLeast);\n  Assertion.addMethod('gte', assertLeast);\n\n  /**\n   * ### .below(value)\n   *\n   * Asserts that the target is less than `value`.\n   *\n   *     expect(5).to.be.below(10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *\n   * @name below\n   * @alias lt\n   * @alias lessThan\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertBelow (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len < n\n        , 'expected #{this} to have a length below #{exp} but got #{act}'\n        , 'expected #{this} to not have a length below #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj < n\n        , 'expected #{this} to be below ' + n\n        , 'expected #{this} to be at least ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('below', assertBelow);\n  Assertion.addMethod('lt', assertBelow);\n  Assertion.addMethod('lessThan', assertBelow);\n\n  /**\n   * ### .most(value)\n   *\n   * Asserts that the target is less than or equal to `value`.\n   *\n   *     expect(5).to.be.at.most(5);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a maximum length. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.of.at.most(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.of.at.most(3);\n   *\n   * @name most\n   * @alias lte\n   * @param {Number} value\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertMost (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len <= n\n        , 'expected #{this} to have a length at most #{exp} but got #{act}'\n        , 'expected #{this} to have a length above #{exp}'\n        , n\n        , len\n      );\n    } else {\n      this.assert(\n          obj <= n\n        , 'expected #{this} to be at most ' + n\n        , 'expected #{this} to be above ' + n\n      );\n    }\n  }\n\n  Assertion.addMethod('most', assertMost);\n  Assertion.addMethod('lte', assertMost);\n\n  /**\n   * ### .within(start, finish)\n   *\n   * Asserts that the target is within a range.\n   *\n   *     expect(7).to.be.within(5,10);\n   *\n   * Can also be used in conjunction with `length` to\n   * assert a length range. The benefit being a\n   * more informative error message than if the length\n   * was supplied directly.\n   *\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name within\n   * @param {Number} start lowerbound inclusive\n   * @param {Number} finish upperbound inclusive\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('within', function (start, finish, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , range = start + '..' + finish;\n    if (flag(this, 'doLength')) {\n      new Assertion(obj, msg).to.have.property('length');\n      var len = obj.length;\n      this.assert(\n          len >= start && len <= finish\n        , 'expected #{this} to have a length within ' + range\n        , 'expected #{this} to not have a length within ' + range\n      );\n    } else {\n      this.assert(\n          obj >= start && obj <= finish\n        , 'expected #{this} to be within ' + range\n        , 'expected #{this} to not be within ' + range\n      );\n    }\n  });\n\n  /**\n   * ### .instanceof(constructor)\n   *\n   * Asserts that the target is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , Chai = new Tea('chai');\n   *\n   *     expect(Chai).to.be.an.instanceof(Tea);\n   *     expect([ 1, 2, 3 ]).to.be.instanceof(Array);\n   *\n   * @name instanceof\n   * @param {Constructor} constructor\n   * @param {String} message _optional_\n   * @alias instanceOf\n   * @api public\n   */\n\n  function assertInstanceOf (constructor, msg) {\n    if (msg) flag(this, 'message', msg);\n    var name = _.getName(constructor);\n    this.assert(\n        flag(this, 'object') instanceof constructor\n      , 'expected #{this} to be an instance of ' + name\n      , 'expected #{this} to not be an instance of ' + name\n    );\n  };\n\n  Assertion.addMethod('instanceof', assertInstanceOf);\n  Assertion.addMethod('instanceOf', assertInstanceOf);\n\n  /**\n   * ### .property(name, [value])\n   *\n   * Asserts that the target has a property `name`, optionally asserting that\n   * the value of that property is strictly equal to  `value`.\n   * If the `deep` flag is set, you can use dot- and bracket-notation for deep\n   * references into objects and arrays.\n   *\n   *     // simple referencing\n   *     var obj = { foo: 'bar' };\n   *     expect(obj).to.have.property('foo');\n   *     expect(obj).to.have.property('foo', 'bar');\n   *\n   *     // deep referencing\n   *     var deepObj = {\n   *         green: { tea: 'matcha' }\n   *       , teas: [ 'chai', 'matcha', { tea: 'konacha' } ]\n   *     };\n\n   *     expect(deepObj).to.have.deep.property('green.tea', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[1]', 'matcha');\n   *     expect(deepObj).to.have.deep.property('teas[2].tea', 'konacha');\n   *\n   * You can also use an array as the starting point of a `deep.property`\n   * assertion, or traverse nested arrays.\n   *\n   *     var arr = [\n   *         [ 'chai', 'matcha', 'konacha' ]\n   *       , [ { tea: 'chai' }\n   *         , { tea: 'matcha' }\n   *         , { tea: 'konacha' } ]\n   *     ];\n   *\n   *     expect(arr).to.have.deep.property('[0][1]', 'matcha');\n   *     expect(arr).to.have.deep.property('[1][2].tea', 'konacha');\n   *\n   * Furthermore, `property` changes the subject of the assertion\n   * to be the value of that property from the original object. This\n   * permits for further chainable assertions on that property.\n   *\n   *     expect(obj).to.have.property('foo')\n   *       .that.is.a('string');\n   *     expect(deepObj).to.have.property('green')\n   *       .that.is.an('object')\n   *       .that.deep.equals({ tea: 'matcha' });\n   *     expect(deepObj).to.have.property('teas')\n   *       .that.is.an('array')\n   *       .with.deep.property('[2]')\n   *         .that.deep.equals({ tea: 'konacha' });\n   *\n   * @name property\n   * @alias deep.property\n   * @param {String} name\n   * @param {Mixed} value (optional)\n   * @param {String} message _optional_\n   * @returns value of property for chaining\n   * @api public\n   */\n\n  Assertion.addMethod('property', function (name, val, msg) {\n    if (msg) flag(this, 'message', msg);\n\n    var isDeep = !!flag(this, 'deep')\n      , descriptor = isDeep ? 'deep property ' : 'property '\n      , negate = flag(this, 'negate')\n      , obj = flag(this, 'object')\n      , pathInfo = isDeep ? _.getPathInfo(name, obj) : null\n      , hasProperty = isDeep\n        ? pathInfo.exists\n        : _.hasProperty(name, obj)\n      , value = isDeep\n        ? pathInfo.value\n        : obj[name];\n\n    if (negate && undefined !== val) {\n      if (undefined === value) {\n        msg = (msg != null) ? msg + ': ' : '';\n        throw new Error(msg + _.inspect(obj) + ' has no ' + descriptor + _.inspect(name));\n      }\n    } else {\n      this.assert(\n          hasProperty\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name)\n        , 'expected #{this} to not have ' + descriptor + _.inspect(name));\n    }\n\n    if (undefined !== val) {\n      this.assert(\n          val === value\n        , 'expected #{this} to have a ' + descriptor + _.inspect(name) + ' of #{exp}, but got #{act}'\n        , 'expected #{this} to not have a ' + descriptor + _.inspect(name) + ' of #{act}'\n        , val\n        , value\n      );\n    }\n\n    flag(this, 'object', value);\n  });\n\n\n  /**\n   * ### .ownProperty(name)\n   *\n   * Asserts that the target has an own property `name`.\n   *\n   *     expect('test').to.have.ownProperty('length');\n   *\n   * @name ownProperty\n   * @alias haveOwnProperty\n   * @param {String} name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertOwnProperty (name, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        obj.hasOwnProperty(name)\n      , 'expected #{this} to have own property ' + _.inspect(name)\n      , 'expected #{this} to not have own property ' + _.inspect(name)\n    );\n  }\n\n  Assertion.addMethod('ownProperty', assertOwnProperty);\n  Assertion.addMethod('haveOwnProperty', assertOwnProperty);\n\n  /**\n   * ### .length(value)\n   *\n   * Asserts that the target's `length` property has\n   * the expected value.\n   *\n   *     expect([ 1, 2, 3]).to.have.length(3);\n   *     expect('foobar').to.have.length(6);\n   *\n   * Can also be used as a chain precursor to a value\n   * comparison for the length property.\n   *\n   *     expect('foo').to.have.length.above(2);\n   *     expect([ 1, 2, 3 ]).to.have.length.above(2);\n   *     expect('foo').to.have.length.below(4);\n   *     expect([ 1, 2, 3 ]).to.have.length.below(4);\n   *     expect('foo').to.have.length.within(2,4);\n   *     expect([ 1, 2, 3 ]).to.have.length.within(2,4);\n   *\n   * @name length\n   * @alias lengthOf\n   * @param {Number} length\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertLengthChain () {\n    flag(this, 'doLength', true);\n  }\n\n  function assertLength (n, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).to.have.property('length');\n    var len = obj.length;\n\n    this.assert(\n        len == n\n      , 'expected #{this} to have a length of #{exp} but got #{act}'\n      , 'expected #{this} to not have a length of #{act}'\n      , n\n      , len\n    );\n  }\n\n  Assertion.addChainableMethod('length', assertLength, assertLengthChain);\n  Assertion.addMethod('lengthOf', assertLength);\n\n  /**\n   * ### .match(regexp)\n   *\n   * Asserts that the target matches a regular expression.\n   *\n   *     expect('foobar').to.match(/^foo/);\n   *\n   * @name match\n   * @param {RegExp} RegularExpression\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('match', function (re, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    this.assert(\n        re.exec(obj)\n      , 'expected #{this} to match ' + re\n      , 'expected #{this} not to match ' + re\n    );\n  });\n\n  /**\n   * ### .string(string)\n   *\n   * Asserts that the string target contains another string.\n   *\n   *     expect('foobar').to.have.string('bar');\n   *\n   * @name string\n   * @param {String} string\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('string', function (str, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('string');\n\n    this.assert(\n        ~obj.indexOf(str)\n      , 'expected #{this} to contain ' + _.inspect(str)\n      , 'expected #{this} to not contain ' + _.inspect(str)\n    );\n  });\n\n\n  /**\n   * ### .keys(key1, [key2], [...])\n   *\n   * Asserts that the target contains any or all of the passed-in keys.\n   * Use in combination with `any`, `all`, `contains`, or `have` will affect \n   * what will pass.\n   * \n   * When used in conjunction with `any`, at least one key that is passed \n   * in must exist in the target object. This is regardless whether or not \n   * the `have` or `contain` qualifiers are used. Note, either `any` or `all`\n   * should be used in the assertion. If neither are used, the assertion is\n   * defaulted to `all`.\n   * \n   * When both `all` and `contain` are used, the target object must have at \n   * least all of the passed-in keys but may have more keys not listed.\n   * \n   * When both `all` and `have` are used, the target object must both contain\n   * all of the passed-in keys AND the number of keys in the target object must\n   * match the number of keys passed in (in other words, a target object must \n   * have all and only all of the passed-in keys).\n   * \n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.have.any.keys('foo');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys('bar', 'baz');\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys(['foo']);\n   *     expect({ foo: 1, bar: 2 }).to.contain.any.keys({'foo': 6});\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2 }).to.have.all.keys({'bar': 6, 'foo', 7});\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys(['bar', 'foo']);\n   *     expect({ foo: 1, bar: 2, baz: 3 }).to.contain.all.keys([{'bar': 6}}]);\n   *\n   *\n   * @name keys\n   * @alias key\n   * @param {String...|Array|Object} keys\n   * @api public\n   */\n\n  function assertKeys (keys) {\n    var obj = flag(this, 'object')\n      , str\n      , ok = true\n      , mixedArgsMsg = 'keys must be given single argument of Array|Object|String, or multiple String arguments';\n\n    switch (_.type(keys)) {\n      case \"array\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        break;\n      case \"object\":\n        if (arguments.length > 1) throw (new Error(mixedArgsMsg));\n        keys = Object.keys(keys);\n        break;\n      default:\n        keys = Array.prototype.slice.call(arguments);\n    }\n\n    if (!keys.length) throw new Error('keys required');\n\n    var actual = Object.keys(obj)\n      , expected = keys\n      , len = keys.length\n      , any = flag(this, 'any')\n      , all = flag(this, 'all');\n\n    if (!any && !all) {\n      all = true;\n    }\n\n    // Has any\n    if (any) {\n      var intersection = expected.filter(function(key) {\n        return ~actual.indexOf(key);\n      });\n      ok = intersection.length > 0;\n    }\n\n    // Has all\n    if (all) {\n      ok = keys.every(function(key){\n        return ~actual.indexOf(key);\n      });\n      if (!flag(this, 'negate') && !flag(this, 'contains')) {\n        ok = ok && keys.length == actual.length;\n      }\n    }\n\n    // Key string\n    if (len > 1) {\n      keys = keys.map(function(key){\n        return _.inspect(key);\n      });\n      var last = keys.pop();\n      if (all) {\n        str = keys.join(', ') + ', and ' + last;\n      }\n      if (any) {\n        str = keys.join(', ') + ', or ' + last;\n      }\n    } else {\n      str = _.inspect(keys[0]);\n    }\n\n    // Form\n    str = (len > 1 ? 'keys ' : 'key ') + str;\n\n    // Have / include\n    str = (flag(this, 'contains') ? 'contain ' : 'have ') + str;\n\n    // Assertion\n    this.assert(\n        ok\n      , 'expected #{this} to ' + str\n      , 'expected #{this} to not ' + str\n      , expected.slice(0).sort()\n      , actual.sort()\n      , true\n    );\n  }\n\n  Assertion.addMethod('keys', assertKeys);\n  Assertion.addMethod('key', assertKeys);\n\n  /**\n   * ### .throw(constructor)\n   *\n   * Asserts that the function target will throw a specific error, or specific type of error\n   * (as determined using `instanceof`), optionally with a RegExp or string inclusion test\n   * for the error's message.\n   *\n   *     var err = new ReferenceError('This is a bad function.');\n   *     var fn = function () { throw err; }\n   *     expect(fn).to.throw(ReferenceError);\n   *     expect(fn).to.throw(Error);\n   *     expect(fn).to.throw(/bad function/);\n   *     expect(fn).to.not.throw('good function');\n   *     expect(fn).to.throw(ReferenceError, /bad function/);\n   *     expect(fn).to.throw(err);\n   *     expect(fn).to.not.throw(new RangeError('Out of range.'));\n   *\n   * Please note that when a throw expectation is negated, it will check each\n   * parameter independently, starting with error constructor type. The appropriate way\n   * to check for the existence of a type of error but for a message that does not match\n   * is to use `and`.\n   *\n   *     expect(fn).to.throw(ReferenceError)\n   *        .and.not.throw(/good function/);\n   *\n   * @name throw\n   * @alias throws\n   * @alias Throw\n   * @param {ErrorConstructor} constructor\n   * @param {String|RegExp} expected error message\n   * @param {String} message _optional_\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @returns error for chaining (null if no error)\n   * @api public\n   */\n\n  function assertThrows (constructor, errMsg, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    new Assertion(obj, msg).is.a('function');\n\n    var thrown = false\n      , desiredError = null\n      , name = null\n      , thrownError = null;\n\n    if (arguments.length === 0) {\n      errMsg = null;\n      constructor = null;\n    } else if (constructor && (constructor instanceof RegExp || 'string' === typeof constructor)) {\n      errMsg = constructor;\n      constructor = null;\n    } else if (constructor && constructor instanceof Error) {\n      desiredError = constructor;\n      constructor = null;\n      errMsg = null;\n    } else if (typeof constructor === 'function') {\n      name = constructor.prototype.name || constructor.name;\n      if (name === 'Error' && constructor !== Error) {\n        name = (new constructor()).name;\n      }\n    } else {\n      constructor = null;\n    }\n\n    try {\n      obj();\n    } catch (err) {\n      // first, check desired error\n      if (desiredError) {\n        this.assert(\n            err === desiredError\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp}'\n          , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        flag(this, 'object', err);\n        return this;\n      }\n\n      // next, check constructor\n      if (constructor) {\n        this.assert(\n            err instanceof constructor\n          , 'expected #{this} to throw #{exp} but #{act} was thrown'\n          , 'expected #{this} to not throw #{exp} but #{act} was thrown'\n          , name\n          , (err instanceof Error ? err.toString() : err)\n        );\n\n        if (!errMsg) {\n          flag(this, 'object', err);\n          return this;\n        }\n      }\n\n      // next, check message\n      var message = 'object' === _.type(err) && \"message\" in err\n        ? err.message\n        : '' + err;\n\n      if ((message != null) && errMsg && errMsg instanceof RegExp) {\n        this.assert(\n            errMsg.exec(message)\n          , 'expected #{this} to throw error matching #{exp} but got #{act}'\n          , 'expected #{this} to throw error not matching #{exp}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else if ((message != null) && errMsg && 'string' === typeof errMsg) {\n        this.assert(\n            ~message.indexOf(errMsg)\n          , 'expected #{this} to throw error including #{exp} but got #{act}'\n          , 'expected #{this} to throw error not including #{act}'\n          , errMsg\n          , message\n        );\n\n        flag(this, 'object', err);\n        return this;\n      } else {\n        thrown = true;\n        thrownError = err;\n      }\n    }\n\n    var actuallyGot = ''\n      , expectedThrown = name !== null\n        ? name\n        : desiredError\n          ? '#{exp}' //_.inspect(desiredError)\n          : 'an error';\n\n    if (thrown) {\n      actuallyGot = ' but #{act} was thrown'\n    }\n\n    this.assert(\n        thrown === true\n      , 'expected #{this} to throw ' + expectedThrown + actuallyGot\n      , 'expected #{this} to not throw ' + expectedThrown + actuallyGot\n      , (desiredError instanceof Error ? desiredError.toString() : desiredError)\n      , (thrownError instanceof Error ? thrownError.toString() : thrownError)\n    );\n\n    flag(this, 'object', thrownError);\n  };\n\n  Assertion.addMethod('throw', assertThrows);\n  Assertion.addMethod('throws', assertThrows);\n  Assertion.addMethod('Throw', assertThrows);\n\n  /**\n   * ### .respondTo(method)\n   *\n   * Asserts that the object or class target will respond to a method.\n   *\n   *     Klass.prototype.bar = function(){};\n   *     expect(Klass).to.respondTo('bar');\n   *     expect(obj).to.respondTo('bar');\n   *\n   * To check if a constructor will respond to a static function,\n   * set the `itself` flag.\n   *\n   *     Klass.baz = function(){};\n   *     expect(Klass).itself.to.respondTo('baz');\n   *\n   * @name respondTo\n   * @param {String} method\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('respondTo', function (method, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object')\n      , itself = flag(this, 'itself')\n      , context = ('function' === _.type(obj) && !itself)\n        ? obj.prototype[method]\n        : obj[method];\n\n    this.assert(\n        'function' === typeof context\n      , 'expected #{this} to respond to ' + _.inspect(method)\n      , 'expected #{this} to not respond to ' + _.inspect(method)\n    );\n  });\n\n  /**\n   * ### .itself\n   *\n   * Sets the `itself` flag, later used by the `respondTo` assertion.\n   *\n   *     function Foo() {}\n   *     Foo.bar = function() {}\n   *     Foo.prototype.baz = function() {}\n   *\n   *     expect(Foo).itself.to.respondTo('bar');\n   *     expect(Foo).itself.not.to.respondTo('baz');\n   *\n   * @name itself\n   * @api public\n   */\n\n  Assertion.addProperty('itself', function () {\n    flag(this, 'itself', true);\n  });\n\n  /**\n   * ### .satisfy(method)\n   *\n   * Asserts that the target passes a given truth test.\n   *\n   *     expect(1).to.satisfy(function(num) { return num > 0; });\n   *\n   * @name satisfy\n   * @param {Function} matcher\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('satisfy', function (matcher, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n    var result = matcher(obj);\n    this.assert(\n        result\n      , 'expected #{this} to satisfy ' + _.objDisplay(matcher)\n      , 'expected #{this} to not satisfy' + _.objDisplay(matcher)\n      , this.negate ? false : true\n      , result\n    );\n  });\n\n  /**\n   * ### .closeTo(expected, delta)\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     expect(1.5).to.be.closeTo(1, 0.5);\n   *\n   * @name closeTo\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('closeTo', function (expected, delta, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj, msg).is.a('number');\n    if (_.type(expected) !== 'number' || _.type(delta) !== 'number') {\n      throw new Error('the arguments to closeTo must be numbers');\n    }\n\n    this.assert(\n        Math.abs(obj - expected) <= delta\n      , 'expected #{this} to be close to ' + expected + ' +/- ' + delta\n      , 'expected #{this} not to be close to ' + expected + ' +/- ' + delta\n    );\n  });\n\n  function isSubsetOf(subset, superset, cmp) {\n    return subset.every(function(elem) {\n      if (!cmp) return superset.indexOf(elem) !== -1;\n\n      return superset.some(function(elem2) {\n        return cmp(elem, elem2);\n      });\n    })\n  }\n\n  /**\n   * ### .members(set)\n   *\n   * Asserts that the target is a superset of `set`,\n   * or that the target and `set` have the same strictly-equal (===) members.\n   * Alternately, if the `deep` flag is set, set members are compared for deep\n   * equality.\n   *\n   *     expect([1, 2, 3]).to.include.members([3, 2]);\n   *     expect([1, 2, 3]).to.not.include.members([3, 2, 8]);\n   *\n   *     expect([4, 2]).to.have.members([2, 4]);\n   *     expect([5, 2]).to.not.have.members([5, 2, 1]);\n   *\n   *     expect([{ id: 1 }]).to.deep.include.members([{ id: 1 }]);\n   *\n   * @name members\n   * @param {Array} set\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  Assertion.addMethod('members', function (subset, msg) {\n    if (msg) flag(this, 'message', msg);\n    var obj = flag(this, 'object');\n\n    new Assertion(obj).to.be.an('array');\n    new Assertion(subset).to.be.an('array');\n\n    var cmp = flag(this, 'deep') ? _.eql : undefined;\n\n    if (flag(this, 'contains')) {\n      return this.assert(\n          isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to be a superset of #{act}'\n        , 'expected #{this} to not be a superset of #{act}'\n        , obj\n        , subset\n      );\n    }\n\n    this.assert(\n        isSubsetOf(obj, subset, cmp) && isSubsetOf(subset, obj, cmp)\n        , 'expected #{this} to have the same members as #{act}'\n        , 'expected #{this} to not have the same members as #{act}'\n        , obj\n        , subset\n    );\n  });\n\n  /**\n   * ### .change(function)\n   *\n   * Asserts that a function changes an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val += 3 };\n   *     var noChangeFn = function() { return 'foo' + 'bar'; }\n   *     expect(fn).to.change(obj, 'val');\n   *     expect(noChangFn).to.not.change(obj, 'val')\n   *\n   * @name change\n   * @alias changes\n   * @alias Change\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertChanges (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      initial !== object[prop]\n      , 'expected .' + prop + ' to change'\n      , 'expected .' + prop + ' to not change'\n    );\n  }\n\n  Assertion.addChainableMethod('change', assertChanges);\n  Assertion.addChainableMethod('changes', assertChanges);\n\n  /**\n   * ### .increase(function)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     expect(fn).to.increase(obj, 'val');\n   *\n   * @name increase\n   * @alias increases\n   * @alias Increase\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertIncreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial > 0\n      , 'expected .' + prop + ' to increase'\n      , 'expected .' + prop + ' to not increase'\n    );\n  }\n\n  Assertion.addChainableMethod('increase', assertIncreases);\n  Assertion.addChainableMethod('increases', assertIncreases);\n\n  /**\n   * ### .decrease(function)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     expect(fn).to.decrease(obj, 'val');\n   *\n   * @name decrease\n   * @alias decreases\n   * @alias Decrease\n   * @param {String} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  function assertDecreases (object, prop, msg) {\n    if (msg) flag(this, 'message', msg);\n    var fn = flag(this, 'object');\n    new Assertion(object, msg).to.have.property(prop);\n    new Assertion(fn).is.a('function');\n\n    var initial = object[prop];\n    fn();\n\n    this.assert(\n      object[prop] - initial < 0\n      , 'expected .' + prop + ' to decrease'\n      , 'expected .' + prop + ' to not decrease'\n    );\n  }\n\n  Assertion.addChainableMethod('decrease', assertDecreases);\n  Assertion.addChainableMethod('decreases', assertDecreases);\n\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/assert.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n\nmodule.exports = function (chai, util) {\n\n  /*!\n   * Chai dependencies.\n   */\n\n  var Assertion = chai.Assertion\n    , flag = util.flag;\n\n  /*!\n   * Module export.\n   */\n\n  /**\n   * ### assert(expression, message)\n   *\n   * Write your own test expressions.\n   *\n   *     assert('foo' !== 'bar', 'foo is not bar');\n   *     assert(Array.isArray([]), 'empty arrays are arrays');\n   *\n   * @param {Mixed} expression to test for truthiness\n   * @param {String} message to display on error\n   * @name assert\n   * @api public\n   */\n\n  var assert = chai.assert = function (express, errmsg) {\n    var test = new Assertion(null, null, chai.assert);\n    test.assert(\n        express\n      , errmsg\n      , '[ negation message unavailable ]'\n    );\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure. Node.js `assert` module-compatible.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  assert.fail = function (actual, expected, message, operator) {\n    message = message || 'assert.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, assert.fail);\n  };\n\n  /**\n   * ### .ok(object, [message])\n   *\n   * Asserts that `object` is truthy.\n   *\n   *     assert.ok('everything', 'everything is ok');\n   *     assert.ok(false, 'this will fail');\n   *\n   * @name ok\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.ok = function (val, msg) {\n    new Assertion(val, msg).is.ok;\n  };\n\n  /**\n   * ### .notOk(object, [message])\n   *\n   * Asserts that `object` is falsy.\n   *\n   *     assert.notOk('everything', 'this will fail');\n   *     assert.notOk(false, 'this will pass');\n   *\n   * @name notOk\n   * @param {Mixed} object to test\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notOk = function (val, msg) {\n    new Assertion(val, msg).is.not.ok;\n  };\n\n  /**\n   * ### .equal(actual, expected, [message])\n   *\n   * Asserts non-strict equality (`==`) of `actual` and `expected`.\n   *\n   *     assert.equal(3, '3', '== coerces values to strings');\n   *\n   * @name equal\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.equal = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.equal);\n\n    test.assert(\n        exp == flag(test, 'object')\n      , 'expected #{this} to equal #{exp}'\n      , 'expected #{this} to not equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .notEqual(actual, expected, [message])\n   *\n   * Asserts non-strict inequality (`!=`) of `actual` and `expected`.\n   *\n   *     assert.notEqual(3, 4, 'these numbers are not equal');\n   *\n   * @name notEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notEqual = function (act, exp, msg) {\n    var test = new Assertion(act, msg, assert.notEqual);\n\n    test.assert(\n        exp != flag(test, 'object')\n      , 'expected #{this} to not equal #{exp}'\n      , 'expected #{this} to equal #{act}'\n      , exp\n      , act\n    );\n  };\n\n  /**\n   * ### .strictEqual(actual, expected, [message])\n   *\n   * Asserts strict equality (`===`) of `actual` and `expected`.\n   *\n   *     assert.strictEqual(true, true, 'these booleans are strictly equal');\n   *\n   * @name strictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.strictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.equal(exp);\n  };\n\n  /**\n   * ### .notStrictEqual(actual, expected, [message])\n   *\n   * Asserts strict inequality (`!==`) of `actual` and `expected`.\n   *\n   *     assert.notStrictEqual(3, '3', 'no coercion for strict equality');\n   *\n   * @name notStrictEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notStrictEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.equal(exp);\n  };\n\n  /**\n   * ### .deepEqual(actual, expected, [message])\n   *\n   * Asserts that `actual` is deeply equal to `expected`.\n   *\n   *     assert.deepEqual({ tea: 'green' }, { tea: 'green' });\n   *\n   * @name deepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.eql(exp);\n  };\n\n  /**\n   * ### .notDeepEqual(actual, expected, [message])\n   *\n   * Assert that `actual` is not deeply equal to `expected`.\n   *\n   *     assert.notDeepEqual({ tea: 'green' }, { tea: 'jasmine' });\n   *\n   * @name notDeepEqual\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepEqual = function (act, exp, msg) {\n    new Assertion(act, msg).to.not.eql(exp);\n  };\n\n  /**\n   * ### .isTrue(value, [message])\n   *\n   * Asserts that `value` is true.\n   *\n   *     var teaServed = true;\n   *     assert.isTrue(teaServed, 'the tea has been served');\n   *\n   * @name isTrue\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isAbove = function (val, abv, msg) {\n    new Assertion(val, msg).to.be.above(abv);\n  };\n\n   /**\n   * ### .isAbove(valueToCheck, valueToBeAbove, [message])\n   *\n   * Asserts `valueToCheck` is strictly greater than (>) `valueToBeAbove`\n   *\n   *     assert.isAbove(5, 2, '5 is strictly greater than 2');\n   *\n   * @name isAbove\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeAbove\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBelow = function (val, blw, msg) {\n    new Assertion(val, msg).to.be.below(blw);\n  };\n\n   /**\n   * ### .isBelow(valueToCheck, valueToBeBelow, [message])\n   *\n   * Asserts `valueToCheck` is strictly less than (<) `valueToBeBelow`\n   *\n   *     assert.isBelow(3, 6, '3 is strictly less than 6');\n   *\n   * @name isBelow\n   * @param {Mixed} valueToCheck\n   * @param {Mixed} valueToBeBelow\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isTrue = function (val, msg) {\n    new Assertion(val, msg).is['true'];\n  };\n\n  /**\n   * ### .isFalse(value, [message])\n   *\n   * Asserts that `value` is false.\n   *\n   *     var teaServed = false;\n   *     assert.isFalse(teaServed, 'no tea yet? hmm...');\n   *\n   * @name isFalse\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFalse = function (val, msg) {\n    new Assertion(val, msg).is['false'];\n  };\n\n  /**\n   * ### .isNull(value, [message])\n   *\n   * Asserts that `value` is null.\n   *\n   *     assert.isNull(err, 'there was no error');\n   *\n   * @name isNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNull = function (val, msg) {\n    new Assertion(val, msg).to.equal(null);\n  };\n\n  /**\n   * ### .isNotNull(value, [message])\n   *\n   * Asserts that `value` is not null.\n   *\n   *     var tea = 'tasty chai';\n   *     assert.isNotNull(tea, 'great, time for tea!');\n   *\n   * @name isNotNull\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNull = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(null);\n  };\n\n  /**\n   * ### .isUndefined(value, [message])\n   *\n   * Asserts that `value` is `undefined`.\n   *\n   *     var tea;\n   *     assert.isUndefined(tea, 'no tea defined');\n   *\n   * @name isUndefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isUndefined = function (val, msg) {\n    new Assertion(val, msg).to.equal(undefined);\n  };\n\n  /**\n   * ### .isDefined(value, [message])\n   *\n   * Asserts that `value` is not `undefined`.\n   *\n   *     var tea = 'cup of chai';\n   *     assert.isDefined(tea, 'tea has been defined');\n   *\n   * @name isDefined\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isDefined = function (val, msg) {\n    new Assertion(val, msg).to.not.equal(undefined);\n  };\n\n  /**\n   * ### .isFunction(value, [message])\n   *\n   * Asserts that `value` is a function.\n   *\n   *     function serveTea() { return 'cup of tea'; };\n   *     assert.isFunction(serveTea, 'great, we can have tea now');\n   *\n   * @name isFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isFunction = function (val, msg) {\n    new Assertion(val, msg).to.be.a('function');\n  };\n\n  /**\n   * ### .isNotFunction(value, [message])\n   *\n   * Asserts that `value` is _not_ a function.\n   *\n   *     var serveTea = [ 'heat', 'pour', 'sip' ];\n   *     assert.isNotFunction(serveTea, 'great, we have listed the steps');\n   *\n   * @name isNotFunction\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotFunction = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('function');\n  };\n\n  /**\n   * ### .isObject(value, [message])\n   *\n   * Asserts that `value` is an object (as revealed by\n   * `Object.prototype.toString`).\n   *\n   *     var selection = { name: 'Chai', serve: 'with spices' };\n   *     assert.isObject(selection, 'tea selection is an object');\n   *\n   * @name isObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isObject = function (val, msg) {\n    new Assertion(val, msg).to.be.a('object');\n  };\n\n  /**\n   * ### .isNotObject(value, [message])\n   *\n   * Asserts that `value` is _not_ an object.\n   *\n   *     var selection = 'chai'\n   *     assert.isNotObject(selection, 'tea selection is not an object');\n   *     assert.isNotObject(null, 'null is not an object');\n   *\n   * @name isNotObject\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotObject = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('object');\n  };\n\n  /**\n   * ### .isArray(value, [message])\n   *\n   * Asserts that `value` is an array.\n   *\n   *     var menu = [ 'green', 'chai', 'oolong' ];\n   *     assert.isArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isArray = function (val, msg) {\n    new Assertion(val, msg).to.be.an('array');\n  };\n\n  /**\n   * ### .isNotArray(value, [message])\n   *\n   * Asserts that `value` is _not_ an array.\n   *\n   *     var menu = 'green|chai|oolong';\n   *     assert.isNotArray(menu, 'what kind of tea do we want?');\n   *\n   * @name isNotArray\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotArray = function (val, msg) {\n    new Assertion(val, msg).to.not.be.an('array');\n  };\n\n  /**\n   * ### .isString(value, [message])\n   *\n   * Asserts that `value` is a string.\n   *\n   *     var teaOrder = 'chai';\n   *     assert.isString(teaOrder, 'order placed');\n   *\n   * @name isString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isString = function (val, msg) {\n    new Assertion(val, msg).to.be.a('string');\n  };\n\n  /**\n   * ### .isNotString(value, [message])\n   *\n   * Asserts that `value` is _not_ a string.\n   *\n   *     var teaOrder = 4;\n   *     assert.isNotString(teaOrder, 'order placed');\n   *\n   * @name isNotString\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotString = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('string');\n  };\n\n  /**\n   * ### .isNumber(value, [message])\n   *\n   * Asserts that `value` is a number.\n   *\n   *     var cups = 2;\n   *     assert.isNumber(cups, 'how many cups');\n   *\n   * @name isNumber\n   * @param {Number} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNumber = function (val, msg) {\n    new Assertion(val, msg).to.be.a('number');\n  };\n\n  /**\n   * ### .isNotNumber(value, [message])\n   *\n   * Asserts that `value` is _not_ a number.\n   *\n   *     var cups = '2 cups please';\n   *     assert.isNotNumber(cups, 'how many cups');\n   *\n   * @name isNotNumber\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotNumber = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('number');\n  };\n\n  /**\n   * ### .isBoolean(value, [message])\n   *\n   * Asserts that `value` is a boolean.\n   *\n   *     var teaReady = true\n   *       , teaServed = false;\n   *\n   *     assert.isBoolean(teaReady, 'is the tea ready');\n   *     assert.isBoolean(teaServed, 'has tea been served');\n   *\n   * @name isBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isBoolean = function (val, msg) {\n    new Assertion(val, msg).to.be.a('boolean');\n  };\n\n  /**\n   * ### .isNotBoolean(value, [message])\n   *\n   * Asserts that `value` is _not_ a boolean.\n   *\n   *     var teaReady = 'yep'\n   *       , teaServed = 'nope';\n   *\n   *     assert.isNotBoolean(teaReady, 'is the tea ready');\n   *     assert.isNotBoolean(teaServed, 'has tea been served');\n   *\n   * @name isNotBoolean\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.isNotBoolean = function (val, msg) {\n    new Assertion(val, msg).to.not.be.a('boolean');\n  };\n\n  /**\n   * ### .typeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.typeOf({ tea: 'chai' }, 'object', 'we have an object');\n   *     assert.typeOf(['chai', 'jasmine'], 'array', 'we have an array');\n   *     assert.typeOf('tea', 'string', 'we have a string');\n   *     assert.typeOf(/tea/, 'regexp', 'we have a regular expression');\n   *     assert.typeOf(null, 'null', 'we have a null');\n   *     assert.typeOf(undefined, 'undefined', 'we have an undefined');\n   *\n   * @name typeOf\n   * @param {Mixed} value\n   * @param {String} name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.typeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.a(type);\n  };\n\n  /**\n   * ### .notTypeOf(value, name, [message])\n   *\n   * Asserts that `value`'s type is _not_ `name`, as determined by\n   * `Object.prototype.toString`.\n   *\n   *     assert.notTypeOf('tea', 'number', 'strings are not numbers');\n   *\n   * @name notTypeOf\n   * @param {Mixed} value\n   * @param {String} typeof name\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notTypeOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.a(type);\n  };\n\n  /**\n   * ### .instanceOf(object, constructor, [message])\n   *\n   * Asserts that `value` is an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new Tea('chai');\n   *\n   *     assert.instanceOf(chai, Tea, 'chai is an instance of tea');\n   *\n   * @name instanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.instanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.be.instanceOf(type);\n  };\n\n  /**\n   * ### .notInstanceOf(object, constructor, [message])\n   *\n   * Asserts `value` is not an instance of `constructor`.\n   *\n   *     var Tea = function (name) { this.name = name; }\n   *       , chai = new String('chai');\n   *\n   *     assert.notInstanceOf(chai, Tea, 'chai is not an instance of tea');\n   *\n   * @name notInstanceOf\n   * @param {Object} object\n   * @param {Constructor} constructor\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInstanceOf = function (val, type, msg) {\n    new Assertion(val, msg).to.not.be.instanceOf(type);\n  };\n\n  /**\n   * ### .include(haystack, needle, [message])\n   *\n   * Asserts that `haystack` includes `needle`. Works\n   * for strings and arrays.\n   *\n   *     assert.include('foobar', 'bar', 'foobar contains string \"bar\"');\n   *     assert.include([ 1, 2, 3 ], 3, 'array contains value');\n   *\n   * @name include\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.include = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.include).include(inc);\n  };\n\n  /**\n   * ### .notInclude(haystack, needle, [message])\n   *\n   * Asserts that `haystack` does not include `needle`. Works\n   * for strings and arrays.\n   *i\n   *     assert.notInclude('foobar', 'baz', 'string not include substring');\n   *     assert.notInclude([ 1, 2, 3 ], 4, 'array not include contain value');\n   *\n   * @name notInclude\n   * @param {Array|String} haystack\n   * @param {Mixed} needle\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notInclude = function (exp, inc, msg) {\n    new Assertion(exp, msg, assert.notInclude).not.include(inc);\n  };\n\n  /**\n   * ### .match(value, regexp, [message])\n   *\n   * Asserts that `value` matches the regular expression `regexp`.\n   *\n   *     assert.match('foobar', /^foo/, 'regexp matches');\n   *\n   * @name match\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.match = function (exp, re, msg) {\n    new Assertion(exp, msg).to.match(re);\n  };\n\n  /**\n   * ### .notMatch(value, regexp, [message])\n   *\n   * Asserts that `value` does not match the regular expression `regexp`.\n   *\n   *     assert.notMatch('foobar', /^foo/, 'regexp does not match');\n   *\n   * @name notMatch\n   * @param {Mixed} value\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notMatch = function (exp, re, msg) {\n    new Assertion(exp, msg).to.not.match(re);\n  };\n\n  /**\n   * ### .property(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`.\n   *\n   *     assert.property({ tea: { green: 'matcha' }}, 'tea');\n   *\n   * @name property\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.property = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.property(prop);\n  };\n\n  /**\n   * ### .notProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`.\n   *\n   *     assert.notProperty({ tea: { green: 'matcha' }}, 'coffee');\n   *\n   * @name notProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop);\n  };\n\n  /**\n   * ### .deepProperty(object, property, [message])\n   *\n   * Asserts that `object` has a property named by `property`, which can be a\n   * string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.deepProperty({ tea: { green: 'matcha' }}, 'tea.green');\n   *\n   * @name deepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop);\n  };\n\n  /**\n   * ### .notDeepProperty(object, property, [message])\n   *\n   * Asserts that `object` does _not_ have a property named by `property`, which\n   * can be a string using dot- and bracket-notation for deep reference.\n   *\n   *     assert.notDeepProperty({ tea: { green: 'matcha' }}, 'tea.oolong');\n   *\n   * @name notDeepProperty\n   * @param {Object} object\n   * @param {String} property\n   * @param {String} message\n   * @api public\n   */\n\n  assert.notDeepProperty = function (obj, prop, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop);\n  };\n\n  /**\n   * ### .propertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`.\n   *\n   *     assert.propertyVal({ tea: 'is good' }, 'tea', 'is good');\n   *\n   * @name propertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.property(prop, val);\n  };\n\n  /**\n   * ### .propertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`.\n   *\n   *     assert.propertyNotVal({ tea: 'is good' }, 'tea', 'is bad');\n   *\n   * @name propertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.propertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property` with value given\n   * by `value`. `property` can use dot- and bracket-notation for deep\n   * reference.\n   *\n   *     assert.deepPropertyVal({ tea: { green: 'matcha' }}, 'tea.green', 'matcha');\n   *\n   * @name deepPropertyVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .deepPropertyNotVal(object, property, value, [message])\n   *\n   * Asserts that `object` has a property named by `property`, but with a value\n   * different from that given by `value`. `property` can use dot- and\n   * bracket-notation for deep reference.\n   *\n   *     assert.deepPropertyNotVal({ tea: { green: 'matcha' }}, 'tea.green', 'konacha');\n   *\n   * @name deepPropertyNotVal\n   * @param {Object} object\n   * @param {String} property\n   * @param {Mixed} value\n   * @param {String} message\n   * @api public\n   */\n\n  assert.deepPropertyNotVal = function (obj, prop, val, msg) {\n    new Assertion(obj, msg).to.not.have.deep.property(prop, val);\n  };\n\n  /**\n   * ### .lengthOf(object, length, [message])\n   *\n   * Asserts that `object` has a `length` property with the expected value.\n   *\n   *     assert.lengthOf([1,2,3], 3, 'array has length of 3');\n   *     assert.lengthOf('foobar', 5, 'string has length of 6');\n   *\n   * @name lengthOf\n   * @param {Mixed} object\n   * @param {Number} length\n   * @param {String} message\n   * @api public\n   */\n\n  assert.lengthOf = function (exp, len, msg) {\n    new Assertion(exp, msg).to.have.length(len);\n  };\n\n  /**\n   * ### .throws(function, [constructor/string/regexp], [string/regexp], [message])\n   *\n   * Asserts that `function` will throw an error that is an instance of\n   * `constructor`, or alternately that it will throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.throw(fn, 'function throws a reference error');\n   *     assert.throw(fn, /function throws a reference error/);\n   *     assert.throw(fn, ReferenceError);\n   *     assert.throw(fn, ReferenceError, 'function throws a reference error');\n   *     assert.throw(fn, ReferenceError, /function throws a reference error/);\n   *\n   * @name throws\n   * @alias throw\n   * @alias Throw\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.Throw = function (fn, errt, errs, msg) {\n    if ('string' === typeof errt || errt instanceof RegExp) {\n      errs = errt;\n      errt = null;\n    }\n\n    var assertErr = new Assertion(fn, msg).to.Throw(errt, errs);\n    return flag(assertErr, 'object');\n  };\n\n  /**\n   * ### .doesNotThrow(function, [constructor/regexp], [message])\n   *\n   * Asserts that `function` will _not_ throw an error that is an instance of\n   * `constructor`, or alternately that it will not throw an error with message\n   * matching `regexp`.\n   *\n   *     assert.doesNotThrow(fn, Error, 'function does not throw');\n   *\n   * @name doesNotThrow\n   * @param {Function} function\n   * @param {ErrorConstructor} constructor\n   * @param {RegExp} regexp\n   * @param {String} message\n   * @see https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types\n   * @api public\n   */\n\n  assert.doesNotThrow = function (fn, type, msg) {\n    if ('string' === typeof type) {\n      msg = type;\n      type = null;\n    }\n\n    new Assertion(fn, msg).to.not.Throw(type);\n  };\n\n  /**\n   * ### .operator(val1, operator, val2, [message])\n   *\n   * Compares two values using `operator`.\n   *\n   *     assert.operator(1, '<', 2, 'everything is ok');\n   *     assert.operator(1, '>', 2, 'this will fail');\n   *\n   * @name operator\n   * @param {Mixed} val1\n   * @param {String} operator\n   * @param {Mixed} val2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.operator = function (val, operator, val2, msg) {\n    if (!~['==', '===', '>', '>=', '<', '<=', '!=', '!=='].indexOf(operator)) {\n      throw new Error('Invalid operator \"' + operator + '\"');\n    }\n    var test = new Assertion(eval(val + operator + val2), msg);\n    test.assert(\n        true === flag(test, 'object')\n      , 'expected ' + util.inspect(val) + ' to be ' + operator + ' ' + util.inspect(val2)\n      , 'expected ' + util.inspect(val) + ' to not be ' + operator + ' ' + util.inspect(val2) );\n  };\n\n  /**\n   * ### .closeTo(actual, expected, delta, [message])\n   *\n   * Asserts that the target is equal `expected`, to within a +/- `delta` range.\n   *\n   *     assert.closeTo(1.5, 1, 0.5, 'numbers are close');\n   *\n   * @name closeTo\n   * @param {Number} actual\n   * @param {Number} expected\n   * @param {Number} delta\n   * @param {String} message\n   * @api public\n   */\n\n  assert.closeTo = function (act, exp, delta, msg) {\n    new Assertion(act, msg).to.be.closeTo(exp, delta);\n  };\n\n  /**\n   * ### .sameMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members.\n   * Order is not taken into account.\n   *\n   *     assert.sameMembers([ 1, 2, 3 ], [ 2, 1, 3 ], 'same members');\n   *\n   * @name sameMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.members(set2);\n  }\n\n  /**\n   * ### .sameDeepMembers(set1, set2, [message])\n   *\n   * Asserts that `set1` and `set2` have the same members - using a deep equality checking.\n   * Order is not taken into account.\n   *\n   *     assert.sameDeepMembers([ {b: 3}, {a: 2}, {c: 5} ], [ {c: 5}, {b: 3}, {a: 2} ], 'same deep members');\n   *\n   * @name sameDeepMembers\n   * @param {Array} set1\n   * @param {Array} set2\n   * @param {String} message\n   * @api public\n   */\n\n  assert.sameDeepMembers = function (set1, set2, msg) {\n    new Assertion(set1, msg).to.have.same.deep.members(set2);\n  }\n\n  /**\n   * ### .includeMembers(superset, subset, [message])\n   *\n   * Asserts that `subset` is included in `superset`.\n   * Order is not taken into account.\n   *\n   *     assert.includeMembers([ 1, 2, 3 ], [ 2, 1 ], 'include members');\n   *\n   * @name includeMembers\n   * @param {Array} superset\n   * @param {Array} subset\n   * @param {String} message\n   * @api public\n   */\n\n  assert.includeMembers = function (superset, subset, msg) {\n    new Assertion(superset, msg).to.include.members(subset);\n  }\n\n   /**\n   * ### .changes(function, object, property)\n   *\n   * Asserts that a function changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 22 };\n   *     assert.changes(fn, obj, 'val');\n   *\n   * @name changes\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.changes = function (fn, obj, prop) {\n    new Assertion(fn).to.change(obj, prop);\n  }\n\n   /**\n   * ### .doesNotChange(function, object, property)\n   *\n   * Asserts that a function does not changes the value of a property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { console.log('foo'); };\n   *     assert.doesNotChange(fn, obj, 'val');\n   *\n   * @name doesNotChange\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotChange = function (fn, obj, prop) {\n    new Assertion(fn).to.not.change(obj, prop);\n  }\n\n   /**\n   * ### .increases(function, object, property)\n   *\n   * Asserts that a function increases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 13 };\n   *     assert.increases(fn, obj, 'val');\n   *\n   * @name increases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.increases = function (fn, obj, prop) {\n    new Assertion(fn).to.increase(obj, prop);\n  }\n\n   /**\n   * ### .doesNotIncrease(function, object, property)\n   *\n   * Asserts that a function does not increase object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 8 };\n   *     assert.doesNotIncrease(fn, obj, 'val');\n   *\n   * @name doesNotIncrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotIncrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.increase(obj, prop);\n  }\n\n   /**\n   * ### .decreases(function, object, property)\n   *\n   * Asserts that a function decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 5 };\n   *     assert.decreases(fn, obj, 'val');\n   *\n   * @name decreases\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.decreases = function (fn, obj, prop) {\n    new Assertion(fn).to.decrease(obj, prop);\n  }\n\n   /**\n   * ### .doesNotDecrease(function, object, property)\n   *\n   * Asserts that a function does not decreases an object property\n   *\n   *     var obj = { val: 10 };\n   *     var fn = function() { obj.val = 15 };\n   *     assert.doesNotDecrease(fn, obj, 'val');\n   *\n   * @name doesNotDecrease\n   * @param {Function} modifier function\n   * @param {Object} object\n   * @param {String} property name\n   * @param {String} message _optional_\n   * @api public\n   */\n\n  assert.doesNotDecrease = function (fn, obj, prop) {\n    new Assertion(fn).to.not.decrease(obj, prop);\n  }\n\n  /*!\n   * Undocumented / untested\n   */\n\n  assert.ifError = function (val, msg) {\n    new Assertion(val, msg).to.not.be.ok;\n  };\n\n  /*!\n   * Aliases.\n   */\n\n  (function alias(name, as){\n    assert[as] = assert[name];\n    return alias;\n  })\n  ('Throw', 'throw')\n  ('Throw', 'throws');\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/expect.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  chai.expect = function (val, message) {\n    return new chai.Assertion(val, message);\n  };\n\n  /**\n   * ### .fail(actual, expected, [message], [operator])\n   *\n   * Throw a failure.\n   *\n   * @name fail\n   * @param {Mixed} actual\n   * @param {Mixed} expected\n   * @param {String} message\n   * @param {String} operator\n   * @api public\n   */\n\n  chai.expect.fail = function (actual, expected, message, operator) {\n    message = message || 'expect.fail()';\n    throw new chai.AssertionError(message, {\n        actual: actual\n      , expected: expected\n      , operator: operator\n    }, chai.expect.fail);\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/interface/should.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nmodule.exports = function (chai, util) {\n  var Assertion = chai.Assertion;\n\n  function loadShould () {\n    // explicitly define this method as function as to have it's name to include as `ssfi`\n    function shouldGetter() {\n      if (this instanceof String || this instanceof Number) {\n        return new Assertion(this.constructor(this), null, shouldGetter);\n      } else if (this instanceof Boolean) {\n        return new Assertion(this == true, null, shouldGetter);\n      }\n      return new Assertion(this, null, shouldGetter);\n    }\n    function shouldSetter(value) {\n      // See https://github.com/chaijs/chai/issues/86: this makes\n      // `whatever.should = someValue` actually set `someValue`, which is\n      // especially useful for `global.should = require('chai').should()`.\n      //\n      // Note that we have to use [[DefineProperty]] instead of [[Put]]\n      // since otherwise we would trigger this very setter!\n      Object.defineProperty(this, 'should', {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    }\n    // modify Object.prototype to have `should`\n    Object.defineProperty(Object.prototype, 'should', {\n      set: shouldSetter\n      , get: shouldGetter\n      , configurable: true\n    });\n\n    var should = {};\n\n    /**\n     * ### .fail(actual, expected, [message], [operator])\n     *\n     * Throw a failure.\n     *\n     * @name fail\n     * @param {Mixed} actual\n     * @param {Mixed} expected\n     * @param {String} message\n     * @param {String} operator\n     * @api public\n     */\n\n    should.fail = function (actual, expected, message, operator) {\n      message = message || 'should.fail()';\n      throw new chai.AssertionError(message, {\n          actual: actual\n        , expected: expected\n        , operator: operator\n      }, should.fail);\n    };\n\n    should.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.equal(val2);\n    };\n\n    should.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.Throw(errt, errs);\n    };\n\n    should.exist = function (val, msg) {\n      new Assertion(val, msg).to.exist;\n    }\n\n    // negation\n    should.not = {}\n\n    should.not.equal = function (val1, val2, msg) {\n      new Assertion(val1, msg).to.not.equal(val2);\n    };\n\n    should.not.Throw = function (fn, errt, errs, msg) {\n      new Assertion(fn, msg).to.not.Throw(errt, errs);\n    };\n\n    should.not.exist = function (val, msg) {\n      new Assertion(val, msg).to.not.exist;\n    }\n\n    should['throw'] = should['Throw'];\n    should.not['throw'] = should.not['Throw'];\n\n    return should;\n  };\n\n  chai.should = loadShould;\n  chai.Should = loadShould;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addChainableMethod.js\", function (exports, module) {\n/*!\n * Chai - addChainingMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependencies\n */\n\nvar transferFlags = require('chai/lib/chai/utils/transferFlags.js');\nvar flag = require('chai/lib/chai/utils/flag.js');\nvar config = require('chai/lib/chai/config.js');\n\n/*!\n * Module variables\n */\n\n// Check whether `__proto__` is supported\nvar hasProtoSupport = '__proto__' in Object;\n\n// Without `__proto__` support, this module will need to add properties to a function.\n// However, some Function.prototype methods cannot be overwritten,\n// and there seems no easy cross-platform way to detect them (@see chaijs/chai/issues/69).\nvar excludeNames = /^(?:length|name|arguments|caller)$/;\n\n// Cache `Function` properties\nvar call  = Function.prototype.call,\n    apply = Function.prototype.apply;\n\n/**\n * ### addChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Adds a method to an object, such that the method can also be chained.\n *\n *     utils.addChainableMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addChainableMethod('foo', fn, chainingBehavior);\n *\n * The result can then be used as both a method assertion, executing both `method` and\n * `chainingBehavior`, or as a language chain, which only executes `chainingBehavior`.\n *\n *     expect(fooStr).to.be.foo('bar');\n *     expect(fooStr).to.be.foo.equal('foo');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for `name`, when called\n * @param {Function} chainingBehavior function to be called every time the property is accessed\n * @name addChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  if (typeof chainingBehavior !== 'function') {\n    chainingBehavior = function () { };\n  }\n\n  var chainableBehavior = {\n      method: method\n    , chainingBehavior: chainingBehavior\n  };\n\n  // save the methods so we can overwrite them later, if we need to.\n  if (!ctx.__methods) {\n    ctx.__methods = {};\n  }\n  ctx.__methods[name] = chainableBehavior;\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        chainableBehavior.chainingBehavior.call(this);\n\n        var assert = function assert() {\n          var old_ssfi = flag(this, 'ssfi');\n          if (old_ssfi && config.includeStack === false)\n            flag(this, 'ssfi', assert);\n          var result = chainableBehavior.method.apply(this, arguments);\n          return result === undefined ? this : result;\n        };\n\n        // Use `__proto__` if available\n        if (hasProtoSupport) {\n          // Inherit all properties from the object by replacing the `Function` prototype\n          var prototype = assert.__proto__ = Object.create(this);\n          // Restore the `call` and `apply` methods from `Function`\n          prototype.call = call;\n          prototype.apply = apply;\n        }\n        // Otherwise, redefine all properties (slow!)\n        else {\n          var asserterNames = Object.getOwnPropertyNames(ctx);\n          asserterNames.forEach(function (asserterName) {\n            if (!excludeNames.test(asserterName)) {\n              var pd = Object.getOwnPropertyDescriptor(ctx, asserterName);\n              Object.defineProperty(assert, asserterName, pd);\n            }\n          });\n        }\n\n        transferFlags(this, assert);\n        return assert;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addMethod.js\", function (exports, module) {\n/*!\n * Chai - addMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar config = require('chai/lib/chai/config.js');\n\n/**\n * ### .addMethod (ctx, name, method)\n *\n * Adds a method to the prototype of an object.\n *\n *     utils.addMethod(chai.Assertion.prototype, 'foo', function (str) {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.equal(str);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(fooStr).to.be.foo('bar');\n *\n * @param {Object} ctx object to which the method is added\n * @param {String} name of method to add\n * @param {Function} method function to be used for name\n * @name addMethod\n * @api public\n */\nvar flag = require('chai/lib/chai/utils/flag.js');\n\nmodule.exports = function (ctx, name, method) {\n  ctx[name] = function () {\n    var old_ssfi = flag(this, 'ssfi');\n    if (old_ssfi && config.includeStack === false)\n      flag(this, 'ssfi', ctx[name]);\n    var result = method.apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/addProperty.js\", function (exports, module) {\n/*!\n * Chai - addProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### addProperty (ctx, name, getter)\n *\n * Adds a property to the prototype of an object.\n *\n *     utils.addProperty(chai.Assertion.prototype, 'foo', function () {\n *       var obj = utils.flag(this, 'object');\n *       new chai.Assertion(obj).to.be.instanceof(Foo);\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.addProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.foo;\n *\n * @param {Object} ctx object to which the property is added\n * @param {String} name of property to add\n * @param {Function} getter function to be used for name\n * @name addProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter.call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/flag.js\", function (exports, module) {\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### flag(object, key, [value])\n *\n * Get or set a flag value on an object. If a\n * value is provided it will be set, else it will\n * return the currently set value or `undefined` if\n * the value is not set.\n *\n *     utils.flag(this, 'foo', 'bar'); // setter\n *     utils.flag(this, 'foo'); // getter, returns `bar`\n *\n * @param {Object} object constructed Assertion\n * @param {String} key\n * @param {Mixed} value (optional)\n * @name flag\n * @api private\n */\n\nmodule.exports = function (obj, key, value) {\n  var flags = obj.__flags || (obj.__flags = Object.create(null));\n  if (arguments.length === 3) {\n    flags[key] = value;\n  } else {\n    return flags[key];\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getActual.js\", function (exports, module) {\n/*!\n * Chai - getActual utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getActual(object, [actual])\n *\n * Returns the `actual` value for an Assertion\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  return args.length > 4 ? args[4] : obj._obj;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getEnumerableProperties.js\", function (exports, module) {\n/*!\n * Chai - getEnumerableProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getEnumerableProperties(object)\n *\n * This allows the retrieval of enumerable property names of an object,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getEnumerableProperties\n * @api public\n */\n\nmodule.exports = function getEnumerableProperties(object) {\n  var result = [];\n  for (var name in object) {\n    result.push(name);\n  }\n  return result;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getMessage.js\", function (exports, module) {\n/*!\n * Chai - message composition utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('chai/lib/chai/utils/flag.js')\n  , getActual = require('chai/lib/chai/utils/getActual.js')\n  , inspect = require('chai/lib/chai/utils/inspect.js')\n  , objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n/**\n * ### .getMessage(object, message, negateMessage)\n *\n * Construct the error message based on flags\n * and template tags. Template tags will return\n * a stringified inspection of the object referenced.\n *\n * Message template tags:\n * - `#{this}` current asserted object\n * - `#{act}` actual value\n * - `#{exp}` expected value\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n * @name getMessage\n * @api public\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , val = flag(obj, 'object')\n    , expected = args[3]\n    , actual = getActual(obj, args)\n    , msg = negate ? args[2] : args[1]\n    , flagMsg = flag(obj, 'message');\n\n  if(typeof msg === \"function\") msg = msg();\n  msg = msg || '';\n  msg = msg\n    .replace(/#{this}/g, objDisplay(val))\n    .replace(/#{act}/g, objDisplay(actual))\n    .replace(/#{exp}/g, objDisplay(expected));\n\n  return flagMsg ? flagMsg + ': ' + msg : msg;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getName.js\", function (exports, module) {\n/*!\n * Chai - getName utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * # getName(func)\n *\n * Gets the name of a function, in a cross-browser way.\n *\n * @param {Function} a function (usually a constructor)\n */\n\nmodule.exports = function (func) {\n  if (func.name) return func.name;\n\n  var match = /^\\s?function ([^(]*)\\(/.exec(func);\n  return match && match[1] ? match[1] : \"\";\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getPathValue.js\", function (exports, module) {\n/*!\n * Chai - getPathValue utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * @see https://github.com/logicalparadox/filtr\n * MIT Licensed\n */\n\nvar getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n/**\n * ### .getPathValue(path, object)\n *\n * This allows the retrieval of values in an\n * object given a string path.\n *\n *     var obj = {\n *         prop1: {\n *             arr: ['a', 'b', 'c']\n *           , str: 'Hello'\n *         }\n *       , prop2: {\n *             arr: [ { nested: 'Universe' } ]\n *           , str: 'Hello again!'\n *         }\n *     }\n *\n * The following would be the results.\n *\n *     getPathValue('prop1.str', obj); // Hello\n *     getPathValue('prop1.att[2]', obj); // b\n *     getPathValue('prop2.arr[0].nested', obj); // Universe\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} value or `undefined`\n * @name getPathValue\n * @api public\n */\nmodule.exports = function(path, obj) {\n  var info = getPathInfo(path, obj);\n  return info.value;\n}; \n\n});\n\nrequire.register(\"chai/lib/chai/utils/getPathInfo.js\", function (exports, module) {\n/*!\n * Chai - getPathInfo utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n/**\n * ### .getPathInfo(path, object)\n *\n * This allows the retrieval of property info in an\n * object given a string path.\n *\n * The path info consists of an object with the\n * following properties:\n *\n * * parent - The parent object of the property referenced by `path`\n * * name - The name of the final property, a number if it was an array indexer\n * * value - The value of the property, if it exists, otherwise `undefined`\n * * exists - Whether the property exists or not\n *\n * @param {String} path\n * @param {Object} object\n * @returns {Object} info\n * @name getPathInfo\n * @api public\n */\n\nmodule.exports = function getPathInfo(path, obj) {\n  var parsed = parsePath(path),\n      last = parsed[parsed.length - 1];\n\n  var info = {\n    parent: _getPathValue(parsed, obj, parsed.length - 1),\n    name: last.p || last.i,\n    value: _getPathValue(parsed, obj),\n  };\n  info.exists = hasProperty(info.name, info.parent);\n\n  return info;\n};\n\n\n/*!\n * ## parsePath(path)\n *\n * Helper function used to parse string object\n * paths. Use in conjunction with `_getPathValue`.\n *\n *      var parsed = parsePath('myobject.property.subprop');\n *\n * ### Paths:\n *\n * * Can be as near infinitely deep and nested\n * * Arrays are also valid using the formal `myobject.document[3].property`.\n *\n * @param {String} path\n * @returns {Object} parsed\n * @api private\n */\n\nfunction parsePath (path) {\n  var str = path.replace(/\\[/g, '.[')\n    , parts = str.match(/(\\\\\\.|[^.]+?)+/g);\n  return parts.map(function (value) {\n    var re = /\\[(\\d+)\\]$/\n      , mArr = re.exec(value);\n    if (mArr) return { i: parseFloat(mArr[1]) };\n    else return { p: value };\n  });\n}\n\n\n/*!\n * ## _getPathValue(parsed, obj)\n *\n * Helper companion function for `.parsePath` that returns\n * the value located at the parsed address.\n *\n *      var value = getPathValue(parsed, obj);\n *\n * @param {Object} parsed definition from `parsePath`.\n * @param {Object} object to search against\n * @param {Number} object to search against\n * @returns {Object|Undefined} value\n * @api private\n */\n\nfunction _getPathValue (parsed, obj, index) {\n  var tmp = obj\n    , res;\n\n  index = (index === undefined ? parsed.length : index);\n\n  for (var i = 0, l = index; i < l; i++) {\n    var part = parsed[i];\n    if (tmp) {\n      if ('undefined' !== typeof part.p)\n        tmp = tmp[part.p];\n      else if ('undefined' !== typeof part.i)\n        tmp = tmp[part.i];\n      if (i == (l - 1)) res = tmp;\n    } else {\n      res = undefined;\n    }\n  }\n  return res;\n}\n\n});\n\nrequire.register(\"chai/lib/chai/utils/hasProperty.js\", function (exports, module) {\n/*!\n * Chai - hasProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\nvar type = require('chai/lib/chai/utils/type.js');\n\n/**\n * ### .hasProperty(object, name)\n *\n * This allows checking whether an object has\n * named property or numeric array index.\n *\n * Basically does the same thing as the `in`\n * operator but works properly with natives\n * and null/undefined values.\n *\n *     var obj = {\n *         arr: ['a', 'b', 'c']\n *       , str: 'Hello'\n *     }\n *\n * The following would be the results.\n *\n *     hasProperty('str', obj);  // true\n *     hasProperty('constructor', obj);  // true\n *     hasProperty('bar', obj);  // false\n *     \n *     hasProperty('length', obj.str); // true\n *     hasProperty(1, obj.str);  // true\n *     hasProperty(5, obj.str);  // false\n *\n *     hasProperty('length', obj.arr);  // true\n *     hasProperty(2, obj.arr);  // true\n *     hasProperty(3, obj.arr);  // false\n *\n * @param {Objuect} object\n * @param {String|Number} name\n * @returns {Boolean} whether it exists\n * @name getPathInfo\n * @api public\n */\n\nvar literals = {\n    'number': Number\n  , 'string': String\n};\n\nmodule.exports = function hasProperty(name, obj) {\n  var ot = type(obj);\n\n  // Bad Object, obviously no props at all\n  if(ot === 'null' || ot === 'undefined')\n    return false;\n\n  // The `in` operator does not work with certain literals\n  // box these before the check\n  if(literals[ot] && typeof obj !== 'object')\n    obj = new literals[ot](obj);\n\n  return name in obj;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/getProperties.js\", function (exports, module) {\n/*!\n * Chai - getProperties utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### .getProperties(object)\n *\n * This allows the retrieval of property names of an object, enumerable or not,\n * inherited or not.\n *\n * @param {Object} object\n * @returns {Array}\n * @name getProperties\n * @api public\n */\n\nmodule.exports = function getProperties(object) {\n  var result = Object.getOwnPropertyNames(subject);\n\n  function addProperty(property) {\n    if (result.indexOf(property) === -1) {\n      result.push(property);\n    }\n  }\n\n  var proto = Object.getPrototypeOf(subject);\n  while (proto !== null) {\n    Object.getOwnPropertyNames(proto).forEach(addProperty);\n    proto = Object.getPrototypeOf(proto);\n  }\n\n  return result;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/index.js\", function (exports, module) {\n/*!\n * chai\n * Copyright(c) 2011 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Main exports\n */\n\nvar exports = module.exports = {};\n\n/*!\n * test utility\n */\n\nexports.test = require('chai/lib/chai/utils/test.js');\n\n/*!\n * type utility\n */\n\nexports.type = require('chai/lib/chai/utils/type.js');\n\n/*!\n * message utility\n */\n\nexports.getMessage = require('chai/lib/chai/utils/getMessage.js');\n\n/*!\n * actual utility\n */\n\nexports.getActual = require('chai/lib/chai/utils/getActual.js');\n\n/*!\n * Inspect util\n */\n\nexports.inspect = require('chai/lib/chai/utils/inspect.js');\n\n/*!\n * Object Display util\n */\n\nexports.objDisplay = require('chai/lib/chai/utils/objDisplay.js');\n\n/*!\n * Flag utility\n */\n\nexports.flag = require('chai/lib/chai/utils/flag.js');\n\n/*!\n * Flag transferring utility\n */\n\nexports.transferFlags = require('chai/lib/chai/utils/transferFlags.js');\n\n/*!\n * Deep equal utility\n */\n\nexports.eql = require('chaijs~deep-eql@0.1.3');\n\n/*!\n * Deep path value\n */\n\nexports.getPathValue = require('chai/lib/chai/utils/getPathValue.js');\n\n/*!\n * Deep path info\n */\n\nexports.getPathInfo = require('chai/lib/chai/utils/getPathInfo.js');\n\n/*!\n * Check if a property exists\n */\n\nexports.hasProperty = require('chai/lib/chai/utils/hasProperty.js');\n\n/*!\n * Function name\n */\n\nexports.getName = require('chai/lib/chai/utils/getName.js');\n\n/*!\n * add Property\n */\n\nexports.addProperty = require('chai/lib/chai/utils/addProperty.js');\n\n/*!\n * add Method\n */\n\nexports.addMethod = require('chai/lib/chai/utils/addMethod.js');\n\n/*!\n * overwrite Property\n */\n\nexports.overwriteProperty = require('chai/lib/chai/utils/overwriteProperty.js');\n\n/*!\n * overwrite Method\n */\n\nexports.overwriteMethod = require('chai/lib/chai/utils/overwriteMethod.js');\n\n/*!\n * Add a chainable method\n */\n\nexports.addChainableMethod = require('chai/lib/chai/utils/addChainableMethod.js');\n\n/*!\n * Overwrite chainable method\n */\n\nexports.overwriteChainableMethod = require('chai/lib/chai/utils/overwriteChainableMethod.js');\n\n\n});\n\nrequire.register(\"chai/lib/chai/utils/inspect.js\", function (exports, module) {\n// This is (almost) directly from Node.js utils\n// https://github.com/joyent/node/blob/f8c335d0caf47f16d31413f89aa28eda3878e3aa/lib/util.js\n\nvar getName = require('chai/lib/chai/utils/getName.js');\nvar getProperties = require('chai/lib/chai/utils/getProperties.js');\nvar getEnumerableProperties = require('chai/lib/chai/utils/getEnumerableProperties.js');\n\nmodule.exports = inspect;\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Boolean} showHidden Flag that shows hidden (not enumerable)\n *    properties of objects.\n * @param {Number} depth Depth in which to descend in object. Default is 2.\n * @param {Boolean} colors Flag to turn on ANSI escape codes to color the\n *    output. Default is false (no coloring).\n */\nfunction inspect(obj, showHidden, depth, colors) {\n  var ctx = {\n    showHidden: showHidden,\n    seen: [],\n    stylize: function (str) { return str; }\n  };\n  return formatValue(ctx, obj, (typeof depth === 'undefined' ? 2 : depth));\n}\n\n// Returns true if object is a DOM element.\nvar isDOMElement = function (object) {\n  if (typeof HTMLElement === 'object') {\n    return object instanceof HTMLElement;\n  } else {\n    return object &&\n      typeof object === 'object' &&\n      object.nodeType === 1 &&\n      typeof object.nodeName === 'string';\n  }\n};\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (value && typeof value.inspect === 'function' &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes);\n    if (typeof ret !== 'string') {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // If this is a DOM element, try to get the outer HTML.\n  if (isDOMElement(value)) {\n    if ('outerHTML' in value) {\n      return value.outerHTML;\n      // This value does not have an outerHTML attribute,\n      //   it could still be an XML element\n    } else {\n      // Attempt to serialize it\n      try {\n        if (document.xmlVersion) {\n          var xmlSerializer = new XMLSerializer();\n          return xmlSerializer.serializeToString(value);\n        } else {\n          // Firefox 11- do not support outerHTML\n          //   It does, however, support innerHTML\n          //   Use the following to render the element\n          var ns = \"http://www.w3.org/1999/xhtml\";\n          var container = document.createElementNS(ns, '_');\n\n          container.appendChild(value.cloneNode(false));\n          html = container.innerHTML\n            .replace('><', '>' + value.innerHTML + '<');\n          container.innerHTML = '';\n          return html;\n        }\n      } catch (err) {\n        // This could be a non-native DOM implementation,\n        //   continue with the normal flow:\n        //   printing the element as if it is an object.\n      }\n    }\n  }\n\n  // Look up the keys of the object.\n  var visibleKeys = getEnumerableProperties(value);\n  var keys = ctx.showHidden ? getProperties(value) : visibleKeys;\n\n  // Some type of object without properties can be shortcutted.\n  // In IE, errors have a single `stack` property, or if they are vanilla `Error`,\n  // a `stack` plus `description` property; ignore those for consistency.\n  if (keys.length === 0 || (isError(value) && (\n      (keys.length === 1 && keys[0] === 'stack') ||\n      (keys.length === 2 && keys[0] === 'description' && keys[1] === 'stack')\n     ))) {\n    if (typeof value === 'function') {\n      var name = getName(value);\n      var nameSuffix = name ? ': ' + name : '';\n      return ctx.stylize('[Function' + nameSuffix + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toUTCString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (typeof value === 'function') {\n    var name = getName(value);\n    var nameSuffix = name ? ': ' + name : '';\n    base = ' [Function' + nameSuffix + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    return formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  switch (typeof value) {\n    case 'undefined':\n      return ctx.stylize('undefined', 'undefined');\n\n    case 'string':\n      var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                               .replace(/'/g, \"\\\\'\")\n                                               .replace(/\\\\\"/g, '\"') + '\\'';\n      return ctx.stylize(simple, 'string');\n\n    case 'number':\n      if (value === 0 && (1/value) === -Infinity) {\n        return ctx.stylize('-0', 'number');\n      }\n      return ctx.stylize('' + value, 'number');\n\n    case 'boolean':\n      return ctx.stylize('' + value, 'boolean');\n  }\n  // For some reason typeof null is \"object\", so special case here.\n  if (value === null) {\n    return ctx.stylize('null', 'null');\n  }\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (Object.prototype.hasOwnProperty.call(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str;\n  if (value.__lookupGetter__) {\n    if (value.__lookupGetter__(key)) {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Getter/Setter]', 'special');\n      } else {\n        str = ctx.stylize('[Getter]', 'special');\n      }\n    } else {\n      if (value.__lookupSetter__(key)) {\n        str = ctx.stylize('[Setter]', 'special');\n      }\n    }\n  }\n  if (visibleKeys.indexOf(key) < 0) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(value[key]) < 0) {\n      if (recurseTimes === null) {\n        str = formatValue(ctx, value[key], null);\n      } else {\n        str = formatValue(ctx, value[key], recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (typeof name === 'undefined') {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\nfunction isArray(ar) {\n  return Array.isArray(ar) ||\n         (typeof ar === 'object' && objectToString(ar) === '[object Array]');\n}\n\nfunction isRegExp(re) {\n  return typeof re === 'object' && objectToString(re) === '[object RegExp]';\n}\n\nfunction isDate(d) {\n  return typeof d === 'object' && objectToString(d) === '[object Date]';\n}\n\nfunction isError(e) {\n  return typeof e === 'object' && objectToString(e) === '[object Error]';\n}\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n});\n\nrequire.register(\"chai/lib/chai/utils/objDisplay.js\", function (exports, module) {\n/*!\n * Chai - flag utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar inspect = require('chai/lib/chai/utils/inspect.js');\nvar config = require('chai/lib/chai/config.js');\n\n/**\n * ### .objDisplay (object)\n *\n * Determines if an object or an array matches\n * criteria to be inspected in-line for error\n * messages or should be truncated.\n *\n * @param {Mixed} javascript object to inspect\n * @name objDisplay\n * @api public\n */\n\nmodule.exports = function (obj) {\n  var str = inspect(obj)\n    , type = Object.prototype.toString.call(obj);\n\n  if (config.truncateThreshold && str.length >= config.truncateThreshold) {\n    if (type === '[object Function]') {\n      return !obj.name || obj.name === ''\n        ? '[Function]'\n        : '[Function: ' + obj.name + ']';\n    } else if (type === '[object Array]') {\n      return '[ Array(' + obj.length + ') ]';\n    } else if (type === '[object Object]') {\n      var keys = Object.keys(obj)\n        , kstr = keys.length > 2\n          ? keys.splice(0, 2).join(', ') + ', ...'\n          : keys.join(', ');\n      return '{ Object (' + kstr + ') }';\n    } else {\n      return str;\n    }\n  } else {\n    return str;\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteMethod.js\", function (exports, module) {\n/*!\n * Chai - overwriteMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteMethod (ctx, name, fn)\n *\n * Overwites an already existing method and provides\n * access to previous function. Must return function\n * to be used for name.\n *\n *     utils.overwriteMethod(chai.Assertion.prototype, 'equal', function (_super) {\n *       return function (str) {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.value).to.equal(str);\n *         } else {\n *           _super.apply(this, arguments);\n *         }\n *       }\n *     });\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteMethod('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.equal('bar');\n *\n * @param {Object} ctx object whose method is to be overwritten\n * @param {String} name of method to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @name overwriteMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method) {\n  var _method = ctx[name]\n    , _super = function () { return this; };\n\n  if (_method && 'function' === typeof _method)\n    _super = _method;\n\n  ctx[name] = function () {\n    var result = method(_super).apply(this, arguments);\n    return result === undefined ? this : result;\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteProperty.js\", function (exports, module) {\n/*!\n * Chai - overwriteProperty utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteProperty (ctx, name, fn)\n *\n * Overwites an already existing property getter and provides\n * access to previous value. Must return function to use as getter.\n *\n *     utils.overwriteProperty(chai.Assertion.prototype, 'ok', function (_super) {\n *       return function () {\n *         var obj = utils.flag(this, 'object');\n *         if (obj instanceof Foo) {\n *           new chai.Assertion(obj.name).to.equal('bar');\n *         } else {\n *           _super.call(this);\n *         }\n *       }\n *     });\n *\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteProperty('foo', fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.be.ok;\n *\n * @param {Object} ctx object whose property is to be overwritten\n * @param {String} name of property to overwrite\n * @param {Function} getter function that returns a getter function to be used for name\n * @name overwriteProperty\n * @api public\n */\n\nmodule.exports = function (ctx, name, getter) {\n  var _get = Object.getOwnPropertyDescriptor(ctx, name)\n    , _super = function () {};\n\n  if (_get && 'function' === typeof _get.get)\n    _super = _get.get\n\n  Object.defineProperty(ctx, name,\n    { get: function () {\n        var result = getter(_super).call(this);\n        return result === undefined ? this : result;\n      }\n    , configurable: true\n  });\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/overwriteChainableMethod.js\", function (exports, module) {\n/*!\n * Chai - overwriteChainableMethod utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### overwriteChainableMethod (ctx, name, method, chainingBehavior)\n *\n * Overwites an already existing chainable method\n * and provides access to the previous function or\n * property.  Must return functions to be used for\n * name.\n *\n *     utils.overwriteChainableMethod(chai.Assertion.prototype, 'length',\n *       function (_super) {\n *       }\n *     , function (_super) {\n *       }\n *     );\n *\n * Can also be accessed directly from `chai.Assertion`.\n *\n *     chai.Assertion.overwriteChainableMethod('foo', fn, fn);\n *\n * Then can be used as any other assertion.\n *\n *     expect(myFoo).to.have.length(3);\n *     expect(myFoo).to.have.length.above(3);\n *\n * @param {Object} ctx object whose method / property is to be overwritten\n * @param {String} name of method / property to overwrite\n * @param {Function} method function that returns a function to be used for name\n * @param {Function} chainingBehavior function that returns a function to be used for property\n * @name overwriteChainableMethod\n * @api public\n */\n\nmodule.exports = function (ctx, name, method, chainingBehavior) {\n  var chainableBehavior = ctx.__methods[name];\n\n  var _chainingBehavior = chainableBehavior.chainingBehavior;\n  chainableBehavior.chainingBehavior = function () {\n    var result = chainingBehavior(_chainingBehavior).call(this);\n    return result === undefined ? this : result;\n  };\n\n  var _method = chainableBehavior.method;\n  chainableBehavior.method = function () {\n    var result = method(_method).apply(this, arguments);\n    return result === undefined ? this : result;\n  };\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/test.js\", function (exports, module) {\n/*!\n * Chai - test utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Module dependancies\n */\n\nvar flag = require('chai/lib/chai/utils/flag.js');\n\n/**\n * # test(object, expression)\n *\n * Test and object for expression.\n *\n * @param {Object} object (constructed Assertion)\n * @param {Arguments} chai.Assertion.prototype.assert arguments\n */\n\nmodule.exports = function (obj, args) {\n  var negate = flag(obj, 'negate')\n    , expr = args[0];\n  return negate ? !expr : expr;\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/transferFlags.js\", function (exports, module) {\n/*!\n * Chai - transferFlags utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/**\n * ### transferFlags(assertion, object, includeAll = true)\n *\n * Transfer all the flags for `assertion` to `object`. If\n * `includeAll` is set to `false`, then the base Chai\n * assertion flags (namely `object`, `ssfi`, and `message`)\n * will not be transferred.\n *\n *\n *     var newAssertion = new Assertion();\n *     utils.transferFlags(assertion, newAssertion);\n *\n *     var anotherAsseriton = new Assertion(myObj);\n *     utils.transferFlags(assertion, anotherAssertion, false);\n *\n * @param {Assertion} assertion the assertion to transfer the flags from\n * @param {Object} object the object to transfer the flags to; usually a new assertion\n * @param {Boolean} includeAll\n * @name transferFlags\n * @api private\n */\n\nmodule.exports = function (assertion, object, includeAll) {\n  var flags = assertion.__flags || (assertion.__flags = Object.create(null));\n\n  if (!object.__flags) {\n    object.__flags = Object.create(null);\n  }\n\n  includeAll = arguments.length === 3 ? includeAll : true;\n\n  for (var flag in flags) {\n    if (includeAll ||\n        (flag !== 'object' && flag !== 'ssfi' && flag != 'message')) {\n      object.__flags[flag] = flags[flag];\n    }\n  }\n};\n\n});\n\nrequire.register(\"chai/lib/chai/utils/type.js\", function (exports, module) {\n/*!\n * Chai - type utility\n * Copyright(c) 2012-2014 Jake Luer <jake@alogicalparadox.com>\n * MIT Licensed\n */\n\n/*!\n * Detectable javascript natives\n */\n\nvar natives = {\n    '[object Arguments]': 'arguments'\n  , '[object Array]': 'array'\n  , '[object Date]': 'date'\n  , '[object Function]': 'function'\n  , '[object Number]': 'number'\n  , '[object RegExp]': 'regexp'\n  , '[object String]': 'string'\n};\n\n/**\n * ### type(object)\n *\n * Better implementation of `typeof` detection that can\n * be used cross-browser. Handles the inconsistencies of\n * Array, `null`, and `undefined` detection.\n *\n *     utils.type({}) // 'object'\n *     utils.type(null) // `null'\n *     utils.type(undefined) // `undefined`\n *     utils.type([]) // `array`\n *\n * @param {Mixed} object to detect type of\n * @name type\n * @api private\n */\n\nmodule.exports = function (obj) {\n  var str = Object.prototype.toString.call(obj);\n  if (natives[str]) return natives[str];\n  if (obj === null) return 'null';\n  if (obj === undefined) return 'undefined';\n  if (obj === Object(obj)) return 'object';\n  return typeof obj;\n};\n\n});\n\nif (typeof exports == \"object\") {\n  module.exports = require(\"chai\");\n} else if (typeof define == \"function\" && define.amd) {\n  define(\"chai\", [], function(){ return require(\"chai\"); });\n} else {\n  (this || window)[\"chai\"] = require(\"chai\");\n}\n})()"]},"hash":"752cad1ca796737def583f9bd2821308b11e5bb2"}
