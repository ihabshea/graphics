{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","filenameRelative":"packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js.map","sourceFileName":"packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"callbacks"},"ignored":false,"code":"define([\"./core\", \"./var/rnotwhite\"], function (jQuery, rnotwhite) {\n\t// String to Object options format cache\n\tvar optionsCache = {}; // Convert String-formatted options into Object-formatted ones and store in cache\n\n\tfunction createOptions(options) {\n\t\tvar object = optionsCache[options] = {};\n\t\tjQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t} /*\n    * Create a callback list using the following parameters:\n    *\n    *\toptions: an optional list of space-separated options that will change how\n    *\t\t\tthe callback list behaves or a more traditional option object\n    *\n    * By default a callback list will act like an event callback list and can be\n    * \"fired\" multiple times.\n    *\n    * Possible options:\n    *\n    *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n    *\n    *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n    *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n    *\t\t\t\t\tvalues (like a Deferred)\n    *\n    *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n    *\n    *\tstopOnFalse:\tinterrupt callings when a callback returns false\n    *\n    */\n\n\tjQuery.Callbacks = function (options) {\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t    // Flag to know if list was already fired\n\t\tfired,\n\t\t    // Flag to know if list is currently firing\n\t\tfiring,\n\t\t    // First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t    // End of the loop when firing\n\t\tfiringLength,\n\t\t    // Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t    // Actual callback list\n\t\tlist = [],\n\t\t    // Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t    // Fire callbacks\n\t\tfire = function (data) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\n\t\t\tfor (; list && firingIndex < firingLength; firingIndex++) {\n\t\t\t\tif (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\tif (list) {\n\t\t\t\tif (stack) {\n\t\t\t\t\tif (stack.length) {\n\t\t\t\t\t\tfire(stack.shift());\n\t\t\t\t\t}\n\t\t\t\t} else if (memory) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t    // Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function () {\n\t\t\t\tif (list) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function () {\n\t\t\t\t\t\tfunction add(args) {\n\t\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\t\tvar type = jQuery.type(arg);\n\n\t\t\t\t\t\t\t\tif (type === \"function\") {\n\t\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (arg && arg.length && type !== \"string\") {\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn add;\n\t\t\t\t\t})()(arguments); // Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tfiringLength = list.length; // With memory, if we're not firing then\n\t\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if (memory) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire(memory);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function () {\n\t\t\t\tif (list) {\n\t\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\t\tvar index;\n\n\t\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\t\tlist.splice(index, 1); // Handle firing indexes\n\n\t\t\t\t\t\t\tif (firing) {\n\t\t\t\t\t\t\t\tif (index <= firingLength) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function (fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function () {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function () {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function () {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function () {\n\t\t\t\tstack = undefined;\n\n\t\t\t\tif (!memory) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function () {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function (context, args) {\n\t\t\t\tif (list && (!fired || stack)) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\n\t\t\t\t\tif (firing) {\n\t\t\t\t\t\tstack.push(args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire(args);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function () {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function () {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\treturn jQuery;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js"],"names":["define","jQuery","rnotwhite","optionsCache","createOptions","options","object","each","match","_","flag","Callbacks","extend","memory","fired","firing","firingStart","firingLength","firingIndex","list","stack","once","fire","data","length","apply","stopOnFalse","shift","self","disable","add","start","args","arg","type","unique","has","push","arguments","remove","index","inArray","splice","fn","empty","undefined","disabled","lock","locked","fireWith","context","slice"],"mappings":"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","file":"packages/zurb:foundation-sites/vendor/jquery/src/callbacks.js.map","sourcesContent":["define([\n\t\"./core\",\n\t\"./var/rnotwhite\"\n], function( jQuery, rnotwhite ) {\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\tfiringLength = 0;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n});\n"]},"hash":"63a611b05f3e578fc43d7b49156c0d6d2e2b1d50"}
