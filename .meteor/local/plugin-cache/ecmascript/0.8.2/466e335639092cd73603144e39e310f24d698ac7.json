{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js","filenameRelative":"packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js.map","sourceFileName":"packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"deferred"},"ignored":false,"code":"define([\"./core\", \"./var/slice\", \"./callbacks\"], function (jQuery, slice) {\n\tjQuery.extend({\n\t\tDeferred: function (func) {\n\t\t\tvar tuples = [// action, add listener, listener list, final state\n\t\t\t[\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n\t\t\t    state = \"pending\",\n\t\t\t    promise = {\n\t\t\t\tstate: function () {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function () {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function () /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\n\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function (obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, promise) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {}; // Keep pipe for back-compat\n\n\t\t\tpromise.pipe = promise.then; // Add list-specific methods\n\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n\t\t\t\tpromise[tuple[1]] = list.add; // Handle state\n\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\tstate = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n\t\t\t\t} // deferred[ resolve | reject | notify ]\n\n\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t}); // Make the deferred a promise\n\n\t\t\tpromise.promise(deferred); // Call given func if any\n\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t} // All done!\n\n\n\t\t\treturn deferred;\n\t\t},\n\t\t// Deferred helper\n\t\twhen: function (subordinate /* , ..., subordinateN */) {\n\t\t\tvar i = 0,\n\t\t\t    resolveValues = slice.call(arguments),\n\t\t\t    length = resolveValues.length,\n\t\t\t    // the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n\t\t\t    // the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\t\t\t    // Update function for both resolve and progress values\n\t\t\tupdateFunc = function (i, contexts, values) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tcontexts[i] = this;\n\t\t\t\t\tvalues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\n\t\t\t\t\tif (values === progressValues) {\n\t\t\t\t\t\tdeferred.notifyWith(contexts, values);\n\t\t\t\t\t} else if (! --remaining) {\n\t\t\t\t\t\tdeferred.resolveWith(contexts, values);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t    progressValues,\n\t\t\t    progressContexts,\n\t\t\t    resolveContexts; // Add listeners to Deferred subordinates; treat others as resolved\n\n\n\t\t\tif (length > 1) {\n\t\t\t\tprogressValues = new Array(length);\n\t\t\t\tprogressContexts = new Array(length);\n\t\t\t\tresolveContexts = new Array(length);\n\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n\t\t\t\t\t\tresolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // If we're not waiting on anything, resolve the master\n\n\n\t\t\tif (!remaining) {\n\t\t\t\tdeferred.resolveWith(resolveContexts, resolveValues);\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\treturn jQuery;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js"],"names":["define","jQuery","slice","extend","Deferred","func","tuples","Callbacks","state","promise","always","deferred","done","arguments","fail","then","fns","newDefer","each","i","tuple","fn","isFunction","returned","apply","progress","notify","resolve","reject","obj","pipe","list","stateString","add","disable","lock","fireWith","call","when","subordinate","resolveValues","length","remaining","updateFunc","contexts","values","value","progressValues","notifyWith","resolveWith","progressContexts","resolveContexts","Array"],"mappings":"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","file":"packages/zurb:foundation-sites/bower_components/jquery/src/deferred.js.map","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/slice\",\n\t\"./callbacks\"\n], function( jQuery, slice ) {\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ) ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis === promise ? newDefer.promise() : this,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add( function() {\n\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 ||\n\t\t\t\t( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred.\n\t\t\t// If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) )\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n} );\n\nreturn jQuery;\n} );\n"]},"hash":"466e335639092cd73603144e39e310f24d698ac7"}
