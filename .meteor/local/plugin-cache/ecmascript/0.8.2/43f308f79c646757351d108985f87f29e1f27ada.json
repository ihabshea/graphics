{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js","filenameRelative":"packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js.map","sourceFileName":"packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"Data"},"ignored":false,"code":"define([\"../core\", \"../var/rnotwhite\", \"./var/acceptData\"], function (jQuery, rnotwhite, acceptData) {\n\tfunction Data() {\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\tData.prototype = {\n\t\tregister: function (owner, initial) {\n\t\t\tvar value = initial || {}; // If it is a node unlikely to be stringify-ed or looped over\n\t\t\t// use plain assignment\n\n\t\t\tif (owner.nodeType) {\n\t\t\t\towner[this.expando] = value; // Otherwise secure it in a non-enumerable, non-writable property\n\t\t\t\t// configurability must be true to allow the property to be\n\t\t\t\t// deleted with the delete operator\n\t\t\t} else {\n\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn owner[this.expando];\n\t\t},\n\t\tcache: function (owner) {\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif (!acceptData(owner)) {\n\t\t\t\treturn {};\n\t\t\t} // Check if the owner object already has a cache\n\n\n\t\t\tvar value = owner[this.expando]; // If not, create one\n\n\t\t\tif (!value) {\n\t\t\t\tvalue = {}; // We can accept data for non-element nodes in modern browsers,\n\t\t\t\t// but we should not, see #8335.\n\t\t\t\t// Always return an empty object.\n\n\t\t\t\tif (acceptData(owner)) {\n\t\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t\t// use plain assignment\n\t\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\t\towner[this.expando] = value; // Otherwise secure it in a non-enumerable property\n\t\t\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t\t\t// deleted when data is removed\n\t\t\t\t\t} else {\n\t\t\t\t\t\tObject.defineProperty(owner, this.expando, {\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn value;\n\t\t},\n\t\tset: function (owner, data, value) {\n\t\t\tvar prop,\n\t\t\t    cache = this.cache(owner); // Handle: [ owner, key, value ] args\n\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\tcache[data] = value; // Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\t\tfor (prop in meteorBabelHelpers.sanitizeForInObject(data)) {\n\t\t\t\t\tcache[prop] = data[prop];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cache;\n\t\t},\n\t\tget: function (owner, key) {\n\t\t\treturn key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];\n\t\t},\n\t\taccess: function (owner, key, value) {\n\t\t\tvar stored; // In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\n\t\t\tif (key === undefined || key && typeof key === \"string\" && value === undefined) {\n\t\t\t\tstored = this.get(owner, key);\n\t\t\t\treturn stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\n\t\t\t} // When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\n\n\t\t\tthis.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function (owner, key) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    camel,\n\t\t\t    cache = owner[this.expando];\n\n\t\t\tif (cache === undefined) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key === undefined) {\n\t\t\t\tthis.register(owner);\n\t\t\t} else {\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif (jQuery.isArray(key)) {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = key.concat(key.map(jQuery.camelCase));\n\t\t\t\t} else {\n\t\t\t\t\tcamel = jQuery.camelCase(key); // Try the string as a key before any manipulation\n\n\t\t\t\t\tif (key in cache) {\n\t\t\t\t\t\tname = [key, camel];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\tname = name in cache ? [name] : name.match(rnotwhite) || [];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete cache[name[i]];\n\t\t\t\t}\n\t\t\t} // Remove the expando if there's no more data\n\n\n\t\t\tif (key === undefined || jQuery.isEmptyObject(cache)) {\n\t\t\t\t// Support: Chrome <= 35-45+\n\t\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\t\tif (owner.nodeType) {\n\t\t\t\t\towner[this.expando] = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tdelete owner[this.expando];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function (owner) {\n\t\t\tvar cache = owner[this.expando];\n\t\t\treturn cache !== undefined && !jQuery.isEmptyObject(cache);\n\t\t}\n\t};\n\treturn Data;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js"],"names":["define","jQuery","rnotwhite","acceptData","Data","expando","uid","prototype","register","owner","initial","value","nodeType","Object","defineProperty","writable","configurable","cache","set","data","prop","get","key","undefined","access","stored","camelCase","remove","i","name","camel","isArray","concat","map","match","length","isEmptyObject","hasData"],"mappings":"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","file":"packages/zurb:foundation-sites/bower_components/jquery/src/data/Data.js.map","sourcesContent":["define( [\n\t\"../core\",\n\t\"../var/rnotwhite\",\n\t\"./var/acceptData\"\n], function( jQuery, rnotwhite, acceptData ) {\n\nfunction Data() {\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\n\nData.prototype = {\n\n\tregister: function( owner, initial ) {\n\t\tvar value = initial || {};\n\n\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t// use plain assignment\n\t\tif ( owner.nodeType ) {\n\t\t\towner[ this.expando ] = value;\n\n\t\t// Otherwise secure it in a non-enumerable, non-writable property\n\t\t// configurability must be true to allow the property to be\n\t\t// deleted with the delete operator\n\t\t} else {\n\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tconfigurable: true\n\t\t\t} );\n\t\t}\n\t\treturn owner[ this.expando ];\n\t},\n\tcache: function( owner ) {\n\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return an empty object.\n\t\tif ( !acceptData( owner ) ) {\n\t\t\treturn {};\n\t\t}\n\n\t\t// Check if the owner object already has a cache\n\t\tvar value = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !value ) {\n\t\t\tvalue = {};\n\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return an empty object.\n\t\t\tif ( acceptData( owner ) ) {\n\n\t\t\t\t// If it is a node unlikely to be stringify-ed or looped over\n\t\t\t\t// use plain assignment\n\t\t\t\tif ( owner.nodeType ) {\n\t\t\t\t\towner[ this.expando ] = value;\n\n\t\t\t\t// Otherwise secure it in a non-enumerable property\n\t\t\t\t// configurable must be true to allow the property to be\n\t\t\t\t// deleted when data is removed\n\t\t\t\t} else {\n\t\t\t\t\tObject.defineProperty( owner, this.expando, {\n\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\tconfigurable: true\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\tcache = this.cache( owner );\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\n\t\t\t// Copy the properties one-by-one to the cache object\n\t\t\tfor ( prop in data ) {\n\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\treturn key === undefined ?\n\t\t\tthis.cache( owner ) :\n\t\t\towner[ this.expando ] && owner[ this.expando ][ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t( ( key && typeof key === \"string\" ) && value === undefined ) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase( key ) );\n\t\t}\n\n\t\t// When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tcache = owner[ this.expando ];\n\n\t\tif ( cache === undefined ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.register( owner );\n\n\t\t} else {\n\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\n\t\t// Remove the expando if there's no more data\n\t\tif ( key === undefined || jQuery.isEmptyObject( cache ) ) {\n\n\t\t\t// Support: Chrome <= 35-45+\n\t\t\t// Webkit & Blink performance suffers when deleting properties\n\t\t\t// from DOM nodes, so set to undefined instead\n\t\t\t// https://code.google.com/p/chromium/issues/detail?id=378607\n\t\t\tif ( owner.nodeType ) {\n\t\t\t\towner[ this.expando ] = undefined;\n\t\t\t} else {\n\t\t\t\tdelete owner[ this.expando ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\tvar cache = owner[ this.expando ];\n\t\treturn cache !== undefined && !jQuery.isEmptyObject( cache );\n\t}\n};\n\nreturn Data;\n} );\n"]},"hash":"43f308f79c646757351d108985f87f29e1f27ada"}
