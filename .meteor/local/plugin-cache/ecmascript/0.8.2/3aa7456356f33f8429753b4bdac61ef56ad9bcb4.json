{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js","filenameRelative":"packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js.map","sourceFileName":"packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"callbacks"},"ignored":false,"code":"define([\"./core\", \"./var/rnotwhite\"], function (jQuery, rnotwhite) {\n\t// Convert String-formatted options into Object-formatted ones\n\tfunction createOptions(options) {\n\t\tvar object = {};\n\t\tjQuery.each(options.match(rnotwhite) || [], function (_, flag) {\n\t\t\tobject[flag] = true;\n\t\t});\n\t\treturn object;\n\t} /*\n    * Create a callback list using the following parameters:\n    *\n    *\toptions: an optional list of space-separated options that will change how\n    *\t\t\tthe callback list behaves or a more traditional option object\n    *\n    * By default a callback list will act like an event callback list and can be\n    * \"fired\" multiple times.\n    *\n    * Possible options:\n    *\n    *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n    *\n    *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n    *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n    *\t\t\t\t\tvalues (like a Deferred)\n    *\n    *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n    *\n    *\tstopOnFalse:\tinterrupt callings when a callback returns false\n    *\n    */\n\n\tjQuery.Callbacks = function (options) {\n\t\t// Convert options from String-formatted to Object-formatted if needed\n\t\t// (we check in cache first)\n\t\toptions = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n\t\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\t\t    // Last fire value for non-forgettable lists\n\t\tmemory,\n\t\t    // Flag to know if list was already fired\n\t\tfired,\n\t\t    // Flag to prevent firing\n\t\tlocked,\n\t\t    // Actual callback list\n\t\tlist = [],\n\t\t    // Queue of execution data for repeatable lists\n\t\tqueue = [],\n\t\t    // Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\t\t    // Fire callbacks\n\t\tfire = function () {\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once; // Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\n\t\t\tfired = firing = true;\n\n\t\t\tfor (; queue.length; firingIndex = -1) {\n\t\t\t\tmemory = queue.shift();\n\n\t\t\t\twhile (++firingIndex < list.length) {\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Forget the data if we're done with it\n\n\n\t\t\tif (!options.memory) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false; // Clean up if we're done firing for good\n\n\t\t\tif (locked) {\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif (memory) {\n\t\t\t\t\tlist = []; // Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t    // Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function () {\n\t\t\t\tif (list) {\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push(memory);\n\t\t\t\t\t}\n\n\t\t\t\t\t(function () {\n\t\t\t\t\t\tfunction add(args) {\n\t\t\t\t\t\t\tjQuery.each(args, function (_, arg) {\n\t\t\t\t\t\t\t\tif (jQuery.isFunction(arg)) {\n\t\t\t\t\t\t\t\t\tif (!options.unique || !self.has(arg)) {\n\t\t\t\t\t\t\t\t\t\tlist.push(arg);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else if (arg && arg.length && jQuery.type(arg) !== \"string\") {\n\t\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\t\tadd(arg);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn add;\n\t\t\t\t\t})()(arguments);\n\n\t\t\t\t\tif (memory && !firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function () {\n\t\t\t\tjQuery.each(arguments, function (_, arg) {\n\t\t\t\t\tvar index;\n\n\t\t\t\t\twhile ((index = jQuery.inArray(arg, list, index)) > -1) {\n\t\t\t\t\t\tlist.splice(index, 1); // Handle firing indexes\n\n\t\t\t\t\t\tif (index <= firingIndex) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function (fn) {\n\t\t\t\treturn fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function () {\n\t\t\t\tif (list) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function () {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function () {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function () {\n\t\t\t\tlocked = queue = [];\n\n\t\t\t\tif (!memory) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function () {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function (context, args) {\n\t\t\t\tif (!locked) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [context, args.slice ? args.slice() : args];\n\t\t\t\t\tqueue.push(args);\n\n\t\t\t\t\tif (!firing) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function () {\n\t\t\t\tself.fireWith(this, arguments);\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function () {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\t\treturn self;\n\t};\n\n\treturn jQuery;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js"],"names":["define","jQuery","rnotwhite","createOptions","options","object","each","match","_","flag","Callbacks","extend","firing","memory","fired","locked","list","queue","firingIndex","fire","once","length","shift","apply","stopOnFalse","self","add","push","args","arg","isFunction","unique","has","type","arguments","remove","index","inArray","splice","fn","empty","disable","disabled","lock","fireWith","context","slice"],"mappings":"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","file":"packages/zurb:foundation-sites/bower_components/jquery/src/callbacks.js.map","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/rnotwhite\"\n], function( jQuery, rnotwhite ) {\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( jQuery.isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && jQuery.type( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n} );\n"]},"hash":"3aa7456356f33f8429753b4bdac61ef56ad9bcb4"}
