{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/vendor/jquery/src/ajax.js","filenameRelative":"packages/zurb:foundation-sites/vendor/jquery/src/ajax.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/vendor/jquery/src/ajax.js.map","sourceFileName":"packages/zurb:foundation-sites/vendor/jquery/src/ajax.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"ajax"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\ndefine([\"./core\", \"./var/rnotwhite\", \"./ajax/var/nonce\", \"./ajax/var/rquery\", \"./core/init\", \"./ajax/parseJSON\", \"./ajax/parseXML\", \"./deferred\"], function (jQuery, rnotwhite, nonce, rquery) {\n\tvar rhash = /#.*$/,\n\t    rts = /([?&])_=[^&]*/,\n\t    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t    // #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\t    rnoContent = /^(?:GET|HEAD)$/,\n\t    rprotocol = /^\\/\\//,\n\t    rurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\t    /* Prefilters\n      * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n      * 2) These are called:\n      *    - BEFORE asking for a transport\n      *    - AFTER param serialization (s.data is a string if s.processData is true)\n      * 3) key is the dataType\n      * 4) the catchall symbol \"*\" can be used\n      * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n      */prefilters = {},\n\t    /* Transports bindings\n      * 1) key is the dataType\n      * 2) the catchall symbol \"*\" can be used\n      * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n      */transports = {},\n\t    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat(\"*\"),\n\t    // Document location\n\tajaxLocation = window.location.href,\n\t    // Segment location into parts\n\tajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || []; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n\tfunction addToPrefiltersOrTransports(structure) {\n\t\t// dataTypeExpression is optional and defaults to \"*\"\n\t\treturn function (dataTypeExpression, func) {\n\t\t\tif (typeof dataTypeExpression !== \"string\") {\n\t\t\t\tfunc = dataTypeExpression;\n\t\t\t\tdataTypeExpression = \"*\";\n\t\t\t}\n\n\t\t\tvar dataType,\n\t\t\t    i = 0,\n\t\t\t    dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];\n\n\t\t\tif (jQuery.isFunction(func)) {\n\t\t\t\t// For each dataType in the dataTypeExpression\n\t\t\t\twhile (dataType = dataTypes[i++]) {\n\t\t\t\t\t// Prepend if requested\n\t\t\t\t\tif (dataType[0] === \"+\") {\n\t\t\t\t\t\tdataType = dataType.slice(1) || \"*\";\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n\t\t\t\t\t} else {\n\t\t\t\t\t\t(structure[dataType] = structure[dataType] || []).push(func);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t} // Base inspection function for prefilters and transports\n\n\n\tfunction inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n\t\tvar inspected = {},\n\t\t    seekingTransport = structure === transports;\n\n\t\tfunction inspect(dataType) {\n\t\t\tvar selected;\n\t\t\tinspected[dataType] = true;\n\t\t\tjQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n\t\t\t\tvar dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n\t\t\t\tif (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n\t\t\t\t\toptions.dataTypes.unshift(dataTypeOrTransport);\n\t\t\t\t\tinspect(dataTypeOrTransport);\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (seekingTransport) {\n\t\t\t\t\treturn !(selected = dataTypeOrTransport);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn selected;\n\t\t}\n\n\t\treturn inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n\t} // A special extend for ajax options\n\t// that takes \"flat\" options (not to be deep extended)\n\t// Fixes #9887\n\n\n\tfunction ajaxExtend(target, src) {\n\t\tvar key,\n\t\t    deep,\n\t\t    flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\t\tfor (key in meteorBabelHelpers.sanitizeForInObject(src)) {\n\t\t\tif (src[key] !== undefined) {\n\t\t\t\t(flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n\t\t\t}\n\t\t}\n\n\t\tif (deep) {\n\t\t\tjQuery.extend(true, target, deep);\n\t\t}\n\n\t\treturn target;\n\t} /* Handles responses to an ajax request:\n    * - finds the right dataType (mediates between content-type and expected dataType)\n    * - returns the corresponding response\n    */\n\n\tfunction ajaxHandleResponses(s, jqXHR, responses) {\n\t\tvar ct,\n\t\t    type,\n\t\t    finalDataType,\n\t\t    firstDataType,\n\t\t    contents = s.contents,\n\t\t    dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n\t\twhile (dataTypes[0] === \"*\") {\n\t\t\tdataTypes.shift();\n\n\t\t\tif (ct === undefined) {\n\t\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t\t}\n\t\t} // Check if we're dealing with a known content-type\n\n\n\t\tif (ct) {\n\t\t\tfor (type in meteorBabelHelpers.sanitizeForInObject(contents)) {\n\t\t\t\tif (contents[type] && contents[type].test(ct)) {\n\t\t\t\t\tdataTypes.unshift(type);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} // Check to see if we have a response for the expected dataType\n\n\n\t\tif (dataTypes[0] in responses) {\n\t\t\tfinalDataType = dataTypes[0];\n\t\t} else {\n\t\t\t// Try convertible dataTypes\n\t\t\tfor (type in meteorBabelHelpers.sanitizeForInObject(responses)) {\n\t\t\t\tif (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n\t\t\t\t\tfinalDataType = type;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (!firstDataType) {\n\t\t\t\t\tfirstDataType = type;\n\t\t\t\t}\n\t\t\t} // Or just use first one\n\n\n\t\t\tfinalDataType = finalDataType || firstDataType;\n\t\t} // If we found a dataType\n\t\t// We add the dataType to the list if needed\n\t\t// and return the corresponding response\n\n\n\t\tif (finalDataType) {\n\t\t\tif (finalDataType !== dataTypes[0]) {\n\t\t\t\tdataTypes.unshift(finalDataType);\n\t\t\t}\n\n\t\t\treturn responses[finalDataType];\n\t\t}\n\t} /* Chain conversions given the request and the original response\n    * Also sets the responseXXX fields on the jqXHR instance\n    */\n\n\tfunction ajaxConvert(s, response, jqXHR, isSuccess) {\n\t\tvar conv2,\n\t\t    current,\n\t\t    conv,\n\t\t    tmp,\n\t\t    prev,\n\t\t    converters = {},\n\t\t    // Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n\t\tif (dataTypes[1]) {\n\t\t\tfor (conv in meteorBabelHelpers.sanitizeForInObject(s.converters)) {\n\t\t\t\tconverters[conv.toLowerCase()] = s.converters[conv];\n\t\t\t}\n\t\t}\n\n\t\tcurrent = dataTypes.shift(); // Convert to each sequential dataType\n\n\t\twhile (current) {\n\t\t\tif (s.responseFields[current]) {\n\t\t\t\tjqXHR[s.responseFields[current]] = response;\n\t\t\t} // Apply the dataFilter if provided\n\n\n\t\t\tif (!prev && isSuccess && s.dataFilter) {\n\t\t\t\tresponse = s.dataFilter(response, s.dataType);\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t\tcurrent = dataTypes.shift();\n\n\t\t\tif (current) {\n\t\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\t\tif (current === \"*\") {\n\t\t\t\t\tcurrent = prev; // Convert response if prev dataType is non-auto and differs from current\n\t\t\t\t} else if (prev !== \"*\" && prev !== current) {\n\t\t\t\t\t// Seek a direct converter\n\t\t\t\t\tconv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n\t\t\t\t\tif (!conv) {\n\t\t\t\t\t\tfor (conv2 in meteorBabelHelpers.sanitizeForInObject(converters)) {\n\t\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\t\ttmp = conv2.split(\" \");\n\n\t\t\t\t\t\t\tif (tmp[1] === current) {\n\t\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\t\tconv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n\t\t\t\t\t\t\t\tif (conv) {\n\t\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\t\tif (conv === true) {\n\t\t\t\t\t\t\t\t\t\tconv = converters[conv2]; // Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t\t} else if (converters[conv2] !== true) {\n\t\t\t\t\t\t\t\t\t\tcurrent = tmp[0];\n\t\t\t\t\t\t\t\t\t\tdataTypes.unshift(tmp[1]);\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // Apply converter (if not an equivalence)\n\n\n\t\t\t\t\tif (conv !== true) {\n\t\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\t\tif (conv && s[\"throws\"]) {\n\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tresponse = conv(response);\n\t\t\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\tstate: \"success\",\n\t\t\tdata: response\n\t\t};\n\t}\n\n\tjQuery.extend({\n\t\t// Counter for holding the number of active queries\n\t\tactive: 0,\n\t\t// Last-Modified header cache for next request\n\t\tlastModified: {},\n\t\tetag: {},\n\t\tajaxSettings: {\n\t\t\turl: ajaxLocation,\n\t\t\ttype: \"GET\",\n\t\t\tisLocal: rlocalProtocol.test(ajaxLocParts[1]),\n\t\t\tglobal: true,\n\t\t\tprocessData: true,\n\t\t\tasync: true,\n\t\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t\t/*\n   timeout: 0,\n   data: null,\n   dataType: null,\n   username: null,\n   password: null,\n   cache: null,\n   throws: false,\n   traditional: false,\n   headers: {},\n   */accepts: {\n\t\t\t\t\"*\": allTypes,\n\t\t\t\ttext: \"text/plain\",\n\t\t\t\thtml: \"text/html\",\n\t\t\t\txml: \"application/xml, text/xml\",\n\t\t\t\tjson: \"application/json, text/javascript\"\n\t\t\t},\n\t\t\tcontents: {\n\t\t\t\txml: /xml/,\n\t\t\t\thtml: /html/,\n\t\t\t\tjson: /json/\n\t\t\t},\n\t\t\tresponseFields: {\n\t\t\t\txml: \"responseXML\",\n\t\t\t\ttext: \"responseText\",\n\t\t\t\tjson: \"responseJSON\"\n\t\t\t},\n\t\t\t// Data converters\n\t\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\t\tconverters: {\n\t\t\t\t// Convert anything to text\n\t\t\t\t\"* text\": String,\n\t\t\t\t// Text to html (true = no transformation)\n\t\t\t\t\"text html\": true,\n\t\t\t\t// Evaluate text as a json expression\n\t\t\t\t\"text json\": jQuery.parseJSON,\n\t\t\t\t// Parse text as xml\n\t\t\t\t\"text xml\": jQuery.parseXML\n\t\t\t},\n\t\t\t// For options that shouldn't be deep extended:\n\t\t\t// you can add your own custom options here if\n\t\t\t// and when you create one that shouldn't be\n\t\t\t// deep extended (see ajaxExtend)\n\t\t\tflatOptions: {\n\t\t\t\turl: true,\n\t\t\t\tcontext: true\n\t\t\t}\n\t\t},\n\t\t// Creates a full fledged settings object into target\n\t\t// with both ajaxSettings and settings fields.\n\t\t// If target is omitted, writes into ajaxSettings.\n\t\tajaxSetup: function (target, settings) {\n\t\t\treturn settings ? // Building a settings object\n\t\t\tajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n\t\t\tajaxExtend(jQuery.ajaxSettings, target);\n\t\t},\n\t\tajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n\t\tajaxTransport: addToPrefiltersOrTransports(transports),\n\t\t// Main method\n\t\tajax: function (url, options) {\n\t\t\t// If url is an object, simulate pre-1.5 signature\n\t\t\tif ((typeof url === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(url)) === \"object\") {\n\t\t\t\toptions = url;\n\t\t\t\turl = undefined;\n\t\t\t} // Force options to be an object\n\n\n\t\t\toptions = options || {};\n\t\t\tvar transport,\n\t\t\t    // URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t    // Response headers\n\t\t\tresponseHeadersString,\n\t\t\t    responseHeaders,\n\t\t\t    // timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t    // Cross-domain detection vars\n\t\t\tparts,\n\t\t\t    // To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t    // Loop variable\n\t\t\ti,\n\t\t\t    // Create the final options object\n\t\t\ts = jQuery.ajaxSetup({}, options),\n\t\t\t    // Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t    // Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n\t\t\t    // Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\t    completeDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t    // Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t    // Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\t    requestHeadersNames = {},\n\t\t\t    // The jqXHR state\n\t\t\tstate = 0,\n\t\t\t    // Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t    // Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function (key) {\n\t\t\t\t\tvar match;\n\n\t\t\t\t\tif (state === 2) {\n\t\t\t\t\t\tif (!responseHeaders) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\n\t\t\t\t\t\t\twhile (match = rheaders.exec(responseHeadersString)) {\n\t\t\t\t\t\t\t\tresponseHeaders[match[1].toLowerCase()] = match[2];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmatch = responseHeaders[key.toLowerCase()];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function () {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function (name, value) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\tname = requestHeadersNames[lname] = requestHeadersNames[lname] || name;\n\t\t\t\t\t\trequestHeaders[name] = value;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function (type) {\n\t\t\t\t\tif (!state) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function (map) {\n\t\t\t\t\tvar code;\n\n\t\t\t\t\tif (map) {\n\t\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\t\tfor (code in meteorBabelHelpers.sanitizeForInObject(map)) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[code] = [statusCode[code], map[code]];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always(map[jqXHR.status]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function (statusText) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\n\t\t\t\t\tif (transport) {\n\t\t\t\t\t\ttransport.abort(finalText);\n\t\t\t\t\t}\n\n\t\t\t\t\tdone(0, finalText);\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t}; // Attach deferreds\n\n\t\t\tdeferred.promise(jqXHR).complete = completeDeferred.add;\n\t\t\tjqXHR.success = jqXHR.done;\n\t\t\tjqXHR.error = jqXHR.fail; // Remove hash character (#7531: and string promotion)\n\t\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t\t// We also use the url parameter if available\n\n\t\t\ts.url = ((url || s.url || ajaxLocation) + \"\").replace(rhash, \"\").replace(rprotocol, ajaxLocParts[1] + \"//\"); // Alias method option to type as per ticket #12004\n\n\t\t\ts.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n\t\t\ts.dataTypes = jQuery.trim(s.dataType || \"*\").toLowerCase().match(rnotwhite) || [\"\"]; // A cross-domain request is in order when we have a protocol:host:port mismatch\n\n\t\t\tif (s.crossDomain == null) {\n\t\t\t\tparts = rurl.exec(s.url.toLowerCase());\n\t\t\t\ts.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === \"http:\" ? \"80\" : \"443\")) !== (ajaxLocParts[3] || (ajaxLocParts[1] === \"http:\" ? \"80\" : \"443\"))));\n\t\t\t} // Convert data if not already a string\n\n\n\t\t\tif (s.data && s.processData && typeof s.data !== \"string\") {\n\t\t\t\ts.data = jQuery.param(s.data, s.traditional);\n\t\t\t} // Apply prefilters\n\n\n\t\t\tinspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n\t\t\tif (state === 2) {\n\t\t\t\treturn jqXHR;\n\t\t\t} // We can fire global events as of now if asked to\n\t\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n\t\t\tfireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n\t\t\tif (fireGlobals && jQuery.active++ === 0) {\n\t\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t\t} // Uppercase the type\n\n\n\t\t\ts.type = s.type.toUpperCase(); // Determine if request has content\n\n\t\t\ts.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n\t\t\t// and/or If-None-Match header later on\n\n\t\t\tcacheURL = s.url; // More options handling for requests with no content\n\n\t\t\tif (!s.hasContent) {\n\t\t\t\t// If data is available, append data to url\n\t\t\t\tif (s.data) {\n\t\t\t\t\tcacheURL = s.url += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n\t\t\t\t\tdelete s.data;\n\t\t\t\t} // Add anti-cache in url if needed\n\n\n\t\t\t\tif (s.cache === false) {\n\t\t\t\t\ts.url = rts.test(cacheURL) ? // If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace(rts, \"$1_=\" + nonce++) : // Otherwise add one to the end\n\t\t\t\t\tcacheURL + (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce++;\n\t\t\t\t}\n\t\t\t} // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n\t\t\tif (s.ifModified) {\n\t\t\t\tif (jQuery.lastModified[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n\t\t\t\t}\n\n\t\t\t\tif (jQuery.etag[cacheURL]) {\n\t\t\t\t\tjqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n\t\t\t\t}\n\t\t\t} // Set the correct header, if data is being sent\n\n\n\t\t\tif (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n\t\t\t\tjqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n\t\t\t} // Set the Accepts header for the server, depending on the dataType\n\n\n\t\t\tjqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject(s.headers)) {\n\t\t\t\tjqXHR.setRequestHeader(i, s.headers[i]);\n\t\t\t} // Allow custom headers/mimetypes and early abort\n\n\n\t\t\tif (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {\n\t\t\t\t// Abort if not done already and return\n\t\t\t\treturn jqXHR.abort();\n\t\t\t} // Aborting is no longer a cancellation\n\n\n\t\t\tstrAbort = \"abort\"; // Install callbacks on deferreds\n\n\t\t\tfor (i in meteorBabelHelpers.sanitizeForInObject({\n\t\t\t\tsuccess: 1,\n\t\t\t\terror: 1,\n\t\t\t\tcomplete: 1\n\t\t\t})) {\n\t\t\t\tjqXHR[i](s[i]);\n\t\t\t} // Get transport\n\n\n\t\t\ttransport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n\t\t\tif (!transport) {\n\t\t\t\tdone(-1, \"No Transport\");\n\t\t\t} else {\n\t\t\t\tjqXHR.readyState = 1; // Send global event\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n\t\t\t\t} // Timeout\n\n\n\t\t\t\tif (s.async && s.timeout > 0) {\n\t\t\t\t\ttimeoutTimer = setTimeout(function () {\n\t\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t\t}, s.timeout);\n\t\t\t\t}\n\n\t\t\t\ttry {\n\t\t\t\t\tstate = 1;\n\t\t\t\t\ttransport.send(requestHeaders, done);\n\t\t\t\t} catch (e) {\n\t\t\t\t\t// Propagate exception as error if not done\n\t\t\t\t\tif (state < 2) {\n\t\t\t\t\t\tdone(-1, e); // Simply rethrow otherwise\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // Callback for when everything is done\n\n\n\t\t\tfunction done(status, nativeStatusText, responses, headers) {\n\t\t\t\tvar isSuccess,\n\t\t\t\t    success,\n\t\t\t\t    error,\n\t\t\t\t    response,\n\t\t\t\t    modified,\n\t\t\t\t    statusText = nativeStatusText; // Called once\n\n\t\t\t\tif (state === 2) {\n\t\t\t\t\treturn;\n\t\t\t\t} // State is \"done\" now\n\n\n\t\t\t\tstate = 2; // Clear timeout if it exists\n\n\t\t\t\tif (timeoutTimer) {\n\t\t\t\t\tclearTimeout(timeoutTimer);\n\t\t\t\t} // Dereference transport for early garbage collection\n\t\t\t\t// (no matter how long the jqXHR object will be used)\n\n\n\t\t\t\ttransport = undefined; // Cache response headers\n\n\t\t\t\tresponseHeadersString = headers || \"\"; // Set readyState\n\n\t\t\t\tjqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n\t\t\t\tisSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n\t\t\t\tif (responses) {\n\t\t\t\t\tresponse = ajaxHandleResponses(s, jqXHR, responses);\n\t\t\t\t} // Convert no matter what (that way responseXXX fields are always set)\n\n\n\t\t\t\tresponse = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\t\tif (s.ifModified) {\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.lastModified[cacheURL] = modified;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\n\t\t\t\t\t\tif (modified) {\n\t\t\t\t\t\t\tjQuery.etag[cacheURL] = modified;\n\t\t\t\t\t\t}\n\t\t\t\t\t} // if no content\n\n\n\t\t\t\t\tif (status === 204 || s.type === \"HEAD\") {\n\t\t\t\t\t\tstatusText = \"nocontent\"; // if not modified\n\t\t\t\t\t} else if (status === 304) {\n\t\t\t\t\t\tstatusText = \"notmodified\"; // If we have data, let's convert it\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\t\terror = response.error;\n\t\t\t\t\t\tisSuccess = !error;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\t\terror = statusText;\n\n\t\t\t\t\tif (status || !statusText) {\n\t\t\t\t\t\tstatusText = \"error\";\n\n\t\t\t\t\t\tif (status < 0) {\n\t\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // Set data for the fake xhr object\n\n\n\t\t\t\tjqXHR.status = status;\n\t\t\t\tjqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n\t\t\t\tif (isSuccess) {\n\t\t\t\t\tdeferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n\t\t\t\t} else {\n\t\t\t\t\tdeferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n\t\t\t\t} // Status-dependent callbacks\n\n\n\t\t\t\tjqXHR.statusCode(statusCode);\n\t\t\t\tstatusCode = undefined;\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n\t\t\t\t} // Complete\n\n\n\t\t\t\tcompleteDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n\t\t\t\tif (fireGlobals) {\n\t\t\t\t\tglobalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n\t\t\t\t\tif (! --jQuery.active) {\n\t\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn jqXHR;\n\t\t},\n\t\tgetJSON: function (url, data, callback) {\n\t\t\treturn jQuery.get(url, data, callback, \"json\");\n\t\t},\n\t\tgetScript: function (url, callback) {\n\t\t\treturn jQuery.get(url, undefined, callback, \"script\");\n\t\t}\n\t});\n\tjQuery.each([\"get\", \"post\"], function (i, method) {\n\t\tjQuery[method] = function (url, data, callback, type) {\n\t\t\t// Shift arguments if data argument was omitted\n\t\t\tif (jQuery.isFunction(data)) {\n\t\t\t\ttype = type || callback;\n\t\t\t\tcallback = data;\n\t\t\t\tdata = undefined;\n\t\t\t}\n\n\t\t\treturn jQuery.ajax({\n\t\t\t\turl: url,\n\t\t\t\ttype: method,\n\t\t\t\tdataType: type,\n\t\t\t\tdata: data,\n\t\t\t\tsuccess: callback\n\t\t\t});\n\t\t};\n\t});\n\treturn jQuery;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/vendor/jquery/src/ajax.js"],"names":["define","jQuery","rnotwhite","nonce","rquery","rhash","rts","rheaders","rlocalProtocol","rnoContent","rprotocol","rurl","prefilters","transports","allTypes","concat","ajaxLocation","window","location","href","ajaxLocParts","exec","toLowerCase","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","i","dataTypes","match","isFunction","slice","unshift","push","inspectPrefiltersOrTransports","options","originalOptions","jqXHR","inspected","seekingTransport","inspect","selected","each","_","prefilterOrFactory","dataTypeOrTransport","ajaxExtend","target","src","key","deep","flatOptions","ajaxSettings","undefined","extend","ajaxHandleResponses","s","responses","ct","type","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","test","converters","ajaxConvert","response","isSuccess","conv2","current","conv","tmp","prev","responseFields","dataFilter","split","e","state","error","data","active","lastModified","etag","url","isLocal","global","processData","async","contentType","accepts","text","html","xml","json","String","parseJSON","parseXML","context","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","transport","cacheURL","responseHeadersString","responseHeaders","timeoutTimer","parts","fireGlobals","callbackContext","globalEventContext","nodeType","jquery","event","deferred","Deferred","completeDeferred","Callbacks","statusCode","requestHeaders","requestHeadersNames","strAbort","readyState","getAllResponseHeaders","setRequestHeader","name","value","lname","overrideMimeType","map","code","always","status","abort","statusText","finalText","done","promise","complete","add","success","fail","replace","method","trim","crossDomain","param","traditional","trigger","toUpperCase","hasContent","cache","ifModified","headers","beforeSend","call","timeout","setTimeout","send","nativeStatusText","modified","clearTimeout","resolveWith","rejectWith","fireWith","getJSON","callback","get","getScript"],"mappings":"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","file":"packages/zurb:foundation-sites/vendor/jquery/src/ajax.js.map","sourcesContent":["define([\n\t\"./core\",\n\t\"./var/rnotwhite\",\n\t\"./ajax/var/nonce\",\n\t\"./ajax/var/rquery\",\n\t\"./core/init\",\n\t\"./ajax/parseJSON\",\n\t\"./ajax/parseXML\",\n\t\"./deferred\"\n], function( jQuery, rnotwhite, nonce, rquery ) {\n\nvar\n\trhash = /#.*$/,\n\trts = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\trurl = /^([\\w.+-]+:)(?:\\/\\/(?:[^\\/?#]*@|)([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Document location\n\tajaxLocation = window.location.href,\n\n\t// Segment location into parts\n\tajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];\n\n\t\tif ( jQuery.isFunction( func ) ) {\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( (dataType = dataTypes[i++]) ) {\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[0] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t(structure[ dataType ] = structure[ dataType ] || []).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t});\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s[ \"throws\" ] ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend({\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: ajaxLocation,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /xml/,\n\t\t\thtml: /html/,\n\t\t\tjson: /json/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": jQuery.parseJSON,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\t\t\t// Cross-domain detection vars\n\t\t\tparts,\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\t\t\t// Loop variable\n\t\t\ti,\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks(\"once memory\"),\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\t\t\t// The jqXHR state\n\t\t\tstate = 0,\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( state === 2 ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( (match = rheaders.exec( responseHeadersString )) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match;\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn state === 2 ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tvar lname = name.toLowerCase();\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\tname = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( !state ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\t// Lazy-add the new callback in a way that preserves old ones\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR ).complete = completeDeferred.add;\n\t\tjqXHR.success = jqXHR.done;\n\t\tjqXHR.error = jqXHR.fail;\n\n\t\t// Remove hash character (#7531: and string promotion)\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" )\n\t\t\t.replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( rnotwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when we have a protocol:host:port mismatch\n\t\tif ( s.crossDomain == null ) {\n\t\t\tparts = rurl.exec( s.url.toLowerCase() );\n\t\t\ts.crossDomain = !!( parts &&\n\t\t\t\t( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n\t\t\t\t\t( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n\t\t\t\t\t\t( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n\t\t\t);\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( state === 2 ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger(\"ajaxStart\");\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\tcacheURL = s.url;\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// If data is available, append data to url\n\t\t\tif ( s.data ) {\n\t\t\t\tcacheURL = ( s.url += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add anti-cache in url if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\ts.url = rts.test( cacheURL ) ?\n\n\t\t\t\t\t// If there is already a '_' parameter, set its value\n\t\t\t\t\tcacheURL.replace( rts, \"$1_=\" + nonce++ ) :\n\n\t\t\t\t\t// Otherwise add one to the end\n\t\t\t\t\tcacheURL + ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + nonce++;\n\t\t\t}\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tfor ( i in { success: 1, error: 1, complete: 1 } ) {\n\t\t\tjqXHR[ i ]( s[ i ] );\n\t\t}\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = setTimeout(function() {\n\t\t\t\t\tjqXHR.abort(\"timeout\");\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tstate = 1;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\t\t\t\t// Propagate exception as error if not done\n\t\t\t\tif ( state < 2 ) {\n\t\t\t\t\tdone( -1, e );\n\t\t\t\t// Simply rethrow otherwise\n\t\t\t\t} else {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Called once\n\t\t\tif ( state === 2 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// State is \"done\" now\n\t\t\tstate = 2;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\tclearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"Last-Modified\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader(\"etag\");\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger(\"ajaxStop\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( jQuery.isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\treturn jQuery.ajax({\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t});\n\t};\n});\n\nreturn jQuery;\n});\n"]},"hash":"d4957fb2cb6593cf8f533068286af934659e9961"}
