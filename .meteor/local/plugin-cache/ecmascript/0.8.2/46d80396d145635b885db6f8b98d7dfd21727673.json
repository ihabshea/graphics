{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js","filenameRelative":"packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js.map","sourceFileName":"packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"sizzle"},"ignored":false,"code":"/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */(function (window) {\n\tvar i,\n\t    support,\n\t    Expr,\n\t    getText,\n\t    isXML,\n\t    tokenize,\n\t    compile,\n\t    select,\n\t    outermostContext,\n\t    sortInput,\n\t    hasDuplicate,\n\t    // Local document vars\n\tsetDocument,\n\t    document,\n\t    docElem,\n\t    documentIsHTML,\n\t    rbuggyQSA,\n\t    rbuggyMatches,\n\t    matches,\n\t    contains,\n\t    // Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\t    preferredDoc = window.document,\n\t    dirruns = 0,\n\t    done = 0,\n\t    classCache = createCache(),\n\t    tokenCache = createCache(),\n\t    compilerCache = createCache(),\n\t    sortOrder = function (a, b) {\n\t\tif (a === b) {\n\t\t\thasDuplicate = true;\n\t\t}\n\n\t\treturn 0;\n\t},\n\t    // General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\t    // Instance methods\n\thasOwn = {}.hasOwnProperty,\n\t    arr = [],\n\t    pop = arr.pop,\n\t    push_native = arr.push,\n\t    push = arr.push,\n\t    slice = arr.slice,\n\t    // Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function (list, elem) {\n\t\tvar i = 0,\n\t\t    len = list.length;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (list[i] === elem) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t},\n\t    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\t    // Regular expressions\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\t    // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\t    // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace + // Operator (capture 2)\n\t\"*([*^$|!~]?=)\" + whitespace + // \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace + \"*\\\\]\",\n\t    pseudos = \":(\" + identifier + \")(?:\\\\((\" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" + // 2. simple (capture 6)\n\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" + // 3. anything else (capture 2)\n\t\".*\" + \")\\\\)|)\",\n\t    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp(whitespace + \"+\", \"g\"),\n\t    rtrim = new RegExp(\"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\"),\n\t    rcomma = new RegExp(\"^\" + whitespace + \"*,\" + whitespace + \"*\"),\n\t    rcombinators = new RegExp(\"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\"),\n\t    rattributeQuotes = new RegExp(\"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\"),\n\t    rpseudo = new RegExp(pseudos),\n\t    ridentifier = new RegExp(\"^\" + identifier + \"$\"),\n\t    matchExpr = {\n\t\t\"ID\": new RegExp(\"^#(\" + identifier + \")\"),\n\t\t\"CLASS\": new RegExp(\"^\\\\.(\" + identifier + \")\"),\n\t\t\"TAG\": new RegExp(\"^(\" + identifier + \"|[*])\"),\n\t\t\"ATTR\": new RegExp(\"^\" + attributes),\n\t\t\"PSEUDO\": new RegExp(\"^\" + pseudos),\n\t\t\"CHILD\": new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace + \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\"),\n\t\t\"bool\": new RegExp(\"^(?:\" + booleans + \")$\", \"i\"),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp(\"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\")\n\t},\n\t    rinputs = /^(?:input|select|textarea|button)$/i,\n\t    rheader = /^h\\d$/i,\n\t    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\t    // Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\t    rsibling = /[+~]/,\n\t    rescape = /'|\\\\/g,\n\t    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\"),\n\t    funescape = function (_, escaped, escapedWhitespace) {\n\t\tvar high = \"0x\" + escaped - 0x10000; // NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\n\t\treturn high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint\n\t\tString.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)\n\t\tString.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);\n\t},\n\t    // Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function () {\n\t\tsetDocument();\n\t}; // Optimize for push.apply( _, NodeList )\n\n\n\ttry {\n\t\tpush.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes); // Support: Android<4.0\n\t\t// Detect silently failing push.apply\n\n\t\tarr[preferredDoc.childNodes.length].nodeType;\n\t} catch (e) {\n\t\tpush = {\n\t\t\tapply: arr.length ? // Leverage slice if possible\n\t\t\tfunction (target, els) {\n\t\t\t\tpush_native.apply(target, slice.call(els));\n\t\t\t} : // Support: IE<9\n\t\t\t// Otherwise append directly\n\t\t\tfunction (target, els) {\n\t\t\t\tvar j = target.length,\n\t\t\t\t    i = 0; // Can't trust NodeList.length\n\n\t\t\t\twhile (target[j++] = els[i++]) {}\n\n\t\t\t\ttarget.length = j - 1;\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction Sizzle(selector, context, results, seed) {\n\t\tvar m,\n\t\t    i,\n\t\t    elem,\n\t\t    nid,\n\t\t    nidselect,\n\t\t    match,\n\t\t    groups,\n\t\t    newSelector,\n\t\t    newContext = context && context.ownerDocument,\n\t\t    // nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\t\tresults = results || []; // Return early from calls with invalid selector or context\n\n\t\tif (typeof selector !== \"string\" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {\n\t\t\treturn results;\n\t\t} // Try to shortcut find operations (as opposed to filters) in HTML documents\n\n\n\t\tif (!seed) {\n\t\t\tif ((context ? context.ownerDocument || context : preferredDoc) !== document) {\n\t\t\t\tsetDocument(context);\n\t\t\t}\n\n\t\t\tcontext = context || document;\n\n\t\t\tif (documentIsHTML) {\n\t\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\t\tif (nodeType !== 11 && (match = rquickExpr.exec(selector))) {\n\t\t\t\t\t// ID selector\n\t\t\t\t\tif (m = match[1]) {\n\t\t\t\t\t\t// Document context\n\t\t\t\t\t\tif (nodeType === 9) {\n\t\t\t\t\t\t\tif (elem = context.getElementById(m)) {\n\t\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\t\tif (elem.id === m) {\n\t\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t} // Element context\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {\n\t\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Type selector\n\n\t\t\t\t\t} else if (match[2]) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByTagName(selector));\n\t\t\t\t\t\treturn results; // Class selector\n\t\t\t\t\t} else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {\n\t\t\t\t\t\tpush.apply(results, context.getElementsByClassName(m));\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\t\t\t\t} // Take advantage of querySelectorAll\n\n\n\t\t\t\tif (support.qsa && !compilerCache[selector + \" \"] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {\n\t\t\t\t\tif (nodeType !== 1) {\n\t\t\t\t\t\tnewContext = context;\n\t\t\t\t\t\tnewSelector = selector; // qSA looks outside Element context, which is not what we want\n\t\t\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t\t\t// Support: IE <=8\n\t\t\t\t\t\t// Exclude object elements\n\t\t\t\t\t} else if (context.nodeName.toLowerCase() !== \"object\") {\n\t\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\t\tif (nid = context.getAttribute(\"id\")) {\n\t\t\t\t\t\t\tnid = nid.replace(rescape, \"\\\\$&\");\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontext.setAttribute(\"id\", nid = expando);\n\t\t\t\t\t\t} // Prefix every selector in the list\n\n\n\t\t\t\t\t\tgroups = tokenize(selector);\n\t\t\t\t\t\ti = groups.length;\n\t\t\t\t\t\tnidselect = ridentifier.test(nid) ? \"#\" + nid : \"[id='\" + nid + \"']\";\n\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tgroups[i] = nidselect + \" \" + toSelector(groups[i]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tnewSelector = groups.join(\",\"); // Expand context for sibling selectors\n\n\t\t\t\t\t\tnewContext = rsibling.test(selector) && testContext(context.parentNode) || context;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (newSelector) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tpush.apply(results, newContext.querySelectorAll(newSelector));\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t} catch (qsaError) {} finally {\n\t\t\t\t\t\t\tif (nid === expando) {\n\t\t\t\t\t\t\t\tcontext.removeAttribute(\"id\");\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // All others\n\n\n\t\treturn select(selector.replace(rtrim, \"$1\"), context, results, seed);\n\t} /**\n    * Create key-value caches of limited size\n    * @returns {function(string, object)} Returns the Object data after storing it on itself with\n    *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n    *\tdeleting the oldest entry\n    */\n\n\tfunction createCache() {\n\t\tvar keys = [];\n\n\t\tfunction cache(key, value) {\n\t\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\t\tif (keys.push(key + \" \") > Expr.cacheLength) {\n\t\t\t\t// Only keep the most recent entries\n\t\t\t\tdelete cache[keys.shift()];\n\t\t\t}\n\n\t\t\treturn cache[key + \" \"] = value;\n\t\t}\n\n\t\treturn cache;\n\t} /**\n    * Mark a function for special use by Sizzle\n    * @param {Function} fn The function to mark\n    */\n\n\tfunction markFunction(fn) {\n\t\tfn[expando] = true;\n\t\treturn fn;\n\t} /**\n    * Support testing using an element\n    * @param {Function} fn Passed the created div and expects a boolean result\n    */\n\n\tfunction assert(fn) {\n\t\tvar div = document.createElement(\"div\");\n\n\t\ttry {\n\t\t\treturn !!fn(div);\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t} finally {\n\t\t\t// Remove from its parent by default\n\t\t\tif (div.parentNode) {\n\t\t\t\tdiv.parentNode.removeChild(div);\n\t\t\t} // release memory in IE\n\n\n\t\t\tdiv = null;\n\t\t}\n\t} /**\n    * Adds the same handler for all of the specified attrs\n    * @param {String} attrs Pipe-separated list of attributes\n    * @param {Function} handler The method that will be applied\n    */\n\n\tfunction addHandle(attrs, handler) {\n\t\tvar arr = attrs.split(\"|\"),\n\t\t    i = arr.length;\n\n\t\twhile (i--) {\n\t\t\tExpr.attrHandle[arr[i]] = handler;\n\t\t}\n\t} /**\n    * Checks document order of two siblings\n    * @param {Element} a\n    * @param {Element} b\n    * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n    */\n\n\tfunction siblingCheck(a, b) {\n\t\tvar cur = b && a,\n\t\t    diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE); // Use IE sourceIndex if available on both nodes\n\n\t\tif (diff) {\n\t\t\treturn diff;\n\t\t} // Check if b follows a\n\n\n\t\tif (cur) {\n\t\t\twhile (cur = cur.nextSibling) {\n\t\t\t\tif (cur === b) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn a ? 1 : -1;\n\t} /**\n    * Returns a function to use in pseudos for input types\n    * @param {String} type\n    */\n\n\tfunction createInputPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === type;\n\t\t};\n\t} /**\n    * Returns a function to use in pseudos for buttons\n    * @param {String} type\n    */\n\n\tfunction createButtonPseudo(type) {\n\t\treturn function (elem) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t\t};\n\t} /**\n    * Returns a function to use in pseudos for positionals\n    * @param {Function} fn\n    */\n\n\tfunction createPositionalPseudo(fn) {\n\t\treturn markFunction(function (argument) {\n\t\t\targument = +argument;\n\t\t\treturn markFunction(function (seed, matches) {\n\t\t\t\tvar j,\n\t\t\t\t    matchIndexes = fn([], seed.length, argument),\n\t\t\t\t    i = matchIndexes.length; // Match elements found at the specified indexes\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (seed[j = matchIndexes[i]]) {\n\t\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t} /**\n    * Checks a node for validity as a Sizzle context\n    * @param {Element|Object=} context\n    * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n    */\n\n\tfunction testContext(context) {\n\t\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n\t} // Expose support vars for convenience\n\n\n\tsupport = Sizzle.support = {}; /**\n                                 * Detects XML nodes\n                                 * @param {Element|Object} elem An element or a document\n                                 * @returns {Boolean} True iff elem is a non-HTML XML node\n                                 */\n\n\tisXML = Sizzle.isXML = function (elem) {\n\t\t// documentElement is verified for cases where it doesn't yet exist\n\t\t// (such as loading iframes in IE - #4833)\n\t\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\t\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n\t}; /**\n     * Sets document-related variables once based on the current document\n     * @param {Element|Object} [doc] An element or document object to use to set the document\n     * @returns {Object} Returns the current document\n     */\n\n\tsetDocument = Sizzle.setDocument = function (node) {\n\t\tvar hasCompare,\n\t\t    parent,\n\t\t    doc = node ? node.ownerDocument || node : preferredDoc; // Return early if doc is invalid or already selected\n\n\t\tif (doc === document || doc.nodeType !== 9 || !doc.documentElement) {\n\t\t\treturn document;\n\t\t} // Update global variables\n\n\n\t\tdocument = doc;\n\t\tdocElem = document.documentElement;\n\t\tdocumentIsHTML = !isXML(document); // Support: IE 9-11, Edge\n\t\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\n\t\tif ((parent = document.defaultView) && parent.top !== parent) {\n\t\t\t// Support: IE 11\n\t\t\tif (parent.addEventListener) {\n\t\t\t\tparent.addEventListener(\"unload\", unloadHandler, false); // Support: IE 9 - 10 only\n\t\t\t} else if (parent.attachEvent) {\n\t\t\t\tparent.attachEvent(\"onunload\", unloadHandler);\n\t\t\t}\n\t\t} /* Attributes\n    ---------------------------------------------------------------------- */ // Support: IE<8\n\t\t// Verify that getAttribute really returns attributes and not properties\n\t\t// (excepting IE8 booleans)\n\n\n\t\tsupport.attributes = assert(function (div) {\n\t\t\tdiv.className = \"i\";\n\t\t\treturn !div.getAttribute(\"className\");\n\t\t}); /* getElement(s)By*\n      ---------------------------------------------------------------------- */ // Check if getElementsByTagName(\"*\") returns only elements\n\n\t\tsupport.getElementsByTagName = assert(function (div) {\n\t\t\tdiv.appendChild(document.createComment(\"\"));\n\t\t\treturn !div.getElementsByTagName(\"*\").length;\n\t\t}); // Support: IE<9\n\n\t\tsupport.getElementsByClassName = rnative.test(document.getElementsByClassName); // Support: IE<10\n\t\t// Check if getElementById returns elements by name\n\t\t// The broken getElementById methods don't pick up programatically-set names,\n\t\t// so use a roundabout getElementsByName test\n\n\t\tsupport.getById = assert(function (div) {\n\t\t\tdocElem.appendChild(div).id = expando;\n\t\t\treturn !document.getElementsByName || !document.getElementsByName(expando).length;\n\t\t}); // ID find and filter\n\n\t\tif (support.getById) {\n\t\t\tExpr.find[\"ID\"] = function (id, context) {\n\t\t\t\tif (typeof context.getElementById !== \"undefined\" && documentIsHTML) {\n\t\t\t\t\tvar m = context.getElementById(id);\n\t\t\t\t\treturn m ? [m] : [];\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t} else {\n\t\t\t// Support: IE6/7\n\t\t\t// getElementById is not reliable as a find shortcut\n\t\t\tdelete Expr.find[\"ID\"];\n\n\t\t\tExpr.filter[\"ID\"] = function (id) {\n\t\t\t\tvar attrId = id.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" && elem.getAttributeNode(\"id\");\n\t\t\t\t\treturn node && node.value === attrId;\n\t\t\t\t};\n\t\t\t};\n\t\t} // Tag\n\n\n\t\tExpr.find[\"TAG\"] = support.getElementsByTagName ? function (tag, context) {\n\t\t\tif (typeof context.getElementsByTagName !== \"undefined\") {\n\t\t\t\treturn context.getElementsByTagName(tag); // DocumentFragment nodes don't have gEBTN\n\t\t\t} else if (support.qsa) {\n\t\t\t\treturn context.querySelectorAll(tag);\n\t\t\t}\n\t\t} : function (tag, context) {\n\t\t\tvar elem,\n\t\t\t    tmp = [],\n\t\t\t    i = 0,\n\t\t\t    // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\tresults = context.getElementsByTagName(tag); // Filter out possible comments\n\n\t\t\tif (tag === \"*\") {\n\t\t\t\twhile (elem = results[i++]) {\n\t\t\t\t\tif (elem.nodeType === 1) {\n\t\t\t\t\t\ttmp.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\n\t\t\treturn results;\n\t\t}; // Class\n\n\t\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function (className, context) {\n\t\t\tif (typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML) {\n\t\t\t\treturn context.getElementsByClassName(className);\n\t\t\t}\n\t\t}; /* QSA/matchesSelector\n     ---------------------------------------------------------------------- */ // QSA and matchesSelector support\n\t\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\n\n\t\trbuggyMatches = []; // qSa(:focus) reports false when true (Chrome 21)\n\t\t// We allow this because of a bug in IE8/9 that throws an error\n\t\t// whenever `document.activeElement` is accessed on an iframe\n\t\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t\t// See http://bugs.jquery.com/ticket/13378\n\n\t\trbuggyQSA = [];\n\n\t\tif (support.qsa = rnative.test(document.querySelectorAll)) {\n\t\t\t// Build QSA regex\n\t\t\t// Regex strategy adopted from Diego Perini\n\t\t\tassert(function (div) {\n\t\t\t\t// Select is set to empty string on purpose\n\t\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t\t// setting a boolean content attribute,\n\t\t\t\t// since its presence should be enough\n\t\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\t\tdocElem.appendChild(div).innerHTML = \"<a id='\" + expando + \"'></a>\" + \"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" + \"<option selected=''></option></select>\"; // Support: IE8, Opera 11-12.16\n\t\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\n\t\t\t\tif (div.querySelectorAll(\"[msallowcapture^='']\").length) {\n\t\t\t\t\trbuggyQSA.push(\"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\");\n\t\t\t\t} // Support: IE8\n\t\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\n\n\t\t\t\tif (!div.querySelectorAll(\"[selected]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\");\n\t\t\t\t} // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\n\n\t\t\t\tif (!div.querySelectorAll(\"[id~=\" + expando + \"-]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t\t} // Webkit/Opera - :checked should return selected option elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\t// IE8 throws error here and will not see later tests\n\n\n\t\t\t\tif (!div.querySelectorAll(\":checked\").length) {\n\t\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t\t} // Support: Safari 8+, iOS 8+\n\t\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\n\n\t\t\t\tif (!div.querySelectorAll(\"a#\" + expando + \"+*\").length) {\n\t\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t\t}\n\t\t\t});\n\t\t\tassert(function (div) {\n\t\t\t\t// Support: Windows 8 Native Apps\n\t\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\t\tvar input = document.createElement(\"input\");\n\t\t\t\tinput.setAttribute(\"type\", \"hidden\");\n\t\t\t\tdiv.appendChild(input).setAttribute(\"name\", \"D\"); // Support: IE8\n\t\t\t\t// Enforce case-sensitivity of name attribute\n\n\t\t\t\tif (div.querySelectorAll(\"[name=d]\").length) {\n\t\t\t\t\trbuggyQSA.push(\"name\" + whitespace + \"*[*^$|!~]?=\");\n\t\t\t\t} // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t\t// IE8 throws error here and will not see later tests\n\n\n\t\t\t\tif (!div.querySelectorAll(\":enabled\").length) {\n\t\t\t\t\trbuggyQSA.push(\":enabled\", \":disabled\");\n\t\t\t\t} // Opera 10-11 does not throw on post-comma invalid pseudos\n\n\n\t\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\t\trbuggyQSA.push(\",.*:\");\n\t\t\t});\n\t\t}\n\n\t\tif (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {\n\t\t\tassert(function (div) {\n\t\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t\t// on a disconnected node (IE 9)\n\t\t\t\tsupport.disconnectedMatch = matches.call(div, \"div\"); // This should fail with an exception\n\t\t\t\t// Gecko does not error, returns false instead\n\n\t\t\t\tmatches.call(div, \"[s!='']:x\");\n\t\t\t\trbuggyMatches.push(\"!=\", pseudos);\n\t\t\t});\n\t\t}\n\n\t\trbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join(\"|\"));\n\t\trbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join(\"|\")); /* Contains\n                                                                               ---------------------------------------------------------------------- */\n\t\thasCompare = rnative.test(docElem.compareDocumentPosition); // Element contains another\n\t\t// Purposefully self-exclusive\n\t\t// As in, an element does not contain itself\n\n\t\tcontains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t    bup = b && b.parentNode;\n\t\t\treturn a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));\n\t\t} : function (a, b) {\n\t\t\tif (b) {\n\t\t\t\twhile (b = b.parentNode) {\n\t\t\t\t\tif (b === a) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}; /* Sorting\n     ---------------------------------------------------------------------- */ // Document order sorting\n\n\t\tsortOrder = hasCompare ? function (a, b) {\n\t\t\t// Flag for duplicate removal\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t} // Sort on method existence if only one input has compareDocumentPosition\n\n\n\t\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\n\t\t\tif (compare) {\n\t\t\t\treturn compare;\n\t\t\t} // Calculate position if both inputs belong to the same document\n\n\n\t\t\tcompare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : // Otherwise we know they are disconnected\n\t\t\t1; // Disconnected nodes\n\n\t\t\tif (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {\n\t\t\t\t// Choose the first element that is related to our preferred document\n\t\t\t\tif (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\n\t\t\t\tif (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} // Maintain original order\n\n\n\t\t\t\treturn sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;\n\t\t\t}\n\n\t\t\treturn compare & 4 ? -1 : 1;\n\t\t} : function (a, b) {\n\t\t\t// Exit early if the nodes are identical\n\t\t\tif (a === b) {\n\t\t\t\thasDuplicate = true;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar cur,\n\t\t\t    i = 0,\n\t\t\t    aup = a.parentNode,\n\t\t\t    bup = b.parentNode,\n\t\t\t    ap = [a],\n\t\t\t    bp = [b]; // Parentless nodes are either documents or disconnected\n\n\t\t\tif (!aup || !bup) {\n\t\t\t\treturn a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0; // If the nodes are siblings, we can do a quick check\n\t\t\t} else if (aup === bup) {\n\t\t\t\treturn siblingCheck(a, b);\n\t\t\t} // Otherwise we need full lists of their ancestors for comparison\n\n\n\t\t\tcur = a;\n\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tap.unshift(cur);\n\t\t\t}\n\n\t\t\tcur = b;\n\n\t\t\twhile (cur = cur.parentNode) {\n\t\t\t\tbp.unshift(cur);\n\t\t\t} // Walk down the tree looking for a discrepancy\n\n\n\t\t\twhile (ap[i] === bp[i]) {\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\treturn i ? // Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck(ap[i], bp[i]) : // Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;\n\t\t};\n\t\treturn document;\n\t};\n\n\tSizzle.matches = function (expr, elements) {\n\t\treturn Sizzle(expr, null, null, elements);\n\t};\n\n\tSizzle.matchesSelector = function (elem, expr) {\n\t\t// Set document vars if needed\n\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\tsetDocument(elem);\n\t\t} // Make sure that attribute selectors are quoted\n\n\n\t\texpr = expr.replace(rattributeQuotes, \"='$1']\");\n\n\t\tif (support.matchesSelector && documentIsHTML && !compilerCache[expr + \" \"] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {\n\t\t\ttry {\n\t\t\t\tvar ret = matches.call(elem, expr); // IE 9's matchesSelector returns false on disconnected nodes\n\n\t\t\t\tif (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document\n\t\t\t\t// fragment in IE 9\n\t\t\t\telem.document && elem.document.nodeType !== 11) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t} catch (e) {}\n\t\t}\n\n\t\treturn Sizzle(expr, document, null, [elem]).length > 0;\n\t};\n\n\tSizzle.contains = function (context, elem) {\n\t\t// Set document vars if needed\n\t\tif ((context.ownerDocument || context) !== document) {\n\t\t\tsetDocument(context);\n\t\t}\n\n\t\treturn contains(context, elem);\n\t};\n\n\tSizzle.attr = function (elem, name) {\n\t\t// Set document vars if needed\n\t\tif ((elem.ownerDocument || elem) !== document) {\n\t\t\tsetDocument(elem);\n\t\t}\n\n\t\tvar fn = Expr.attrHandle[name.toLowerCase()],\n\t\t    // Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;\n\t\treturn val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t};\n\n\tSizzle.error = function (msg) {\n\t\tthrow new Error(\"Syntax error, unrecognized expression: \" + msg);\n\t}; /**\n     * Document sorting and removing duplicates\n     * @param {ArrayLike} results\n     */\n\n\tSizzle.uniqueSort = function (results) {\n\t\tvar elem,\n\t\t    duplicates = [],\n\t\t    j = 0,\n\t\t    i = 0; // Unless we *know* we can detect duplicates, assume their presence\n\n\t\thasDuplicate = !support.detectDuplicates;\n\t\tsortInput = !support.sortStable && results.slice(0);\n\t\tresults.sort(sortOrder);\n\n\t\tif (hasDuplicate) {\n\t\t\twhile (elem = results[i++]) {\n\t\t\t\tif (elem === results[i]) {\n\t\t\t\t\tj = duplicates.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (j--) {\n\t\t\t\tresults.splice(duplicates[j], 1);\n\t\t\t}\n\t\t} // Clear input after sorting to release objects\n\t\t// See https://github.com/jquery/sizzle/pull/225\n\n\n\t\tsortInput = null;\n\t\treturn results;\n\t}; /**\n     * Utility function for retrieving the text value of an array of DOM nodes\n     * @param {Array|Element} elem\n     */\n\n\tgetText = Sizzle.getText = function (elem) {\n\t\tvar node,\n\t\t    ret = \"\",\n\t\t    i = 0,\n\t\t    nodeType = elem.nodeType;\n\n\t\tif (!nodeType) {\n\t\t\t// If no nodeType, this is expected to be an array\n\t\t\twhile (node = elem[i++]) {\n\t\t\t\t// Do not traverse comment nodes\n\t\t\t\tret += getText(node);\n\t\t\t}\n\t\t} else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {\n\t\t\t// Use textContent for elements\n\t\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\t\tif (typeof elem.textContent === \"string\") {\n\t\t\t\treturn elem.textContent;\n\t\t\t} else {\n\t\t\t\t// Traverse its children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tret += getText(elem);\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 3 || nodeType === 4) {\n\t\t\treturn elem.nodeValue;\n\t\t} // Do not include comment or processing instruction nodes\n\n\n\t\treturn ret;\n\t};\n\n\tExpr = Sizzle.selectors = {\n\t\t// Can be adjusted by the user\n\t\tcacheLength: 50,\n\t\tcreatePseudo: markFunction,\n\t\tmatch: matchExpr,\n\t\tattrHandle: {},\n\t\tfind: {},\n\t\trelative: {\n\t\t\t\">\": {\n\t\t\t\tdir: \"parentNode\",\n\t\t\t\tfirst: true\n\t\t\t},\n\t\t\t\" \": {\n\t\t\t\tdir: \"parentNode\"\n\t\t\t},\n\t\t\t\"+\": {\n\t\t\t\tdir: \"previousSibling\",\n\t\t\t\tfirst: true\n\t\t\t},\n\t\t\t\"~\": {\n\t\t\t\tdir: \"previousSibling\"\n\t\t\t}\n\t\t},\n\t\tpreFilter: {\n\t\t\t\"ATTR\": function (match) {\n\t\t\t\tmatch[1] = match[1].replace(runescape, funescape); // Move the given value to match[3] whether quoted or unquoted\n\n\t\t\t\tmatch[3] = (match[3] || match[4] || match[5] || \"\").replace(runescape, funescape);\n\n\t\t\t\tif (match[2] === \"~=\") {\n\t\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t\t}\n\n\t\t\t\treturn match.slice(0, 4);\n\t\t\t},\n\t\t\t\"CHILD\": function (match) {\n\t\t\t\t/* matches from matchExpr[\"CHILD\"]\n    \t1 type (only|nth|...)\n    \t2 what (child|of-type)\n    \t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n    \t4 xn-component of xn+y argument ([+-]?\\d*n|)\n    \t5 sign of xn-component\n    \t6 x of xn-component\n    \t7 sign of y-component\n    \t8 y of y-component\n    */match[1] = match[1].toLowerCase();\n\n\t\t\t\tif (match[1].slice(0, 3) === \"nth\") {\n\t\t\t\t\t// nth-* requires argument\n\t\t\t\t\tif (!match[3]) {\n\t\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t\t} // numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t\t// remember that false/true cast respectively to 0/1\n\n\n\t\t\t\t\tmatch[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === \"even\" || match[3] === \"odd\"));\n\t\t\t\t\tmatch[5] = +(match[7] + match[8] || match[3] === \"odd\"); // other types prohibit arguments\n\t\t\t\t} else if (match[3]) {\n\t\t\t\t\tSizzle.error(match[0]);\n\t\t\t\t}\n\n\t\t\t\treturn match;\n\t\t\t},\n\t\t\t\"PSEUDO\": function (match) {\n\t\t\t\tvar excess,\n\t\t\t\t    unquoted = !match[6] && match[2];\n\n\t\t\t\tif (matchExpr[\"CHILD\"].test(match[0])) {\n\t\t\t\t\treturn null;\n\t\t\t\t} // Accept quoted arguments as-is\n\n\n\t\t\t\tif (match[3]) {\n\t\t\t\t\tmatch[2] = match[4] || match[5] || \"\"; // Strip excess characters from unquoted arguments\n\t\t\t\t} else if (unquoted && rpseudo.test(unquoted) && ( // Get excess from tokenize (recursively)\n\t\t\t\texcess = tokenize(unquoted, true)) && ( // advance to the next closing parenthesis\n\t\t\t\texcess = unquoted.indexOf(\")\", unquoted.length - excess) - unquoted.length)) {\n\t\t\t\t\t// excess is a negative index\n\t\t\t\t\tmatch[0] = match[0].slice(0, excess);\n\t\t\t\t\tmatch[2] = unquoted.slice(0, excess);\n\t\t\t\t} // Return only captures needed by the pseudo filter method (type and argument)\n\n\n\t\t\t\treturn match.slice(0, 3);\n\t\t\t}\n\t\t},\n\t\tfilter: {\n\t\t\t\"TAG\": function (nodeNameSelector) {\n\t\t\t\tvar nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn nodeNameSelector === \"*\" ? function () {\n\t\t\t\t\treturn true;\n\t\t\t\t} : function (elem) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t\t},\n\t\t\t\"CLASS\": function (className) {\n\t\t\t\tvar pattern = classCache[className + \" \"];\n\t\t\t\treturn pattern || (pattern = new RegExp(\"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\")) && classCache(className, function (elem) {\n\t\t\t\t\treturn pattern.test(typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\");\n\t\t\t\t});\n\t\t\t},\n\t\t\t\"ATTR\": function (name, operator, check) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar result = Sizzle.attr(elem, name);\n\n\t\t\t\t\tif (result == null) {\n\t\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!operator) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult += \"\";\n\t\t\t\t\treturn operator === \"=\" ? result === check : operator === \"!=\" ? result !== check : operator === \"^=\" ? check && result.indexOf(check) === 0 : operator === \"*=\" ? check && result.indexOf(check) > -1 : operator === \"$=\" ? check && result.slice(-check.length) === check : operator === \"~=\" ? (\" \" + result.replace(rwhitespace, \" \") + \" \").indexOf(check) > -1 : operator === \"|=\" ? result === check || result.slice(0, check.length + 1) === check + \"-\" : false;\n\t\t\t\t};\n\t\t\t},\n\t\t\t\"CHILD\": function (type, what, argument, first, last) {\n\t\t\t\tvar simple = type.slice(0, 3) !== \"nth\",\n\t\t\t\t    forward = type.slice(-4) !== \"last\",\n\t\t\t\t    ofType = what === \"of-type\";\n\t\t\t\treturn first === 1 && last === 0 ? // Shortcut for :nth-*(n)\n\t\t\t\tfunction (elem) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} : function (elem, context, xml) {\n\t\t\t\t\tvar cache,\n\t\t\t\t\t    uniqueCache,\n\t\t\t\t\t    outerCache,\n\t\t\t\t\t    node,\n\t\t\t\t\t    nodeIndex,\n\t\t\t\t\t    start,\n\t\t\t\t\t    dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t    parent = elem.parentNode,\n\t\t\t\t\t    name = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t    useCache = !xml && !ofType,\n\t\t\t\t\t    diff = false;\n\n\t\t\t\t\tif (parent) {\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif (simple) {\n\t\t\t\t\t\t\twhile (dir) {\n\t\t\t\t\t\t\t\tnode = elem;\n\n\t\t\t\t\t\t\t\twhile (node = node[dir]) {\n\t\t\t\t\t\t\t\t\tif (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // Reverse direction for :only-* (if we haven't yet done so)\n\n\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [forward ? parent.firstChild : parent.lastChild]; // non-xml :nth-child(...) stores cache data on `parent`\n\n\t\t\t\t\t\tif (forward && useCache) {\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\n\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[2];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[nodeIndex];\n\n\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || ( // Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\tdiff = nodeIndex = 0) || start.pop()) {\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif (node.nodeType === 1 && ++diff && node === elem) {\n\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, nodeIndex, diff];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\t\t\t\t\t\t\t\tcache = uniqueCache[type] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[0] === dirruns && cache[1];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t} // xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\n\n\t\t\t\t\t\t\tif (diff === false) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {\n\t\t\t\t\t\t\t\t\tif ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif (useCache) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[expando] || (node[expando] = {}); // Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[type] = [dirruns, diff];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (node === elem) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // Incorporate the offset, then check against cycle size\n\n\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || diff % first === 0 && diff / first >= 0;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t\"PSEUDO\": function (pseudo, argument) {\n\t\t\t\t// pseudo-class names are case-insensitive\n\t\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\t\tvar args,\n\t\t\t\t    fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error(\"unsupported pseudo: \" + pseudo); // The user may use createPseudo to indicate that\n\t\t\t\t// arguments are needed to create the filter function\n\t\t\t\t// just as Sizzle does\n\n\t\t\t\tif (fn[expando]) {\n\t\t\t\t\treturn fn(argument);\n\t\t\t\t} // But maintain support for old signatures\n\n\n\t\t\t\tif (fn.length > 1) {\n\t\t\t\t\targs = [pseudo, pseudo, \"\", argument];\n\t\t\t\t\treturn Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t    matched = fn(seed, argument),\n\t\t\t\t\t\t    i = matched.length;\n\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tidx = indexOf(seed, matched[i]);\n\t\t\t\t\t\t\tseed[idx] = !(matches[idx] = matched[i]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}) : function (elem) {\n\t\t\t\t\t\treturn fn(elem, 0, args);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn fn;\n\t\t\t}\n\t\t},\n\t\tpseudos: {\n\t\t\t// Potentially complex pseudos\n\t\t\t\"not\": markFunction(function (selector) {\n\t\t\t\t// Trim the selector passed to compile\n\t\t\t\t// to avoid treating leading and trailing\n\t\t\t\t// spaces as combinators\n\t\t\t\tvar input = [],\n\t\t\t\t    results = [],\n\t\t\t\t    matcher = compile(selector.replace(rtrim, \"$1\"));\n\t\t\t\treturn matcher[expando] ? markFunction(function (seed, matches, context, xml) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t    unmatched = matcher(seed, null, xml, []),\n\t\t\t\t\t    i = seed.length; // Match elements unmatched by `matcher`\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif (elem = unmatched[i]) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) : function (elem, context, xml) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher(input, null, xml, results); // Don't keep the element (issue #299)\n\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t\t}),\n\t\t\t\"has\": markFunction(function (selector) {\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn Sizzle(selector, elem).length > 0;\n\t\t\t\t};\n\t\t\t}),\n\t\t\t\"contains\": markFunction(function (text) {\n\t\t\t\ttext = text.replace(runescape, funescape);\n\t\t\t\treturn function (elem) {\n\t\t\t\t\treturn (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;\n\t\t\t\t};\n\t\t\t}),\n\t\t\t// \"Whether an element is represented by a :lang() selector\n\t\t\t// is based solely on the element's language value\n\t\t\t// being equal to the identifier C,\n\t\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t\t// The identifier C does not have to be a valid language name.\"\n\t\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\t\"lang\": markFunction(function (lang) {\n\t\t\t\t// lang value must be a valid identifier\n\t\t\t\tif (!ridentifier.test(lang || \"\")) {\n\t\t\t\t\tSizzle.error(\"unsupported lang: \" + lang);\n\t\t\t\t}\n\n\t\t\t\tlang = lang.replace(runescape, funescape).toLowerCase();\n\t\t\t\treturn function (elem) {\n\t\t\t\t\tvar elemLang;\n\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (elemLang = documentIsHTML ? elem.lang : elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) {\n\t\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf(lang + \"-\") === 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while ((elem = elem.parentNode) && elem.nodeType === 1);\n\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\t\t\t}),\n\t\t\t// Miscellaneous\n\t\t\t\"target\": function (elem) {\n\t\t\t\tvar hash = window.location && window.location.hash;\n\t\t\t\treturn hash && hash.slice(1) === elem.id;\n\t\t\t},\n\t\t\t\"root\": function (elem) {\n\t\t\t\treturn elem === docElem;\n\t\t\t},\n\t\t\t\"focus\": function (elem) {\n\t\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t\t},\n\t\t\t// Boolean properties\n\t\t\t\"enabled\": function (elem) {\n\t\t\t\treturn elem.disabled === false;\n\t\t\t},\n\t\t\t\"disabled\": function (elem) {\n\t\t\t\treturn elem.disabled === true;\n\t\t\t},\n\t\t\t\"checked\": function (elem) {\n\t\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\t\treturn nodeName === \"input\" && !!elem.checked || nodeName === \"option\" && !!elem.selected;\n\t\t\t},\n\t\t\t\"selected\": function (elem) {\n\t\t\t\t// Accessing this property makes selected-by-default\n\t\t\t\t// options in Safari work properly\n\t\t\t\tif (elem.parentNode) {\n\t\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t\t}\n\n\t\t\t\treturn elem.selected === true;\n\t\t\t},\n\t\t\t// Contents\n\t\t\t\"empty\": function (elem) {\n\t\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\t\tfor (elem = elem.firstChild; elem; elem = elem.nextSibling) {\n\t\t\t\t\tif (elem.nodeType < 6) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t},\n\t\t\t\"parent\": function (elem) {\n\t\t\t\treturn !Expr.pseudos[\"empty\"](elem);\n\t\t\t},\n\t\t\t// Element/input types\n\t\t\t\"header\": function (elem) {\n\t\t\t\treturn rheader.test(elem.nodeName);\n\t\t\t},\n\t\t\t\"input\": function (elem) {\n\t\t\t\treturn rinputs.test(elem.nodeName);\n\t\t\t},\n\t\t\t\"button\": function (elem) {\n\t\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t\t},\n\t\t\t\"text\": function (elem) {\n\t\t\t\tvar attr;\n\t\t\t\treturn elem.nodeName.toLowerCase() === \"input\" && elem.type === \"text\" && ( // Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t(attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\");\n\t\t\t},\n\t\t\t// Position-in-collection\n\t\t\t\"first\": createPositionalPseudo(function () {\n\t\t\t\treturn [0];\n\t\t\t}),\n\t\t\t\"last\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\treturn [length - 1];\n\t\t\t}),\n\t\t\t\"eq\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\treturn [argument < 0 ? argument + length : argument];\n\t\t\t}),\n\t\t\t\"even\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 0;\n\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\t\t\"odd\": createPositionalPseudo(function (matchIndexes, length) {\n\t\t\t\tvar i = 1;\n\n\t\t\t\tfor (; i < length; i += 2) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\t\t\"lt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\n\t\t\t\tfor (; --i >= 0;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\n\t\t\t\treturn matchIndexes;\n\t\t\t}),\n\t\t\t\"gt\": createPositionalPseudo(function (matchIndexes, length, argument) {\n\t\t\t\tvar i = argument < 0 ? argument + length : argument;\n\n\t\t\t\tfor (; ++i < length;) {\n\t\t\t\t\tmatchIndexes.push(i);\n\t\t\t\t}\n\n\t\t\t\treturn matchIndexes;\n\t\t\t})\n\t\t}\n\t};\n\tExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"]; // Add button/input type pseudos\n\n\tfor (i in meteorBabelHelpers.sanitizeForInObject({\n\t\tradio: true,\n\t\tcheckbox: true,\n\t\tfile: true,\n\t\tpassword: true,\n\t\timage: true\n\t})) {\n\t\tExpr.pseudos[i] = createInputPseudo(i);\n\t}\n\n\tfor (i in meteorBabelHelpers.sanitizeForInObject({\n\t\tsubmit: true,\n\t\treset: true\n\t})) {\n\t\tExpr.pseudos[i] = createButtonPseudo(i);\n\t} // Easy API for creating new setFilters\n\n\n\tfunction setFilters() {}\n\n\tsetFilters.prototype = Expr.filters = Expr.pseudos;\n\tExpr.setFilters = new setFilters();\n\n\ttokenize = Sizzle.tokenize = function (selector, parseOnly) {\n\t\tvar matched,\n\t\t    match,\n\t\t    tokens,\n\t\t    type,\n\t\t    soFar,\n\t\t    groups,\n\t\t    preFilters,\n\t\t    cached = tokenCache[selector + \" \"];\n\n\t\tif (cached) {\n\t\t\treturn parseOnly ? 0 : cached.slice(0);\n\t\t}\n\n\t\tsoFar = selector;\n\t\tgroups = [];\n\t\tpreFilters = Expr.preFilter;\n\n\t\twhile (soFar) {\n\t\t\t// Comma and first run\n\t\t\tif (!matched || (match = rcomma.exec(soFar))) {\n\t\t\t\tif (match) {\n\t\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\t\tsoFar = soFar.slice(match[0].length) || soFar;\n\t\t\t\t}\n\n\t\t\t\tgroups.push(tokens = []);\n\t\t\t}\n\n\t\t\tmatched = false; // Combinators\n\n\t\t\tif (match = rcombinators.exec(soFar)) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\t// Cast descendant combinators to space\n\t\t\t\t\ttype: match[0].replace(rtrim, \" \")\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t} // Filters\n\n\n\t\t\tfor (type in meteorBabelHelpers.sanitizeForInObject(Expr.filter)) {\n\t\t\t\tif ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {\n\t\t\t\t\tmatched = match.shift();\n\t\t\t\t\ttokens.push({\n\t\t\t\t\t\tvalue: matched,\n\t\t\t\t\t\ttype: type,\n\t\t\t\t\t\tmatches: match\n\t\t\t\t\t});\n\t\t\t\t\tsoFar = soFar.slice(matched.length);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!matched) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} // Return the length of the invalid excess\n\t\t// if we're just parsing\n\t\t// Otherwise, throw an error or return tokens\n\n\n\t\treturn parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens\n\t\ttokenCache(selector, groups).slice(0);\n\t};\n\n\tfunction toSelector(tokens) {\n\t\tvar i = 0,\n\t\t    len = tokens.length,\n\t\t    selector = \"\";\n\n\t\tfor (; i < len; i++) {\n\t\t\tselector += tokens[i].value;\n\t\t}\n\n\t\treturn selector;\n\t}\n\n\tfunction addCombinator(matcher, combinator, base) {\n\t\tvar dir = combinator.dir,\n\t\t    checkNonElements = base && dir === \"parentNode\",\n\t\t    doneName = done++;\n\t\treturn combinator.first ? // Check against closest ancestor/preceding element\n\t\tfunction (elem, context, xml) {\n\t\t\twhile (elem = elem[dir]) {\n\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\treturn matcher(elem, context, xml);\n\t\t\t\t}\n\t\t\t}\n\t\t} : // Check against all ancestor/preceding elements\n\t\tfunction (elem, context, xml) {\n\t\t\tvar oldCache,\n\t\t\t    uniqueCache,\n\t\t\t    outerCache,\n\t\t\t    newCache = [dirruns, doneName]; // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\n\t\t\tif (xml) {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\tif (matcher(elem, context, xml)) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile (elem = elem[dir]) {\n\t\t\t\t\tif (elem.nodeType === 1 || checkNonElements) {\n\t\t\t\t\t\touterCache = elem[expando] || (elem[expando] = {}); // Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\n\t\t\t\t\t\tuniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});\n\n\t\t\t\t\t\tif ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn newCache[2] = oldCache[2];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[dir] = newCache; // A match means we're done; a fail means we have to keep checking\n\n\t\t\t\t\t\t\tif (newCache[2] = matcher(elem, context, xml)) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}\n\n\tfunction elementMatcher(matchers) {\n\t\treturn matchers.length > 1 ? function (elem, context, xml) {\n\t\t\tvar i = matchers.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tif (!matchers[i](elem, context, xml)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} : matchers[0];\n\t}\n\n\tfunction multipleContexts(selector, contexts, results) {\n\t\tvar i = 0,\n\t\t    len = contexts.length;\n\n\t\tfor (; i < len; i++) {\n\t\t\tSizzle(selector, contexts[i], results);\n\t\t}\n\n\t\treturn results;\n\t}\n\n\tfunction condense(unmatched, map, filter, context, xml) {\n\t\tvar elem,\n\t\t    newUnmatched = [],\n\t\t    i = 0,\n\t\t    len = unmatched.length,\n\t\t    mapped = map != null;\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (elem = unmatched[i]) {\n\t\t\t\tif (!filter || filter(elem, context, xml)) {\n\t\t\t\t\tnewUnmatched.push(elem);\n\n\t\t\t\t\tif (mapped) {\n\t\t\t\t\t\tmap.push(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn newUnmatched;\n\t}\n\n\tfunction setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {\n\t\tif (postFilter && !postFilter[expando]) {\n\t\t\tpostFilter = setMatcher(postFilter);\n\t\t}\n\n\t\tif (postFinder && !postFinder[expando]) {\n\t\t\tpostFinder = setMatcher(postFinder, postSelector);\n\t\t}\n\n\t\treturn markFunction(function (seed, results, context, xml) {\n\t\t\tvar temp,\n\t\t\t    i,\n\t\t\t    elem,\n\t\t\t    preMap = [],\n\t\t\t    postMap = [],\n\t\t\t    preexisting = results.length,\n\t\t\t    // Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts(selector || \"*\", context.nodeType ? [context] : context, []),\n\t\t\t    // Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,\n\t\t\t    matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\tpostFinder || (seed ? preFilter : preexisting || postFilter) ? // ...intermediate processing is necessary\n\t\t\t[] : // ...otherwise use results directly\n\t\t\tresults : matcherIn; // Find primary matches\n\n\t\t\tif (matcher) {\n\t\t\t\tmatcher(matcherIn, matcherOut, context, xml);\n\t\t\t} // Apply postFilter\n\n\n\t\t\tif (postFilter) {\n\t\t\t\ttemp = condense(matcherOut, postMap);\n\t\t\t\tpostFilter(temp, [], context, xml); // Un-match failing elements by moving them back to matcherIn\n\n\t\t\t\ti = temp.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tif (elem = temp[i]) {\n\t\t\t\t\t\tmatcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (seed) {\n\t\t\t\tif (postFinder || preFilter) {\n\t\t\t\t\tif (postFinder) {\n\t\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\t\ttemp = [];\n\t\t\t\t\t\ti = matcherOut.length;\n\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (elem = matcherOut[i]) {\n\t\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\t\ttemp.push(matcherIn[i] = elem);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpostFinder(null, matcherOut = [], temp, xml);\n\t\t\t\t\t} // Move matched elements from seed to results to keep them synchronized\n\n\n\t\t\t\t\ti = matcherOut.length;\n\n\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\tif ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {\n\t\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} // Add elements to results, through postFinder if defined\n\n\t\t\t} else {\n\t\t\t\tmatcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);\n\n\t\t\t\tif (postFinder) {\n\t\t\t\t\tpostFinder(null, results, matcherOut, xml);\n\t\t\t\t} else {\n\t\t\t\t\tpush.apply(results, matcherOut);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tfunction matcherFromTokens(tokens) {\n\t\tvar checkContext,\n\t\t    matcher,\n\t\t    j,\n\t\t    len = tokens.length,\n\t\t    leadingRelative = Expr.relative[tokens[0].type],\n\t\t    implicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\t    i = leadingRelative ? 1 : 0,\n\t\t    // The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator(function (elem) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true),\n\t\t    matchAnyContext = addCombinator(function (elem) {\n\t\t\treturn indexOf(checkContext, elem) > -1;\n\t\t}, implicitRelative, true),\n\t\t    matchers = [function (elem, context, xml) {\n\t\t\tvar ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml)); // Avoid hanging onto element (issue #299)\n\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t}];\n\n\t\tfor (; i < len; i++) {\n\t\t\tif (matcher = Expr.relative[tokens[i].type]) {\n\t\t\t\tmatchers = [addCombinator(elementMatcher(matchers), matcher)];\n\t\t\t} else {\n\t\t\t\tmatcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches); // Return special upon seeing a positional matcher\n\n\t\t\t\tif (matcher[expando]) {\n\t\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\t\tj = ++i;\n\n\t\t\t\t\tfor (; j < len; j++) {\n\t\t\t\t\t\tif (Expr.relative[tokens[j].type]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector( // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\ttokens.slice(0, i - 1).concat({\n\t\t\t\t\t\tvalue: tokens[i - 2].type === \" \" ? \"*\" : \"\"\n\t\t\t\t\t})).replace(rtrim, \"$1\"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));\n\t\t\t\t}\n\n\t\t\t\tmatchers.push(matcher);\n\t\t\t}\n\t\t}\n\n\t\treturn elementMatcher(matchers);\n\t}\n\n\tfunction matcherFromGroupMatchers(elementMatchers, setMatchers) {\n\t\tvar bySet = setMatchers.length > 0,\n\t\t    byElement = elementMatchers.length > 0,\n\t\t    superMatcher = function (seed, context, xml, results, outermost) {\n\t\t\tvar elem,\n\t\t\t    j,\n\t\t\t    matcher,\n\t\t\t    matchedCount = 0,\n\t\t\t    i = \"0\",\n\t\t\t    unmatched = seed && [],\n\t\t\t    setMatched = [],\n\t\t\t    contextBackup = outermostContext,\n\t\t\t    // We must always have either seed elements or outermost context\n\t\t\telems = seed || byElement && Expr.find[\"TAG\"](\"*\", outermost),\n\t\t\t    // Use integer dirruns iff this is the outermost matcher\n\t\t\tdirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1,\n\t\t\t    len = elems.length;\n\n\t\t\tif (outermost) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t} // Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\n\n\t\t\tfor (; i !== len && (elem = elems[i]) != null; i++) {\n\t\t\t\tif (byElement && elem) {\n\t\t\t\t\tj = 0;\n\n\t\t\t\t\tif (!context && elem.ownerDocument !== document) {\n\t\t\t\t\t\tsetDocument(elem);\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (matcher = elementMatchers[j++]) {\n\t\t\t\t\t\tif (matcher(elem, context || document, xml)) {\n\t\t\t\t\t\t\tresults.push(elem);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (outermost) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t} // Track unmatched elements for set filters\n\n\n\t\t\t\tif (bySet) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif (elem = !matcher && elem) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t} // Lengthen the array for every element, matched or not\n\n\n\t\t\t\t\tif (seed) {\n\t\t\t\t\t\tunmatched.push(elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\n\n\t\t\tmatchedCount += i; // Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\n\t\t\tif (bySet && i !== matchedCount) {\n\t\t\t\tj = 0;\n\n\t\t\t\twhile (matcher = setMatchers[j++]) {\n\t\t\t\t\tmatcher(unmatched, setMatched, context, xml);\n\t\t\t\t}\n\n\t\t\t\tif (seed) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif (matchedCount > 0) {\n\t\t\t\t\t\twhile (i--) {\n\t\t\t\t\t\t\tif (!(unmatched[i] || setMatched[i])) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call(results);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} // Discard index placeholder values to get only actual matches\n\n\n\t\t\t\t\tsetMatched = condense(setMatched);\n\t\t\t\t} // Add matches to results\n\n\n\t\t\t\tpush.apply(results, setMatched); // Seedless set matches succeeding multiple successful matchers stipulate sorting\n\n\t\t\t\tif (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {\n\t\t\t\t\tSizzle.uniqueSort(results);\n\t\t\t\t}\n\t\t\t} // Override manipulation of globals by nested matchers\n\n\n\t\t\tif (outermost) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\t\treturn bySet ? markFunction(superMatcher) : superMatcher;\n\t}\n\n\tcompile = Sizzle.compile = function (selector, match /* Internal Use Only */) {\n\t\tvar i,\n\t\t    setMatchers = [],\n\t\t    elementMatchers = [],\n\t\t    cached = compilerCache[selector + \" \"];\n\n\t\tif (!cached) {\n\t\t\t// Generate a function of recursive functions that can be used to check each element\n\t\t\tif (!match) {\n\t\t\t\tmatch = tokenize(selector);\n\t\t\t}\n\n\t\t\ti = match.length;\n\n\t\t\twhile (i--) {\n\t\t\t\tcached = matcherFromTokens(match[i]);\n\n\t\t\t\tif (cached[expando]) {\n\t\t\t\t\tsetMatchers.push(cached);\n\t\t\t\t} else {\n\t\t\t\t\telementMatchers.push(cached);\n\t\t\t\t}\n\t\t\t} // Cache the compiled function\n\n\n\t\t\tcached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)); // Save selector and tokenization\n\n\t\t\tcached.selector = selector;\n\t\t}\n\n\t\treturn cached;\n\t}; /**\n     * A low-level selection function that works with Sizzle's compiled\n     *  selector functions\n     * @param {String|Function} selector A selector or a pre-compiled\n     *  selector function built with Sizzle.compile\n     * @param {Element} context\n     * @param {Array} [results]\n     * @param {Array} [seed] A set of elements to match against\n     */\n\n\tselect = Sizzle.select = function (selector, context, results, seed) {\n\t\tvar i,\n\t\t    tokens,\n\t\t    token,\n\t\t    type,\n\t\t    find,\n\t\t    compiled = typeof selector === \"function\" && selector,\n\t\t    match = !seed && tokenize(selector = compiled.selector || selector);\n\t\tresults = results || []; // Try to minimize operations if there is only one selector in the list and no seed\n\t\t// (the latter of which guarantees us context)\n\n\t\tif (match.length === 1) {\n\t\t\t// Reduce context if the leading compound selector is an ID\n\t\t\ttokens = match[0] = match[0].slice(0);\n\n\t\t\tif (tokens.length > 2 && (token = tokens[0]).type === \"ID\" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {\n\t\t\t\tcontext = (Expr.find[\"ID\"](token.matches[0].replace(runescape, funescape), context) || [])[0];\n\n\t\t\t\tif (!context) {\n\t\t\t\t\treturn results; // Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t\t} else if (compiled) {\n\t\t\t\t\tcontext = context.parentNode;\n\t\t\t\t}\n\n\t\t\t\tselector = selector.slice(tokens.shift().value.length);\n\t\t\t} // Fetch a seed set for right-to-left matching\n\n\n\t\t\ti = matchExpr[\"needsContext\"].test(selector) ? 0 : tokens.length;\n\n\t\t\twhile (i--) {\n\t\t\t\ttoken = tokens[i]; // Abort if we hit a combinator\n\n\t\t\t\tif (Expr.relative[type = token.type]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (find = Expr.find[type]) {\n\t\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\t\tif (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {\n\t\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\t\ttokens.splice(i, 1);\n\t\t\t\t\t\tselector = seed.length && toSelector(tokens);\n\n\t\t\t\t\t\tif (!selector) {\n\t\t\t\t\t\t\tpush.apply(results, seed);\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} // Compile and execute a filtering function if one is not provided\n\t\t// Provide `match` to avoid retokenization if we modified the selector above\n\n\n\t\t(compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);\n\t\treturn results;\n\t}; // One-time assignments\n\t// Sort stability\n\n\n\tsupport.sortStable = expando.split(\"\").sort(sortOrder).join(\"\") === expando; // Support: Chrome 14-35+\n\t// Always assume duplicates if they aren't passed to the comparison function\n\n\tsupport.detectDuplicates = !!hasDuplicate; // Initialize against the default document\n\n\tsetDocument(); // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n\t// Detached nodes confoundingly follow *each other*\n\n\tsupport.sortDetached = assert(function (div1) {\n\t\t// Should return 1, but returns 4 (following)\n\t\treturn div1.compareDocumentPosition(document.createElement(\"div\")) & 1;\n\t}); // Support: IE<8\n\t// Prevent attribute/property \"interpolation\"\n\t// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\n\n\tif (!assert(function (div) {\n\t\tdiv.innerHTML = \"<a href='#'></a>\";\n\t\treturn div.firstChild.getAttribute(\"href\") === \"#\";\n\t})) {\n\t\taddHandle(\"type|href|height|width\", function (elem, name, isXML) {\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem.getAttribute(name, name.toLowerCase() === \"type\" ? 1 : 2);\n\t\t\t}\n\t\t});\n\t} // Support: IE<9\n\t// Use defaultValue in place of getAttribute(\"value\")\n\n\n\tif (!support.attributes || !assert(function (div) {\n\t\tdiv.innerHTML = \"<input/>\";\n\t\tdiv.firstChild.setAttribute(\"value\", \"\");\n\t\treturn div.firstChild.getAttribute(\"value\") === \"\";\n\t})) {\n\t\taddHandle(\"value\", function (elem, name, isXML) {\n\t\t\tif (!isXML && elem.nodeName.toLowerCase() === \"input\") {\n\t\t\t\treturn elem.defaultValue;\n\t\t\t}\n\t\t});\n\t} // Support: IE<9\n\t// Use getAttributeNode to fetch booleans when getAttribute lies\n\n\n\tif (!assert(function (div) {\n\t\treturn div.getAttribute(\"disabled\") == null;\n\t})) {\n\t\taddHandle(booleans, function (elem, name, isXML) {\n\t\t\tvar val;\n\n\t\t\tif (!isXML) {\n\t\t\t\treturn elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;\n\t\t\t}\n\t\t});\n\t} // EXPOSE\n\n\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(function () {\n\t\t\treturn Sizzle;\n\t\t}); // Sizzle requires that there be a global window in Common-JS like environments\n\t} else if (typeof module !== \"undefined\" && module.exports) {\n\t\tmodule.exports = Sizzle;\n\t} else {\n\t\twindow.Sizzle = Sizzle;\n\t} // EXPOSE\n\n})(window);","map":{"version":3,"sources":["packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js"],"names":["window","i","support","Expr","getText","isXML","tokenize","compile","select","outermostContext","sortInput","hasDuplicate","setDocument","document","docElem","documentIsHTML","rbuggyQSA","rbuggyMatches","matches","contains","expando","Date","preferredDoc","dirruns","done","classCache","createCache","tokenCache","compilerCache","sortOrder","a","b","MAX_NEGATIVE","hasOwn","hasOwnProperty","arr","pop","push_native","push","slice","indexOf","list","elem","len","length","booleans","whitespace","identifier","attributes","pseudos","rwhitespace","RegExp","rtrim","rcomma","rcombinators","rattributeQuotes","rpseudo","ridentifier","matchExpr","rinputs","rheader","rnative","rquickExpr","rsibling","rescape","runescape","funescape","_","escaped","escapedWhitespace","high","String","fromCharCode","unloadHandler","apply","call","childNodes","nodeType","e","target","els","j","Sizzle","selector","context","results","seed","m","nid","nidselect","match","groups","newSelector","newContext","ownerDocument","exec","getElementById","id","getElementsByTagName","getElementsByClassName","qsa","test","nodeName","toLowerCase","getAttribute","replace","setAttribute","toSelector","join","testContext","parentNode","querySelectorAll","qsaError","removeAttribute","keys","cache","key","value","cacheLength","shift","markFunction","fn","assert","div","createElement","removeChild","addHandle","attrs","handler","split","attrHandle","siblingCheck","cur","diff","sourceIndex","nextSibling","createInputPseudo","type","name","createButtonPseudo","createPositionalPseudo","argument","matchIndexes","documentElement","node","hasCompare","parent","doc","defaultView","top","addEventListener","attachEvent","className","appendChild","createComment","getById","getElementsByName","find","filter","attrId","getAttributeNode","tag","tmp","innerHTML","input","matchesSelector","webkitMatchesSelector","mozMatchesSelector","oMatchesSelector","msMatchesSelector","disconnectedMatch","compareDocumentPosition","adown","bup","compare","sortDetached","aup","ap","bp","unshift","expr","elements","ret","attr","val","undefined","specified","error","msg","Error","uniqueSort","duplicates","detectDuplicates","sortStable","sort","splice","textContent","firstChild","nodeValue","selectors","createPseudo","relative","dir","first","preFilter","excess","unquoted","nodeNameSelector","pattern","operator","check","result","what","last","simple","forward","ofType","xml","uniqueCache","outerCache","nodeIndex","start","useCache","lastChild","uniqueID","pseudo","args","setFilters","idx","matched","matcher","unmatched","text","innerText","lang","elemLang","hash","location","activeElement","hasFocus","href","tabIndex","disabled","checked","selected","selectedIndex","radio","checkbox","file","password","image","submit","reset","prototype","filters","parseOnly","tokens","soFar","preFilters","cached","addCombinator","combinator","base","checkNonElements","doneName","oldCache","newCache","elementMatcher","matchers","multipleContexts","contexts","condense","map","newUnmatched","mapped","setMatcher","postFilter","postFinder","postSelector","temp","preMap","postMap","preexisting","elems","matcherIn","matcherOut","matcherFromTokens","checkContext","leadingRelative","implicitRelative","matchContext","matchAnyContext","concat","matcherFromGroupMatchers","elementMatchers","setMatchers","bySet","byElement","superMatcher","outermost","matchedCount","setMatched","contextBackup","dirrunsUnique","Math","random","token","compiled","div1","defaultValue","define","amd","module","exports"],"mappings":"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","file":"packages/zurb:foundation-sites/bower_components/jquery/external/sizzle/dist/sizzle.js.map","sourcesContent":["/*!\n * Sizzle CSS Selector Engine v2.2.1\n * http://sizzlejs.com/\n *\n * Copyright jQuery Foundation and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2015-10-17\n */\n(function( window ) {\n\nvar i,\n\tsupport,\n\tExpr,\n\tgetText,\n\tisXML,\n\ttokenize,\n\tcompile,\n\tselect,\n\toutermostContext,\n\tsortInput,\n\thasDuplicate,\n\n\t// Local document vars\n\tsetDocument,\n\tdocument,\n\tdocElem,\n\tdocumentIsHTML,\n\trbuggyQSA,\n\trbuggyMatches,\n\tmatches,\n\tcontains,\n\n\t// Instance-specific data\n\texpando = \"sizzle\" + 1 * new Date(),\n\tpreferredDoc = window.document,\n\tdirruns = 0,\n\tdone = 0,\n\tclassCache = createCache(),\n\ttokenCache = createCache(),\n\tcompilerCache = createCache(),\n\tsortOrder = function( a, b ) {\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t}\n\t\treturn 0;\n\t},\n\n\t// General-purpose constants\n\tMAX_NEGATIVE = 1 << 31,\n\n\t// Instance methods\n\thasOwn = ({}).hasOwnProperty,\n\tarr = [],\n\tpop = arr.pop,\n\tpush_native = arr.push,\n\tpush = arr.push,\n\tslice = arr.slice,\n\t// Use a stripped-down indexOf as it's faster than native\n\t// http://jsperf.com/thor-indexof-vs-for/5\n\tindexOf = function( list, elem ) {\n\t\tvar i = 0,\n\t\t\tlen = list.length;\n\t\tfor ( ; i < len; i++ ) {\n\t\t\tif ( list[i] === elem ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t},\n\n\tbooleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n\t// Regular expressions\n\n\t// http://www.w3.org/TR/css3-selectors/#whitespace\n\twhitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n\n\t// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n\tidentifier = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n\t// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors\n\tattributes = \"\\\\[\" + whitespace + \"*(\" + identifier + \")(?:\" + whitespace +\n\t\t// Operator (capture 2)\n\t\t\"*([*^$|!~]?=)\" + whitespace +\n\t\t// \"Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]\"\n\t\t\"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + identifier + \"))|)\" + whitespace +\n\t\t\"*\\\\]\",\n\n\tpseudos = \":(\" + identifier + \")(?:\\\\((\" +\n\t\t// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:\n\t\t// 1. quoted (capture 3; capture 4 or capture 5)\n\t\t\"('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|\" +\n\t\t// 2. simple (capture 6)\n\t\t\"((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes + \")*)|\" +\n\t\t// 3. anything else (capture 2)\n\t\t\".*\" +\n\t\t\")\\\\)|)\",\n\n\t// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n\trwhitespace = new RegExp( whitespace + \"+\", \"g\" ),\n\trtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n\trcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n\trcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n\trattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*?)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n\trpseudo = new RegExp( pseudos ),\n\tridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n\tmatchExpr = {\n\t\t\"ID\": new RegExp( \"^#(\" + identifier + \")\" ),\n\t\t\"CLASS\": new RegExp( \"^\\\\.(\" + identifier + \")\" ),\n\t\t\"TAG\": new RegExp( \"^(\" + identifier + \"|[*])\" ),\n\t\t\"ATTR\": new RegExp( \"^\" + attributes ),\n\t\t\"PSEUDO\": new RegExp( \"^\" + pseudos ),\n\t\t\"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n\t\t\t\"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n\t\t\t\"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n\t\t\"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n\t\t// For use in libraries implementing .is()\n\t\t// We use this for POS matching in `select`\n\t\t\"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n\t\t\twhitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n\t},\n\n\trinputs = /^(?:input|select|textarea|button)$/i,\n\trheader = /^h\\d$/i,\n\n\trnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n\t// Easily-parseable/retrievable ID or TAG or CLASS selectors\n\trquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n\trsibling = /[+~]/,\n\trescape = /'|\\\\/g,\n\n\t// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n\trunescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n\tfunescape = function( _, escaped, escapedWhitespace ) {\n\t\tvar high = \"0x\" + escaped - 0x10000;\n\t\t// NaN means non-codepoint\n\t\t// Support: Firefox<24\n\t\t// Workaround erroneous numeric interpretation of +\"0x\"\n\t\treturn high !== high || escapedWhitespace ?\n\t\t\tescaped :\n\t\t\thigh < 0 ?\n\t\t\t\t// BMP codepoint\n\t\t\t\tString.fromCharCode( high + 0x10000 ) :\n\t\t\t\t// Supplemental Plane codepoint (surrogate pair)\n\t\t\t\tString.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n\t},\n\n\t// Used for iframes\n\t// See setDocument()\n\t// Removing the function wrapper causes a \"Permission Denied\"\n\t// error in IE\n\tunloadHandler = function() {\n\t\tsetDocument();\n\t};\n\n// Optimize for push.apply( _, NodeList )\ntry {\n\tpush.apply(\n\t\t(arr = slice.call( preferredDoc.childNodes )),\n\t\tpreferredDoc.childNodes\n\t);\n\t// Support: Android<4.0\n\t// Detect silently failing push.apply\n\tarr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n\tpush = { apply: arr.length ?\n\n\t\t// Leverage slice if possible\n\t\tfunction( target, els ) {\n\t\t\tpush_native.apply( target, slice.call(els) );\n\t\t} :\n\n\t\t// Support: IE<9\n\t\t// Otherwise append directly\n\t\tfunction( target, els ) {\n\t\t\tvar j = target.length,\n\t\t\t\ti = 0;\n\t\t\t// Can't trust NodeList.length\n\t\t\twhile ( (target[j++] = els[i++]) ) {}\n\t\t\ttarget.length = j - 1;\n\t\t}\n\t};\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n\tvar m, i, elem, nid, nidselect, match, groups, newSelector,\n\t\tnewContext = context && context.ownerDocument,\n\n\t\t// nodeType defaults to 9, since context defaults to document\n\t\tnodeType = context ? context.nodeType : 9;\n\n\tresults = results || [];\n\n\t// Return early from calls with invalid selector or context\n\tif ( typeof selector !== \"string\" || !selector ||\n\t\tnodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {\n\n\t\treturn results;\n\t}\n\n\t// Try to shortcut find operations (as opposed to filters) in HTML documents\n\tif ( !seed ) {\n\n\t\tif ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n\t\t\tsetDocument( context );\n\t\t}\n\t\tcontext = context || document;\n\n\t\tif ( documentIsHTML ) {\n\n\t\t\t// If the selector is sufficiently simple, try using a \"get*By*\" DOM method\n\t\t\t// (excepting DocumentFragment context, where the methods don't exist)\n\t\t\tif ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {\n\n\t\t\t\t// ID selector\n\t\t\t\tif ( (m = match[1]) ) {\n\n\t\t\t\t\t// Document context\n\t\t\t\t\tif ( nodeType === 9 ) {\n\t\t\t\t\t\tif ( (elem = context.getElementById( m )) ) {\n\n\t\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\t\tif ( elem.id === m ) {\n\t\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Element context\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// Support: IE, Opera, Webkit\n\t\t\t\t\t\t// TODO: identify versions\n\t\t\t\t\t\t// getElementById can match elements by name instead of ID\n\t\t\t\t\t\tif ( newContext && (elem = newContext.getElementById( m )) &&\n\t\t\t\t\t\t\tcontains( context, elem ) &&\n\t\t\t\t\t\t\telem.id === m ) {\n\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\treturn results;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t// Type selector\n\t\t\t\t} else if ( match[2] ) {\n\t\t\t\t\tpush.apply( results, context.getElementsByTagName( selector ) );\n\t\t\t\t\treturn results;\n\n\t\t\t\t// Class selector\n\t\t\t\t} else if ( (m = match[3]) && support.getElementsByClassName &&\n\t\t\t\t\tcontext.getElementsByClassName ) {\n\n\t\t\t\t\tpush.apply( results, context.getElementsByClassName( m ) );\n\t\t\t\t\treturn results;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Take advantage of querySelectorAll\n\t\t\tif ( support.qsa &&\n\t\t\t\t!compilerCache[ selector + \" \" ] &&\n\t\t\t\t(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n\n\t\t\t\tif ( nodeType !== 1 ) {\n\t\t\t\t\tnewContext = context;\n\t\t\t\t\tnewSelector = selector;\n\n\t\t\t\t// qSA looks outside Element context, which is not what we want\n\t\t\t\t// Thanks to Andrew Dupont for this workaround technique\n\t\t\t\t// Support: IE <=8\n\t\t\t\t// Exclude object elements\n\t\t\t\t} else if ( context.nodeName.toLowerCase() !== \"object\" ) {\n\n\t\t\t\t\t// Capture the context ID, setting it first if necessary\n\t\t\t\t\tif ( (nid = context.getAttribute( \"id\" )) ) {\n\t\t\t\t\t\tnid = nid.replace( rescape, \"\\\\$&\" );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontext.setAttribute( \"id\", (nid = expando) );\n\t\t\t\t\t}\n\n\t\t\t\t\t// Prefix every selector in the list\n\t\t\t\t\tgroups = tokenize( selector );\n\t\t\t\t\ti = groups.length;\n\t\t\t\t\tnidselect = ridentifier.test( nid ) ? \"#\" + nid : \"[id='\" + nid + \"']\";\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tgroups[i] = nidselect + \" \" + toSelector( groups[i] );\n\t\t\t\t\t}\n\t\t\t\t\tnewSelector = groups.join( \",\" );\n\n\t\t\t\t\t// Expand context for sibling selectors\n\t\t\t\t\tnewContext = rsibling.test( selector ) && testContext( context.parentNode ) ||\n\t\t\t\t\t\tcontext;\n\t\t\t\t}\n\n\t\t\t\tif ( newSelector ) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tpush.apply( results,\n\t\t\t\t\t\t\tnewContext.querySelectorAll( newSelector )\n\t\t\t\t\t\t);\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t} catch ( qsaError ) {\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tif ( nid === expando ) {\n\t\t\t\t\t\t\tcontext.removeAttribute( \"id\" );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// All others\n\treturn select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {function(string, object)} Returns the Object data after storing it on itself with\n *\tproperty name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *\tdeleting the oldest entry\n */\nfunction createCache() {\n\tvar keys = [];\n\n\tfunction cache( key, value ) {\n\t\t// Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n\t\tif ( keys.push( key + \" \" ) > Expr.cacheLength ) {\n\t\t\t// Only keep the most recent entries\n\t\t\tdelete cache[ keys.shift() ];\n\t\t}\n\t\treturn (cache[ key + \" \" ] = value);\n\t}\n\treturn cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n\tfn[ expando ] = true;\n\treturn fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n\tvar div = document.createElement(\"div\");\n\n\ttry {\n\t\treturn !!fn( div );\n\t} catch (e) {\n\t\treturn false;\n\t} finally {\n\t\t// Remove from its parent by default\n\t\tif ( div.parentNode ) {\n\t\t\tdiv.parentNode.removeChild( div );\n\t\t}\n\t\t// release memory in IE\n\t\tdiv = null;\n\t}\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n\tvar arr = attrs.split(\"|\"),\n\t\ti = arr.length;\n\n\twhile ( i-- ) {\n\t\tExpr.attrHandle[ arr[i] ] = handler;\n\t}\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n\tvar cur = b && a,\n\t\tdiff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n\t\t\t( ~b.sourceIndex || MAX_NEGATIVE ) -\n\t\t\t( ~a.sourceIndex || MAX_NEGATIVE );\n\n\t// Use IE sourceIndex if available on both nodes\n\tif ( diff ) {\n\t\treturn diff;\n\t}\n\n\t// Check if b follows a\n\tif ( cur ) {\n\t\twhile ( (cur = cur.nextSibling) ) {\n\t\t\tif ( cur === b ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn name === \"input\" && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n\treturn function( elem ) {\n\t\tvar name = elem.nodeName.toLowerCase();\n\t\treturn (name === \"input\" || name === \"button\") && elem.type === type;\n\t};\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n\treturn markFunction(function( argument ) {\n\t\targument = +argument;\n\t\treturn markFunction(function( seed, matches ) {\n\t\t\tvar j,\n\t\t\t\tmatchIndexes = fn( [], seed.length, argument ),\n\t\t\t\ti = matchIndexes.length;\n\n\t\t\t// Match elements found at the specified indexes\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( seed[ (j = matchIndexes[i]) ] ) {\n\t\t\t\t\tseed[j] = !(matches[j] = seed[j]);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n}\n\n/**\n * Checks a node for validity as a Sizzle context\n * @param {Element|Object=} context\n * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value\n */\nfunction testContext( context ) {\n\treturn context && typeof context.getElementsByTagName !== \"undefined\" && context;\n}\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Detects XML nodes\n * @param {Element|Object} elem An element or a document\n * @returns {Boolean} True iff elem is a non-HTML XML node\n */\nisXML = Sizzle.isXML = function( elem ) {\n\t// documentElement is verified for cases where it doesn't yet exist\n\t// (such as loading iframes in IE - #4833)\n\tvar documentElement = elem && (elem.ownerDocument || elem).documentElement;\n\treturn documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n\tvar hasCompare, parent,\n\t\tdoc = node ? node.ownerDocument || node : preferredDoc;\n\n\t// Return early if doc is invalid or already selected\n\tif ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n\t\treturn document;\n\t}\n\n\t// Update global variables\n\tdocument = doc;\n\tdocElem = document.documentElement;\n\tdocumentIsHTML = !isXML( document );\n\n\t// Support: IE 9-11, Edge\n\t// Accessing iframe documents after unload throws \"permission denied\" errors (jQuery #13936)\n\tif ( (parent = document.defaultView) && parent.top !== parent ) {\n\t\t// Support: IE 11\n\t\tif ( parent.addEventListener ) {\n\t\t\tparent.addEventListener( \"unload\", unloadHandler, false );\n\n\t\t// Support: IE 9 - 10 only\n\t\t} else if ( parent.attachEvent ) {\n\t\t\tparent.attachEvent( \"onunload\", unloadHandler );\n\t\t}\n\t}\n\n\t/* Attributes\n\t---------------------------------------------------------------------- */\n\n\t// Support: IE<8\n\t// Verify that getAttribute really returns attributes and not properties\n\t// (excepting IE8 booleans)\n\tsupport.attributes = assert(function( div ) {\n\t\tdiv.className = \"i\";\n\t\treturn !div.getAttribute(\"className\");\n\t});\n\n\t/* getElement(s)By*\n\t---------------------------------------------------------------------- */\n\n\t// Check if getElementsByTagName(\"*\") returns only elements\n\tsupport.getElementsByTagName = assert(function( div ) {\n\t\tdiv.appendChild( document.createComment(\"\") );\n\t\treturn !div.getElementsByTagName(\"*\").length;\n\t});\n\n\t// Support: IE<9\n\tsupport.getElementsByClassName = rnative.test( document.getElementsByClassName );\n\n\t// Support: IE<10\n\t// Check if getElementById returns elements by name\n\t// The broken getElementById methods don't pick up programatically-set names,\n\t// so use a roundabout getElementsByName test\n\tsupport.getById = assert(function( div ) {\n\t\tdocElem.appendChild( div ).id = expando;\n\t\treturn !document.getElementsByName || !document.getElementsByName( expando ).length;\n\t});\n\n\t// ID find and filter\n\tif ( support.getById ) {\n\t\tExpr.find[\"ID\"] = function( id, context ) {\n\t\t\tif ( typeof context.getElementById !== \"undefined\" && documentIsHTML ) {\n\t\t\t\tvar m = context.getElementById( id );\n\t\t\t\treturn m ? [ m ] : [];\n\t\t\t}\n\t\t};\n\t\tExpr.filter[\"ID\"] = function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn elem.getAttribute(\"id\") === attrId;\n\t\t\t};\n\t\t};\n\t} else {\n\t\t// Support: IE6/7\n\t\t// getElementById is not reliable as a find shortcut\n\t\tdelete Expr.find[\"ID\"];\n\n\t\tExpr.filter[\"ID\"] =  function( id ) {\n\t\t\tvar attrId = id.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\tvar node = typeof elem.getAttributeNode !== \"undefined\" &&\n\t\t\t\t\telem.getAttributeNode(\"id\");\n\t\t\t\treturn node && node.value === attrId;\n\t\t\t};\n\t\t};\n\t}\n\n\t// Tag\n\tExpr.find[\"TAG\"] = support.getElementsByTagName ?\n\t\tfunction( tag, context ) {\n\t\t\tif ( typeof context.getElementsByTagName !== \"undefined\" ) {\n\t\t\t\treturn context.getElementsByTagName( tag );\n\n\t\t\t// DocumentFragment nodes don't have gEBTN\n\t\t\t} else if ( support.qsa ) {\n\t\t\t\treturn context.querySelectorAll( tag );\n\t\t\t}\n\t\t} :\n\n\t\tfunction( tag, context ) {\n\t\t\tvar elem,\n\t\t\t\ttmp = [],\n\t\t\t\ti = 0,\n\t\t\t\t// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too\n\t\t\t\tresults = context.getElementsByTagName( tag );\n\n\t\t\t// Filter out possible comments\n\t\t\tif ( tag === \"*\" ) {\n\t\t\t\twhile ( (elem = results[i++]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 ) {\n\t\t\t\t\t\ttmp.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn tmp;\n\t\t\t}\n\t\t\treturn results;\n\t\t};\n\n\t// Class\n\tExpr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n\t\tif ( typeof context.getElementsByClassName !== \"undefined\" && documentIsHTML ) {\n\t\t\treturn context.getElementsByClassName( className );\n\t\t}\n\t};\n\n\t/* QSA/matchesSelector\n\t---------------------------------------------------------------------- */\n\n\t// QSA and matchesSelector support\n\n\t// matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n\trbuggyMatches = [];\n\n\t// qSa(:focus) reports false when true (Chrome 21)\n\t// We allow this because of a bug in IE8/9 that throws an error\n\t// whenever `document.activeElement` is accessed on an iframe\n\t// So, we allow :focus to pass through QSA all the time to avoid the IE error\n\t// See http://bugs.jquery.com/ticket/13378\n\trbuggyQSA = [];\n\n\tif ( (support.qsa = rnative.test( document.querySelectorAll )) ) {\n\t\t// Build QSA regex\n\t\t// Regex strategy adopted from Diego Perini\n\t\tassert(function( div ) {\n\t\t\t// Select is set to empty string on purpose\n\t\t\t// This is to test IE's treatment of not explicitly\n\t\t\t// setting a boolean content attribute,\n\t\t\t// since its presence should be enough\n\t\t\t// http://bugs.jquery.com/ticket/12359\n\t\t\tdocElem.appendChild( div ).innerHTML = \"<a id='\" + expando + \"'></a>\" +\n\t\t\t\t\"<select id='\" + expando + \"-\\r\\\\' msallowcapture=''>\" +\n\t\t\t\t\"<option selected=''></option></select>\";\n\n\t\t\t// Support: IE8, Opera 11-12.16\n\t\t\t// Nothing should be selected when empty strings follow ^= or $= or *=\n\t\t\t// The test attribute must be unknown in Opera but \"safe\" for WinRT\n\t\t\t// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section\n\t\t\tif ( div.querySelectorAll(\"[msallowcapture^='']\").length ) {\n\t\t\t\trbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n\t\t\t}\n\n\t\t\t// Support: IE8\n\t\t\t// Boolean attributes and \"value\" are not treated correctly\n\t\t\tif ( !div.querySelectorAll(\"[selected]\").length ) {\n\t\t\t\trbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n\t\t\t}\n\n\t\t\t// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+\n\t\t\tif ( !div.querySelectorAll( \"[id~=\" + expando + \"-]\" ).length ) {\n\t\t\t\trbuggyQSA.push(\"~=\");\n\t\t\t}\n\n\t\t\t// Webkit/Opera - :checked should return selected option elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":checked\").length ) {\n\t\t\t\trbuggyQSA.push(\":checked\");\n\t\t\t}\n\n\t\t\t// Support: Safari 8+, iOS 8+\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=136851\n\t\t\t// In-page `selector#id sibing-combinator selector` fails\n\t\t\tif ( !div.querySelectorAll( \"a#\" + expando + \"+*\" ).length ) {\n\t\t\t\trbuggyQSA.push(\".#.+[+~]\");\n\t\t\t}\n\t\t});\n\n\t\tassert(function( div ) {\n\t\t\t// Support: Windows 8 Native Apps\n\t\t\t// The type and name attributes are restricted during .innerHTML assignment\n\t\t\tvar input = document.createElement(\"input\");\n\t\t\tinput.setAttribute( \"type\", \"hidden\" );\n\t\t\tdiv.appendChild( input ).setAttribute( \"name\", \"D\" );\n\n\t\t\t// Support: IE8\n\t\t\t// Enforce case-sensitivity of name attribute\n\t\t\tif ( div.querySelectorAll(\"[name=d]\").length ) {\n\t\t\t\trbuggyQSA.push( \"name\" + whitespace + \"*[*^$|!~]?=\" );\n\t\t\t}\n\n\t\t\t// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n\t\t\t// IE8 throws error here and will not see later tests\n\t\t\tif ( !div.querySelectorAll(\":enabled\").length ) {\n\t\t\t\trbuggyQSA.push( \":enabled\", \":disabled\" );\n\t\t\t}\n\n\t\t\t// Opera 10-11 does not throw on post-comma invalid pseudos\n\t\t\tdiv.querySelectorAll(\"*,:x\");\n\t\t\trbuggyQSA.push(\",.*:\");\n\t\t});\n\t}\n\n\tif ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||\n\t\tdocElem.webkitMatchesSelector ||\n\t\tdocElem.mozMatchesSelector ||\n\t\tdocElem.oMatchesSelector ||\n\t\tdocElem.msMatchesSelector) )) ) {\n\n\t\tassert(function( div ) {\n\t\t\t// Check to see if it's possible to do matchesSelector\n\t\t\t// on a disconnected node (IE 9)\n\t\t\tsupport.disconnectedMatch = matches.call( div, \"div\" );\n\n\t\t\t// This should fail with an exception\n\t\t\t// Gecko does not error, returns false instead\n\t\t\tmatches.call( div, \"[s!='']:x\" );\n\t\t\trbuggyMatches.push( \"!=\", pseudos );\n\t\t});\n\t}\n\n\trbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n\trbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n\t/* Contains\n\t---------------------------------------------------------------------- */\n\thasCompare = rnative.test( docElem.compareDocumentPosition );\n\n\t// Element contains another\n\t// Purposefully self-exclusive\n\t// As in, an element does not contain itself\n\tcontains = hasCompare || rnative.test( docElem.contains ) ?\n\t\tfunction( a, b ) {\n\t\t\tvar adown = a.nodeType === 9 ? a.documentElement : a,\n\t\t\t\tbup = b && b.parentNode;\n\t\t\treturn a === bup || !!( bup && bup.nodeType === 1 && (\n\t\t\t\tadown.contains ?\n\t\t\t\t\tadown.contains( bup ) :\n\t\t\t\t\ta.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n\t\t\t));\n\t\t} :\n\t\tfunction( a, b ) {\n\t\t\tif ( b ) {\n\t\t\t\twhile ( (b = b.parentNode) ) {\n\t\t\t\t\tif ( b === a ) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t};\n\n\t/* Sorting\n\t---------------------------------------------------------------------- */\n\n\t// Document order sorting\n\tsortOrder = hasCompare ?\n\tfunction( a, b ) {\n\n\t\t// Flag for duplicate removal\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\t// Sort on method existence if only one input has compareDocumentPosition\n\t\tvar compare = !a.compareDocumentPosition - !b.compareDocumentPosition;\n\t\tif ( compare ) {\n\t\t\treturn compare;\n\t\t}\n\n\t\t// Calculate position if both inputs belong to the same document\n\t\tcompare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?\n\t\t\ta.compareDocumentPosition( b ) :\n\n\t\t\t// Otherwise we know they are disconnected\n\t\t\t1;\n\n\t\t// Disconnected nodes\n\t\tif ( compare & 1 ||\n\t\t\t(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n\t\t\t// Choose the first element that is related to our preferred document\n\t\t\tif ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {\n\t\t\t\treturn 1;\n\t\t\t}\n\n\t\t\t// Maintain original order\n\t\t\treturn sortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\t\t}\n\n\t\treturn compare & 4 ? -1 : 1;\n\t} :\n\tfunction( a, b ) {\n\t\t// Exit early if the nodes are identical\n\t\tif ( a === b ) {\n\t\t\thasDuplicate = true;\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar cur,\n\t\t\ti = 0,\n\t\t\taup = a.parentNode,\n\t\t\tbup = b.parentNode,\n\t\t\tap = [ a ],\n\t\t\tbp = [ b ];\n\n\t\t// Parentless nodes are either documents or disconnected\n\t\tif ( !aup || !bup ) {\n\t\t\treturn a === document ? -1 :\n\t\t\t\tb === document ? 1 :\n\t\t\t\taup ? -1 :\n\t\t\t\tbup ? 1 :\n\t\t\t\tsortInput ?\n\t\t\t\t( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :\n\t\t\t\t0;\n\n\t\t// If the nodes are siblings, we can do a quick check\n\t\t} else if ( aup === bup ) {\n\t\t\treturn siblingCheck( a, b );\n\t\t}\n\n\t\t// Otherwise we need full lists of their ancestors for comparison\n\t\tcur = a;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tap.unshift( cur );\n\t\t}\n\t\tcur = b;\n\t\twhile ( (cur = cur.parentNode) ) {\n\t\t\tbp.unshift( cur );\n\t\t}\n\n\t\t// Walk down the tree looking for a discrepancy\n\t\twhile ( ap[i] === bp[i] ) {\n\t\t\ti++;\n\t\t}\n\n\t\treturn i ?\n\t\t\t// Do a sibling check if the nodes have a common ancestor\n\t\t\tsiblingCheck( ap[i], bp[i] ) :\n\n\t\t\t// Otherwise nodes in our document sort first\n\t\t\tap[i] === preferredDoc ? -1 :\n\t\t\tbp[i] === preferredDoc ? 1 :\n\t\t\t0;\n\t};\n\n\treturn document;\n};\n\nSizzle.matches = function( expr, elements ) {\n\treturn Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\t// Make sure that attribute selectors are quoted\n\texpr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n\tif ( support.matchesSelector && documentIsHTML &&\n\t\t!compilerCache[ expr + \" \" ] &&\n\t\t( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n\t\t( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n\t\ttry {\n\t\t\tvar ret = matches.call( elem, expr );\n\n\t\t\t// IE 9's matchesSelector returns false on disconnected nodes\n\t\t\tif ( ret || support.disconnectedMatch ||\n\t\t\t\t\t// As well, disconnected nodes are said to be in a document\n\t\t\t\t\t// fragment in IE 9\n\t\t\t\t\telem.document && elem.document.nodeType !== 11 ) {\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t} catch (e) {}\n\t}\n\n\treturn Sizzle( expr, document, null, [ elem ] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n\t// Set document vars if needed\n\tif ( ( context.ownerDocument || context ) !== document ) {\n\t\tsetDocument( context );\n\t}\n\treturn contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n\t// Set document vars if needed\n\tif ( ( elem.ownerDocument || elem ) !== document ) {\n\t\tsetDocument( elem );\n\t}\n\n\tvar fn = Expr.attrHandle[ name.toLowerCase() ],\n\t\t// Don't get fooled by Object.prototype properties (jQuery #13807)\n\t\tval = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n\t\t\tfn( elem, name, !documentIsHTML ) :\n\t\t\tundefined;\n\n\treturn val !== undefined ?\n\t\tval :\n\t\tsupport.attributes || !documentIsHTML ?\n\t\t\telem.getAttribute( name ) :\n\t\t\t(val = elem.getAttributeNode(name)) && val.specified ?\n\t\t\t\tval.value :\n\t\t\t\tnull;\n};\n\nSizzle.error = function( msg ) {\n\tthrow new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n\tvar elem,\n\t\tduplicates = [],\n\t\tj = 0,\n\t\ti = 0;\n\n\t// Unless we *know* we can detect duplicates, assume their presence\n\thasDuplicate = !support.detectDuplicates;\n\tsortInput = !support.sortStable && results.slice( 0 );\n\tresults.sort( sortOrder );\n\n\tif ( hasDuplicate ) {\n\t\twhile ( (elem = results[i++]) ) {\n\t\t\tif ( elem === results[ i ] ) {\n\t\t\t\tj = duplicates.push( i );\n\t\t\t}\n\t\t}\n\t\twhile ( j-- ) {\n\t\t\tresults.splice( duplicates[ j ], 1 );\n\t\t}\n\t}\n\n\t// Clear input after sorting to release objects\n\t// See https://github.com/jquery/sizzle/pull/225\n\tsortInput = null;\n\n\treturn results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n\tvar node,\n\t\tret = \"\",\n\t\ti = 0,\n\t\tnodeType = elem.nodeType;\n\n\tif ( !nodeType ) {\n\t\t// If no nodeType, this is expected to be an array\n\t\twhile ( (node = elem[i++]) ) {\n\t\t\t// Do not traverse comment nodes\n\t\t\tret += getText( node );\n\t\t}\n\t} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n\t\t// Use textContent for elements\n\t\t// innerText usage removed for consistency of new lines (jQuery #11153)\n\t\tif ( typeof elem.textContent === \"string\" ) {\n\t\t\treturn elem.textContent;\n\t\t} else {\n\t\t\t// Traverse its children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tret += getText( elem );\n\t\t\t}\n\t\t}\n\t} else if ( nodeType === 3 || nodeType === 4 ) {\n\t\treturn elem.nodeValue;\n\t}\n\t// Do not include comment or processing instruction nodes\n\n\treturn ret;\n};\n\nExpr = Sizzle.selectors = {\n\n\t// Can be adjusted by the user\n\tcacheLength: 50,\n\n\tcreatePseudo: markFunction,\n\n\tmatch: matchExpr,\n\n\tattrHandle: {},\n\n\tfind: {},\n\n\trelative: {\n\t\t\">\": { dir: \"parentNode\", first: true },\n\t\t\" \": { dir: \"parentNode\" },\n\t\t\"+\": { dir: \"previousSibling\", first: true },\n\t\t\"~\": { dir: \"previousSibling\" }\n\t},\n\n\tpreFilter: {\n\t\t\"ATTR\": function( match ) {\n\t\t\tmatch[1] = match[1].replace( runescape, funescape );\n\n\t\t\t// Move the given value to match[3] whether quoted or unquoted\n\t\t\tmatch[3] = ( match[3] || match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n\t\t\tif ( match[2] === \"~=\" ) {\n\t\t\t\tmatch[3] = \" \" + match[3] + \" \";\n\t\t\t}\n\n\t\t\treturn match.slice( 0, 4 );\n\t\t},\n\n\t\t\"CHILD\": function( match ) {\n\t\t\t/* matches from matchExpr[\"CHILD\"]\n\t\t\t\t1 type (only|nth|...)\n\t\t\t\t2 what (child|of-type)\n\t\t\t\t3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n\t\t\t\t4 xn-component of xn+y argument ([+-]?\\d*n|)\n\t\t\t\t5 sign of xn-component\n\t\t\t\t6 x of xn-component\n\t\t\t\t7 sign of y-component\n\t\t\t\t8 y of y-component\n\t\t\t*/\n\t\t\tmatch[1] = match[1].toLowerCase();\n\n\t\t\tif ( match[1].slice( 0, 3 ) === \"nth\" ) {\n\t\t\t\t// nth-* requires argument\n\t\t\t\tif ( !match[3] ) {\n\t\t\t\t\tSizzle.error( match[0] );\n\t\t\t\t}\n\n\t\t\t\t// numeric x and y parameters for Expr.filter.CHILD\n\t\t\t\t// remember that false/true cast respectively to 0/1\n\t\t\t\tmatch[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n\t\t\t\tmatch[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n\t\t\t// other types prohibit arguments\n\t\t\t} else if ( match[3] ) {\n\t\t\t\tSizzle.error( match[0] );\n\t\t\t}\n\n\t\t\treturn match;\n\t\t},\n\n\t\t\"PSEUDO\": function( match ) {\n\t\t\tvar excess,\n\t\t\t\tunquoted = !match[6] && match[2];\n\n\t\t\tif ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\t// Accept quoted arguments as-is\n\t\t\tif ( match[3] ) {\n\t\t\t\tmatch[2] = match[4] || match[5] || \"\";\n\n\t\t\t// Strip excess characters from unquoted arguments\n\t\t\t} else if ( unquoted && rpseudo.test( unquoted ) &&\n\t\t\t\t// Get excess from tokenize (recursively)\n\t\t\t\t(excess = tokenize( unquoted, true )) &&\n\t\t\t\t// advance to the next closing parenthesis\n\t\t\t\t(excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n\t\t\t\t// excess is a negative index\n\t\t\t\tmatch[0] = match[0].slice( 0, excess );\n\t\t\t\tmatch[2] = unquoted.slice( 0, excess );\n\t\t\t}\n\n\t\t\t// Return only captures needed by the pseudo filter method (type and argument)\n\t\t\treturn match.slice( 0, 3 );\n\t\t}\n\t},\n\n\tfilter: {\n\n\t\t\"TAG\": function( nodeNameSelector ) {\n\t\t\tvar nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn nodeNameSelector === \"*\" ?\n\t\t\t\tfunction() { return true; } :\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n\t\t\t\t};\n\t\t},\n\n\t\t\"CLASS\": function( className ) {\n\t\t\tvar pattern = classCache[ className + \" \" ];\n\n\t\t\treturn pattern ||\n\t\t\t\t(pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n\t\t\t\tclassCache( className, function( elem ) {\n\t\t\t\t\treturn pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== \"undefined\" && elem.getAttribute(\"class\") || \"\" );\n\t\t\t\t});\n\t\t},\n\n\t\t\"ATTR\": function( name, operator, check ) {\n\t\t\treturn function( elem ) {\n\t\t\t\tvar result = Sizzle.attr( elem, name );\n\n\t\t\t\tif ( result == null ) {\n\t\t\t\t\treturn operator === \"!=\";\n\t\t\t\t}\n\t\t\t\tif ( !operator ) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tresult += \"\";\n\n\t\t\t\treturn operator === \"=\" ? result === check :\n\t\t\t\t\toperator === \"!=\" ? result !== check :\n\t\t\t\t\toperator === \"^=\" ? check && result.indexOf( check ) === 0 :\n\t\t\t\t\toperator === \"*=\" ? check && result.indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"$=\" ? check && result.slice( -check.length ) === check :\n\t\t\t\t\toperator === \"~=\" ? ( \" \" + result.replace( rwhitespace, \" \" ) + \" \" ).indexOf( check ) > -1 :\n\t\t\t\t\toperator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n\t\t\t\t\tfalse;\n\t\t\t};\n\t\t},\n\n\t\t\"CHILD\": function( type, what, argument, first, last ) {\n\t\t\tvar simple = type.slice( 0, 3 ) !== \"nth\",\n\t\t\t\tforward = type.slice( -4 ) !== \"last\",\n\t\t\t\tofType = what === \"of-type\";\n\n\t\t\treturn first === 1 && last === 0 ?\n\n\t\t\t\t// Shortcut for :nth-*(n)\n\t\t\t\tfunction( elem ) {\n\t\t\t\t\treturn !!elem.parentNode;\n\t\t\t\t} :\n\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tvar cache, uniqueCache, outerCache, node, nodeIndex, start,\n\t\t\t\t\t\tdir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n\t\t\t\t\t\tparent = elem.parentNode,\n\t\t\t\t\t\tname = ofType && elem.nodeName.toLowerCase(),\n\t\t\t\t\t\tuseCache = !xml && !ofType,\n\t\t\t\t\t\tdiff = false;\n\n\t\t\t\t\tif ( parent ) {\n\n\t\t\t\t\t\t// :(first|last|only)-(child|of-type)\n\t\t\t\t\t\tif ( simple ) {\n\t\t\t\t\t\t\twhile ( dir ) {\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\twhile ( (node = node[ dir ]) ) {\n\t\t\t\t\t\t\t\t\tif ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) {\n\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// Reverse direction for :only-* (if we haven't yet done so)\n\t\t\t\t\t\t\t\tstart = dir = type === \"only\" && !start && \"nextSibling\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart = [ forward ? parent.firstChild : parent.lastChild ];\n\n\t\t\t\t\t\t// non-xml :nth-child(...) stores cache data on `parent`\n\t\t\t\t\t\tif ( forward && useCache ) {\n\n\t\t\t\t\t\t\t// Seek `elem` from a previously-cached index\n\n\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\tnode = parent;\n\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\tdiff = nodeIndex && cache[ 2 ];\n\t\t\t\t\t\t\tnode = nodeIndex && parent.childNodes[ nodeIndex ];\n\n\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\n\t\t\t\t\t\t\t\t// Fallback to seeking `elem` from the start\n\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t// When found, cache indexes on `parent` and break\n\t\t\t\t\t\t\t\tif ( node.nodeType === 1 && ++diff && node === elem ) {\n\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, nodeIndex, diff ];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Use previously-cached element index if available\n\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t// ...in a gzip-friendly way\n\t\t\t\t\t\t\t\tnode = elem;\n\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\tcache = uniqueCache[ type ] || [];\n\t\t\t\t\t\t\t\tnodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];\n\t\t\t\t\t\t\t\tdiff = nodeIndex;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// xml :nth-child(...)\n\t\t\t\t\t\t\t// or :nth-last-child(...) or :nth(-last)?-of-type(...)\n\t\t\t\t\t\t\tif ( diff === false ) {\n\t\t\t\t\t\t\t\t// Use the same loop as above to seek `elem` from the start\n\t\t\t\t\t\t\t\twhile ( (node = ++nodeIndex && node && node[ dir ] ||\n\t\t\t\t\t\t\t\t\t(diff = nodeIndex = 0) || start.pop()) ) {\n\n\t\t\t\t\t\t\t\t\tif ( ( ofType ?\n\t\t\t\t\t\t\t\t\t\tnode.nodeName.toLowerCase() === name :\n\t\t\t\t\t\t\t\t\t\tnode.nodeType === 1 ) &&\n\t\t\t\t\t\t\t\t\t\t++diff ) {\n\n\t\t\t\t\t\t\t\t\t\t// Cache the index of each encountered element\n\t\t\t\t\t\t\t\t\t\tif ( useCache ) {\n\t\t\t\t\t\t\t\t\t\t\touterCache = node[ expando ] || (node[ expando ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache = outerCache[ node.uniqueID ] ||\n\t\t\t\t\t\t\t\t\t\t\t\t(outerCache[ node.uniqueID ] = {});\n\n\t\t\t\t\t\t\t\t\t\t\tuniqueCache[ type ] = [ dirruns, diff ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif ( node === elem ) {\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Incorporate the offset, then check against cycle size\n\t\t\t\t\t\tdiff -= last;\n\t\t\t\t\t\treturn diff === first || ( diff % first === 0 && diff / first >= 0 );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t},\n\n\t\t\"PSEUDO\": function( pseudo, argument ) {\n\t\t\t// pseudo-class names are case-insensitive\n\t\t\t// http://www.w3.org/TR/selectors/#pseudo-classes\n\t\t\t// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n\t\t\t// Remember that setFilters inherits from pseudos\n\t\t\tvar args,\n\t\t\t\tfn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n\t\t\t\t\tSizzle.error( \"unsupported pseudo: \" + pseudo );\n\n\t\t\t// The user may use createPseudo to indicate that\n\t\t\t// arguments are needed to create the filter function\n\t\t\t// just as Sizzle does\n\t\t\tif ( fn[ expando ] ) {\n\t\t\t\treturn fn( argument );\n\t\t\t}\n\n\t\t\t// But maintain support for old signatures\n\t\t\tif ( fn.length > 1 ) {\n\t\t\t\targs = [ pseudo, pseudo, \"\", argument ];\n\t\t\t\treturn Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n\t\t\t\t\tmarkFunction(function( seed, matches ) {\n\t\t\t\t\t\tvar idx,\n\t\t\t\t\t\t\tmatched = fn( seed, argument ),\n\t\t\t\t\t\t\ti = matched.length;\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tidx = indexOf( seed, matched[i] );\n\t\t\t\t\t\t\tseed[ idx ] = !( matches[ idx ] = matched[i] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}) :\n\t\t\t\t\tfunction( elem ) {\n\t\t\t\t\t\treturn fn( elem, 0, args );\n\t\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn fn;\n\t\t}\n\t},\n\n\tpseudos: {\n\t\t// Potentially complex pseudos\n\t\t\"not\": markFunction(function( selector ) {\n\t\t\t// Trim the selector passed to compile\n\t\t\t// to avoid treating leading and trailing\n\t\t\t// spaces as combinators\n\t\t\tvar input = [],\n\t\t\t\tresults = [],\n\t\t\t\tmatcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n\t\t\treturn matcher[ expando ] ?\n\t\t\t\tmarkFunction(function( seed, matches, context, xml ) {\n\t\t\t\t\tvar elem,\n\t\t\t\t\t\tunmatched = matcher( seed, null, xml, [] ),\n\t\t\t\t\t\ti = seed.length;\n\n\t\t\t\t\t// Match elements unmatched by `matcher`\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = unmatched[i]) ) {\n\t\t\t\t\t\t\tseed[i] = !(matches[i] = elem);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}) :\n\t\t\t\tfunction( elem, context, xml ) {\n\t\t\t\t\tinput[0] = elem;\n\t\t\t\t\tmatcher( input, null, xml, results );\n\t\t\t\t\t// Don't keep the element (issue #299)\n\t\t\t\t\tinput[0] = null;\n\t\t\t\t\treturn !results.pop();\n\t\t\t\t};\n\t\t}),\n\n\t\t\"has\": markFunction(function( selector ) {\n\t\t\treturn function( elem ) {\n\t\t\t\treturn Sizzle( selector, elem ).length > 0;\n\t\t\t};\n\t\t}),\n\n\t\t\"contains\": markFunction(function( text ) {\n\t\t\ttext = text.replace( runescape, funescape );\n\t\t\treturn function( elem ) {\n\t\t\t\treturn ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n\t\t\t};\n\t\t}),\n\n\t\t// \"Whether an element is represented by a :lang() selector\n\t\t// is based solely on the element's language value\n\t\t// being equal to the identifier C,\n\t\t// or beginning with the identifier C immediately followed by \"-\".\n\t\t// The matching of C against the element's language value is performed case-insensitively.\n\t\t// The identifier C does not have to be a valid language name.\"\n\t\t// http://www.w3.org/TR/selectors/#lang-pseudo\n\t\t\"lang\": markFunction( function( lang ) {\n\t\t\t// lang value must be a valid identifier\n\t\t\tif ( !ridentifier.test(lang || \"\") ) {\n\t\t\t\tSizzle.error( \"unsupported lang: \" + lang );\n\t\t\t}\n\t\t\tlang = lang.replace( runescape, funescape ).toLowerCase();\n\t\t\treturn function( elem ) {\n\t\t\t\tvar elemLang;\n\t\t\t\tdo {\n\t\t\t\t\tif ( (elemLang = documentIsHTML ?\n\t\t\t\t\t\telem.lang :\n\t\t\t\t\t\telem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n\t\t\t\t\t\telemLang = elemLang.toLowerCase();\n\t\t\t\t\t\treturn elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n\t\t\t\t\t}\n\t\t\t\t} while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n\t\t\t\treturn false;\n\t\t\t};\n\t\t}),\n\n\t\t// Miscellaneous\n\t\t\"target\": function( elem ) {\n\t\t\tvar hash = window.location && window.location.hash;\n\t\t\treturn hash && hash.slice( 1 ) === elem.id;\n\t\t},\n\n\t\t\"root\": function( elem ) {\n\t\t\treturn elem === docElem;\n\t\t},\n\n\t\t\"focus\": function( elem ) {\n\t\t\treturn elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n\t\t},\n\n\t\t// Boolean properties\n\t\t\"enabled\": function( elem ) {\n\t\t\treturn elem.disabled === false;\n\t\t},\n\n\t\t\"disabled\": function( elem ) {\n\t\t\treturn elem.disabled === true;\n\t\t},\n\n\t\t\"checked\": function( elem ) {\n\t\t\t// In CSS3, :checked should return both checked and selected elements\n\t\t\t// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n\t\t\tvar nodeName = elem.nodeName.toLowerCase();\n\t\t\treturn (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n\t\t},\n\n\t\t\"selected\": function( elem ) {\n\t\t\t// Accessing this property makes selected-by-default\n\t\t\t// options in Safari work properly\n\t\t\tif ( elem.parentNode ) {\n\t\t\t\telem.parentNode.selectedIndex;\n\t\t\t}\n\n\t\t\treturn elem.selected === true;\n\t\t},\n\n\t\t// Contents\n\t\t\"empty\": function( elem ) {\n\t\t\t// http://www.w3.org/TR/selectors/#empty-pseudo\n\t\t\t// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),\n\t\t\t//   but not by others (comment: 8; processing instruction: 7; etc.)\n\t\t\t// nodeType < 6 works because attributes (2) do not appear as children\n\t\t\tfor ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n\t\t\t\tif ( elem.nodeType < 6 ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t},\n\n\t\t\"parent\": function( elem ) {\n\t\t\treturn !Expr.pseudos[\"empty\"]( elem );\n\t\t},\n\n\t\t// Element/input types\n\t\t\"header\": function( elem ) {\n\t\t\treturn rheader.test( elem.nodeName );\n\t\t},\n\n\t\t\"input\": function( elem ) {\n\t\t\treturn rinputs.test( elem.nodeName );\n\t\t},\n\n\t\t\"button\": function( elem ) {\n\t\t\tvar name = elem.nodeName.toLowerCase();\n\t\t\treturn name === \"input\" && elem.type === \"button\" || name === \"button\";\n\t\t},\n\n\t\t\"text\": function( elem ) {\n\t\t\tvar attr;\n\t\t\treturn elem.nodeName.toLowerCase() === \"input\" &&\n\t\t\t\telem.type === \"text\" &&\n\n\t\t\t\t// Support: IE<8\n\t\t\t\t// New HTML5 attribute values (e.g., \"search\") appear with elem.type === \"text\"\n\t\t\t\t( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === \"text\" );\n\t\t},\n\n\t\t// Position-in-collection\n\t\t\"first\": createPositionalPseudo(function() {\n\t\t\treturn [ 0 ];\n\t\t}),\n\n\t\t\"last\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\treturn [ length - 1 ];\n\t\t}),\n\n\t\t\"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\treturn [ argument < 0 ? argument + length : argument ];\n\t\t}),\n\n\t\t\"even\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 0;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n\t\t\tvar i = 1;\n\t\t\tfor ( ; i < length; i += 2 ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; --i >= 0; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t}),\n\n\t\t\"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n\t\t\tvar i = argument < 0 ? argument + length : argument;\n\t\t\tfor ( ; ++i < length; ) {\n\t\t\t\tmatchIndexes.push( i );\n\t\t\t}\n\t\t\treturn matchIndexes;\n\t\t})\n\t}\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n\tExpr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n\tExpr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\ntokenize = Sizzle.tokenize = function( selector, parseOnly ) {\n\tvar matched, match, tokens, type,\n\t\tsoFar, groups, preFilters,\n\t\tcached = tokenCache[ selector + \" \" ];\n\n\tif ( cached ) {\n\t\treturn parseOnly ? 0 : cached.slice( 0 );\n\t}\n\n\tsoFar = selector;\n\tgroups = [];\n\tpreFilters = Expr.preFilter;\n\n\twhile ( soFar ) {\n\n\t\t// Comma and first run\n\t\tif ( !matched || (match = rcomma.exec( soFar )) ) {\n\t\t\tif ( match ) {\n\t\t\t\t// Don't consume trailing commas as valid\n\t\t\t\tsoFar = soFar.slice( match[0].length ) || soFar;\n\t\t\t}\n\t\t\tgroups.push( (tokens = []) );\n\t\t}\n\n\t\tmatched = false;\n\n\t\t// Combinators\n\t\tif ( (match = rcombinators.exec( soFar )) ) {\n\t\t\tmatched = match.shift();\n\t\t\ttokens.push({\n\t\t\t\tvalue: matched,\n\t\t\t\t// Cast descendant combinators to space\n\t\t\t\ttype: match[0].replace( rtrim, \" \" )\n\t\t\t});\n\t\t\tsoFar = soFar.slice( matched.length );\n\t\t}\n\n\t\t// Filters\n\t\tfor ( type in Expr.filter ) {\n\t\t\tif ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n\t\t\t\t(match = preFilters[ type ]( match ))) ) {\n\t\t\t\tmatched = match.shift();\n\t\t\t\ttokens.push({\n\t\t\t\t\tvalue: matched,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tmatches: match\n\t\t\t\t});\n\t\t\t\tsoFar = soFar.slice( matched.length );\n\t\t\t}\n\t\t}\n\n\t\tif ( !matched ) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// Return the length of the invalid excess\n\t// if we're just parsing\n\t// Otherwise, throw an error or return tokens\n\treturn parseOnly ?\n\t\tsoFar.length :\n\t\tsoFar ?\n\t\t\tSizzle.error( selector ) :\n\t\t\t// Cache the tokens\n\t\t\ttokenCache( selector, groups ).slice( 0 );\n};\n\nfunction toSelector( tokens ) {\n\tvar i = 0,\n\t\tlen = tokens.length,\n\t\tselector = \"\";\n\tfor ( ; i < len; i++ ) {\n\t\tselector += tokens[i].value;\n\t}\n\treturn selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n\tvar dir = combinator.dir,\n\t\tcheckNonElements = base && dir === \"parentNode\",\n\t\tdoneName = done++;\n\n\treturn combinator.first ?\n\t\t// Check against closest ancestor/preceding element\n\t\tfunction( elem, context, xml ) {\n\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\treturn matcher( elem, context, xml );\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\n\t\t// Check against all ancestor/preceding elements\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar oldCache, uniqueCache, outerCache,\n\t\t\t\tnewCache = [ dirruns, doneName ];\n\n\t\t\t// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching\n\t\t\tif ( xml ) {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\tif ( matcher( elem, context, xml ) ) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\twhile ( (elem = elem[ dir ]) ) {\n\t\t\t\t\tif ( elem.nodeType === 1 || checkNonElements ) {\n\t\t\t\t\t\touterCache = elem[ expando ] || (elem[ expando ] = {});\n\n\t\t\t\t\t\t// Support: IE <9 only\n\t\t\t\t\t\t// Defend against cloned attroperties (jQuery gh-1709)\n\t\t\t\t\t\tuniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});\n\n\t\t\t\t\t\tif ( (oldCache = uniqueCache[ dir ]) &&\n\t\t\t\t\t\t\toldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {\n\n\t\t\t\t\t\t\t// Assign to newCache so results back-propagate to previous elements\n\t\t\t\t\t\t\treturn (newCache[ 2 ] = oldCache[ 2 ]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Reuse newcache so results back-propagate to previous elements\n\t\t\t\t\t\t\tuniqueCache[ dir ] = newCache;\n\n\t\t\t\t\t\t\t// A match means we're done; a fail means we have to keep checking\n\t\t\t\t\t\t\tif ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {\n\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n}\n\nfunction elementMatcher( matchers ) {\n\treturn matchers.length > 1 ?\n\t\tfunction( elem, context, xml ) {\n\t\t\tvar i = matchers.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( !matchers[i]( elem, context, xml ) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t} :\n\t\tmatchers[0];\n}\n\nfunction multipleContexts( selector, contexts, results ) {\n\tvar i = 0,\n\t\tlen = contexts.length;\n\tfor ( ; i < len; i++ ) {\n\t\tSizzle( selector, contexts[i], results );\n\t}\n\treturn results;\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n\tvar elem,\n\t\tnewUnmatched = [],\n\t\ti = 0,\n\t\tlen = unmatched.length,\n\t\tmapped = map != null;\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (elem = unmatched[i]) ) {\n\t\t\tif ( !filter || filter( elem, context, xml ) ) {\n\t\t\t\tnewUnmatched.push( elem );\n\t\t\t\tif ( mapped ) {\n\t\t\t\t\tmap.push( i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n\tif ( postFilter && !postFilter[ expando ] ) {\n\t\tpostFilter = setMatcher( postFilter );\n\t}\n\tif ( postFinder && !postFinder[ expando ] ) {\n\t\tpostFinder = setMatcher( postFinder, postSelector );\n\t}\n\treturn markFunction(function( seed, results, context, xml ) {\n\t\tvar temp, i, elem,\n\t\t\tpreMap = [],\n\t\t\tpostMap = [],\n\t\t\tpreexisting = results.length,\n\n\t\t\t// Get initial elements from seed or context\n\t\t\telems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n\t\t\t// Prefilter to get matcher input, preserving a map for seed-results synchronization\n\t\t\tmatcherIn = preFilter && ( seed || !selector ) ?\n\t\t\t\tcondense( elems, preMap, preFilter, context, xml ) :\n\t\t\t\telems,\n\n\t\t\tmatcherOut = matcher ?\n\t\t\t\t// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n\t\t\t\tpostFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n\t\t\t\t\t// ...intermediate processing is necessary\n\t\t\t\t\t[] :\n\n\t\t\t\t\t// ...otherwise use results directly\n\t\t\t\t\tresults :\n\t\t\t\tmatcherIn;\n\n\t\t// Find primary matches\n\t\tif ( matcher ) {\n\t\t\tmatcher( matcherIn, matcherOut, context, xml );\n\t\t}\n\n\t\t// Apply postFilter\n\t\tif ( postFilter ) {\n\t\t\ttemp = condense( matcherOut, postMap );\n\t\t\tpostFilter( temp, [], context, xml );\n\n\t\t\t// Un-match failing elements by moving them back to matcherIn\n\t\t\ti = temp.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tif ( (elem = temp[i]) ) {\n\t\t\t\t\tmatcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( seed ) {\n\t\t\tif ( postFinder || preFilter ) {\n\t\t\t\tif ( postFinder ) {\n\t\t\t\t\t// Get the final matcherOut by condensing this intermediate into postFinder contexts\n\t\t\t\t\ttemp = [];\n\t\t\t\t\ti = matcherOut.length;\n\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\tif ( (elem = matcherOut[i]) ) {\n\t\t\t\t\t\t\t// Restore matcherIn since elem is not yet a final match\n\t\t\t\t\t\t\ttemp.push( (matcherIn[i] = elem) );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tpostFinder( null, (matcherOut = []), temp, xml );\n\t\t\t\t}\n\n\t\t\t\t// Move matched elements from seed to results to keep them synchronized\n\t\t\t\ti = matcherOut.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\tif ( (elem = matcherOut[i]) &&\n\t\t\t\t\t\t(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {\n\n\t\t\t\t\t\tseed[temp] = !(results[temp] = elem);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t// Add elements to results, through postFinder if defined\n\t\t} else {\n\t\t\tmatcherOut = condense(\n\t\t\t\tmatcherOut === results ?\n\t\t\t\t\tmatcherOut.splice( preexisting, matcherOut.length ) :\n\t\t\t\t\tmatcherOut\n\t\t\t);\n\t\t\tif ( postFinder ) {\n\t\t\t\tpostFinder( null, results, matcherOut, xml );\n\t\t\t} else {\n\t\t\t\tpush.apply( results, matcherOut );\n\t\t\t}\n\t\t}\n\t});\n}\n\nfunction matcherFromTokens( tokens ) {\n\tvar checkContext, matcher, j,\n\t\tlen = tokens.length,\n\t\tleadingRelative = Expr.relative[ tokens[0].type ],\n\t\timplicitRelative = leadingRelative || Expr.relative[\" \"],\n\t\ti = leadingRelative ? 1 : 0,\n\n\t\t// The foundational matcher ensures that elements are reachable from top-level context(s)\n\t\tmatchContext = addCombinator( function( elem ) {\n\t\t\treturn elem === checkContext;\n\t\t}, implicitRelative, true ),\n\t\tmatchAnyContext = addCombinator( function( elem ) {\n\t\t\treturn indexOf( checkContext, elem ) > -1;\n\t\t}, implicitRelative, true ),\n\t\tmatchers = [ function( elem, context, xml ) {\n\t\t\tvar ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n\t\t\t\t(checkContext = context).nodeType ?\n\t\t\t\t\tmatchContext( elem, context, xml ) :\n\t\t\t\t\tmatchAnyContext( elem, context, xml ) );\n\t\t\t// Avoid hanging onto element (issue #299)\n\t\t\tcheckContext = null;\n\t\t\treturn ret;\n\t\t} ];\n\n\tfor ( ; i < len; i++ ) {\n\t\tif ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n\t\t\tmatchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n\t\t} else {\n\t\t\tmatcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n\t\t\t// Return special upon seeing a positional matcher\n\t\t\tif ( matcher[ expando ] ) {\n\t\t\t\t// Find the next relative operator (if any) for proper handling\n\t\t\t\tj = ++i;\n\t\t\t\tfor ( ; j < len; j++ ) {\n\t\t\t\t\tif ( Expr.relative[ tokens[j].type ] ) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn setMatcher(\n\t\t\t\t\ti > 1 && elementMatcher( matchers ),\n\t\t\t\t\ti > 1 && toSelector(\n\t\t\t\t\t\t// If the preceding token was a descendant combinator, insert an implicit any-element `*`\n\t\t\t\t\t\ttokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n\t\t\t\t\t).replace( rtrim, \"$1\" ),\n\t\t\t\t\tmatcher,\n\t\t\t\t\ti < j && matcherFromTokens( tokens.slice( i, j ) ),\n\t\t\t\t\tj < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n\t\t\t\t\tj < len && toSelector( tokens )\n\t\t\t\t);\n\t\t\t}\n\t\t\tmatchers.push( matcher );\n\t\t}\n\t}\n\n\treturn elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n\tvar bySet = setMatchers.length > 0,\n\t\tbyElement = elementMatchers.length > 0,\n\t\tsuperMatcher = function( seed, context, xml, results, outermost ) {\n\t\t\tvar elem, j, matcher,\n\t\t\t\tmatchedCount = 0,\n\t\t\t\ti = \"0\",\n\t\t\t\tunmatched = seed && [],\n\t\t\t\tsetMatched = [],\n\t\t\t\tcontextBackup = outermostContext,\n\t\t\t\t// We must always have either seed elements or outermost context\n\t\t\t\telems = seed || byElement && Expr.find[\"TAG\"]( \"*\", outermost ),\n\t\t\t\t// Use integer dirruns iff this is the outermost matcher\n\t\t\t\tdirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),\n\t\t\t\tlen = elems.length;\n\n\t\t\tif ( outermost ) {\n\t\t\t\toutermostContext = context === document || context || outermost;\n\t\t\t}\n\n\t\t\t// Add elements passing elementMatchers directly to results\n\t\t\t// Support: IE<9, Safari\n\t\t\t// Tolerate NodeList properties (IE: \"length\"; Safari: <number>) matching elements by id\n\t\t\tfor ( ; i !== len && (elem = elems[i]) != null; i++ ) {\n\t\t\t\tif ( byElement && elem ) {\n\t\t\t\t\tj = 0;\n\t\t\t\t\tif ( !context && elem.ownerDocument !== document ) {\n\t\t\t\t\t\tsetDocument( elem );\n\t\t\t\t\t\txml = !documentIsHTML;\n\t\t\t\t\t}\n\t\t\t\t\twhile ( (matcher = elementMatchers[j++]) ) {\n\t\t\t\t\t\tif ( matcher( elem, context || document, xml) ) {\n\t\t\t\t\t\t\tresults.push( elem );\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( outermost ) {\n\t\t\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Track unmatched elements for set filters\n\t\t\t\tif ( bySet ) {\n\t\t\t\t\t// They will have gone through all possible matchers\n\t\t\t\t\tif ( (elem = !matcher && elem) ) {\n\t\t\t\t\t\tmatchedCount--;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Lengthen the array for every element, matched or not\n\t\t\t\t\tif ( seed ) {\n\t\t\t\t\t\tunmatched.push( elem );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// `i` is now the count of elements visited above, and adding it to `matchedCount`\n\t\t\t// makes the latter nonnegative.\n\t\t\tmatchedCount += i;\n\n\t\t\t// Apply set filters to unmatched elements\n\t\t\t// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`\n\t\t\t// equals `i`), unless we didn't visit _any_ elements in the above loop because we have\n\t\t\t// no element matchers and no seed.\n\t\t\t// Incrementing an initially-string \"0\" `i` allows `i` to remain a string only in that\n\t\t\t// case, which will result in a \"00\" `matchedCount` that differs from `i` but is also\n\t\t\t// numerically zero.\n\t\t\tif ( bySet && i !== matchedCount ) {\n\t\t\t\tj = 0;\n\t\t\t\twhile ( (matcher = setMatchers[j++]) ) {\n\t\t\t\t\tmatcher( unmatched, setMatched, context, xml );\n\t\t\t\t}\n\n\t\t\t\tif ( seed ) {\n\t\t\t\t\t// Reintegrate element matches to eliminate the need for sorting\n\t\t\t\t\tif ( matchedCount > 0 ) {\n\t\t\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t\t\tif ( !(unmatched[i] || setMatched[i]) ) {\n\t\t\t\t\t\t\t\tsetMatched[i] = pop.call( results );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// Discard index placeholder values to get only actual matches\n\t\t\t\t\tsetMatched = condense( setMatched );\n\t\t\t\t}\n\n\t\t\t\t// Add matches to results\n\t\t\t\tpush.apply( results, setMatched );\n\n\t\t\t\t// Seedless set matches succeeding multiple successful matchers stipulate sorting\n\t\t\t\tif ( outermost && !seed && setMatched.length > 0 &&\n\t\t\t\t\t( matchedCount + setMatchers.length ) > 1 ) {\n\n\t\t\t\t\tSizzle.uniqueSort( results );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Override manipulation of globals by nested matchers\n\t\t\tif ( outermost ) {\n\t\t\t\tdirruns = dirrunsUnique;\n\t\t\t\toutermostContext = contextBackup;\n\t\t\t}\n\n\t\t\treturn unmatched;\n\t\t};\n\n\treturn bySet ?\n\t\tmarkFunction( superMatcher ) :\n\t\tsuperMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {\n\tvar i,\n\t\tsetMatchers = [],\n\t\telementMatchers = [],\n\t\tcached = compilerCache[ selector + \" \" ];\n\n\tif ( !cached ) {\n\t\t// Generate a function of recursive functions that can be used to check each element\n\t\tif ( !match ) {\n\t\t\tmatch = tokenize( selector );\n\t\t}\n\t\ti = match.length;\n\t\twhile ( i-- ) {\n\t\t\tcached = matcherFromTokens( match[i] );\n\t\t\tif ( cached[ expando ] ) {\n\t\t\t\tsetMatchers.push( cached );\n\t\t\t} else {\n\t\t\t\telementMatchers.push( cached );\n\t\t\t}\n\t\t}\n\n\t\t// Cache the compiled function\n\t\tcached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n\n\t\t// Save selector and tokenization\n\t\tcached.selector = selector;\n\t}\n\treturn cached;\n};\n\n/**\n * A low-level selection function that works with Sizzle's compiled\n *  selector functions\n * @param {String|Function} selector A selector or a pre-compiled\n *  selector function built with Sizzle.compile\n * @param {Element} context\n * @param {Array} [results]\n * @param {Array} [seed] A set of elements to match against\n */\nselect = Sizzle.select = function( selector, context, results, seed ) {\n\tvar i, tokens, token, type, find,\n\t\tcompiled = typeof selector === \"function\" && selector,\n\t\tmatch = !seed && tokenize( (selector = compiled.selector || selector) );\n\n\tresults = results || [];\n\n\t// Try to minimize operations if there is only one selector in the list and no seed\n\t// (the latter of which guarantees us context)\n\tif ( match.length === 1 ) {\n\n\t\t// Reduce context if the leading compound selector is an ID\n\t\ttokens = match[0] = match[0].slice( 0 );\n\t\tif ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n\t\t\t\tsupport.getById && context.nodeType === 9 && documentIsHTML &&\n\t\t\t\tExpr.relative[ tokens[1].type ] ) {\n\n\t\t\tcontext = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n\t\t\tif ( !context ) {\n\t\t\t\treturn results;\n\n\t\t\t// Precompiled matchers will still verify ancestry, so step up a level\n\t\t\t} else if ( compiled ) {\n\t\t\t\tcontext = context.parentNode;\n\t\t\t}\n\n\t\t\tselector = selector.slice( tokens.shift().value.length );\n\t\t}\n\n\t\t// Fetch a seed set for right-to-left matching\n\t\ti = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n\t\twhile ( i-- ) {\n\t\t\ttoken = tokens[i];\n\n\t\t\t// Abort if we hit a combinator\n\t\t\tif ( Expr.relative[ (type = token.type) ] ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( (find = Expr.find[ type ]) ) {\n\t\t\t\t// Search, expanding context for leading sibling combinators\n\t\t\t\tif ( (seed = find(\n\t\t\t\t\ttoken.matches[0].replace( runescape, funescape ),\n\t\t\t\t\trsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context\n\t\t\t\t)) ) {\n\n\t\t\t\t\t// If seed is empty or no tokens remain, we can return early\n\t\t\t\t\ttokens.splice( i, 1 );\n\t\t\t\t\tselector = seed.length && toSelector( tokens );\n\t\t\t\t\tif ( !selector ) {\n\t\t\t\t\t\tpush.apply( results, seed );\n\t\t\t\t\t\treturn results;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Compile and execute a filtering function if one is not provided\n\t// Provide `match` to avoid retokenization if we modified the selector above\n\t( compiled || compile( selector, match ) )(\n\t\tseed,\n\t\tcontext,\n\t\t!documentIsHTML,\n\t\tresults,\n\t\t!context || rsibling.test( selector ) && testContext( context.parentNode ) || context\n\t);\n\treturn results;\n};\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome 14-35+\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = !!hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n\t// Should return 1, but returns 4 (following)\n\treturn div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n\tdiv.innerHTML = \"<a href='#'></a>\";\n\treturn div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n\taddHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n\t\tif ( !isXML ) {\n\t\t\treturn elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n\tdiv.innerHTML = \"<input/>\";\n\tdiv.firstChild.setAttribute( \"value\", \"\" );\n\treturn div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n\taddHandle( \"value\", function( elem, name, isXML ) {\n\t\tif ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n\t\t\treturn elem.defaultValue;\n\t\t}\n\t});\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n\treturn div.getAttribute(\"disabled\") == null;\n}) ) {\n\taddHandle( booleans, function( elem, name, isXML ) {\n\t\tvar val;\n\t\tif ( !isXML ) {\n\t\t\treturn elem[ name ] === true ? name.toLowerCase() :\n\t\t\t\t\t(val = elem.getAttributeNode( name )) && val.specified ?\n\t\t\t\t\tval.value :\n\t\t\t\tnull;\n\t\t}\n\t});\n}\n\n// EXPOSE\nif ( typeof define === \"function\" && define.amd ) {\n\tdefine(function() { return Sizzle; });\n// Sizzle requires that there be a global window in Common-JS like environments\n} else if ( typeof module !== \"undefined\" && module.exports ) {\n\tmodule.exports = Sizzle;\n} else {\n\twindow.Sizzle = Sizzle;\n}\n// EXPOSE\n\n})( window );\n"]},"hash":"46d80396d145635b885db6f8b98d7dfd21727673"}
