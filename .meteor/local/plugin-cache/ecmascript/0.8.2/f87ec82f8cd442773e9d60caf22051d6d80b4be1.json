{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","filenameRelative":"packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/vendor/jquery/src/deferred.js.map","sourceFileName":"packages/zurb:foundation-sites/vendor/jquery/src/deferred.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"deferred"},"ignored":false,"code":"define([\"./core\", \"./var/slice\", \"./callbacks\"], function (jQuery, slice) {\n\tjQuery.extend({\n\t\tDeferred: function (func) {\n\t\t\tvar tuples = [// action, add listener, listener list, final state\n\t\t\t[\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", jQuery.Callbacks(\"memory\")]],\n\t\t\t    state = \"pending\",\n\t\t\t    promise = {\n\t\t\t\tstate: function () {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function () {\n\t\t\t\t\tdeferred.done(arguments).fail(arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function () /* fnDone, fnFail, fnProgress */{\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function (newDefer) {\n\t\t\t\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction(fns[i]) && fns[i]; // deferred[ done | fail | progress ] for forwarding actions to newDefer\n\n\t\t\t\t\t\t\tdeferred[tuple[1]](function () {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply(this, arguments);\n\n\t\t\t\t\t\t\t\tif (returned && jQuery.isFunction(returned.promise)) {\n\t\t\t\t\t\t\t\t\treturned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[tuple[0] + \"With\"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function (obj) {\n\t\t\t\t\treturn obj != null ? jQuery.extend(obj, promise) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\t    deferred = {}; // Keep pipe for back-compat\n\n\t\t\tpromise.pipe = promise.then; // Add list-specific methods\n\n\t\t\tjQuery.each(tuples, function (i, tuple) {\n\t\t\t\tvar list = tuple[2],\n\t\t\t\t    stateString = tuple[3]; // promise[ done | fail | progress ] = list.add\n\n\t\t\t\tpromise[tuple[1]] = list.add; // Handle state\n\n\t\t\t\tif (stateString) {\n\t\t\t\t\tlist.add(function () {\n\t\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\t\tstate = stateString; // [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t\t}, tuples[i ^ 1][2].disable, tuples[2][2].lock);\n\t\t\t\t} // deferred[ resolve | reject | notify ]\n\n\n\t\t\t\tdeferred[tuple[0]] = function () {\n\t\t\t\t\tdeferred[tuple[0] + \"With\"](this === deferred ? promise : this, arguments);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\n\t\t\t\tdeferred[tuple[0] + \"With\"] = list.fireWith;\n\t\t\t}); // Make the deferred a promise\n\n\t\t\tpromise.promise(deferred); // Call given func if any\n\n\t\t\tif (func) {\n\t\t\t\tfunc.call(deferred, deferred);\n\t\t\t} // All done!\n\n\n\t\t\treturn deferred;\n\t\t},\n\t\t// Deferred helper\n\t\twhen: function (subordinate /* , ..., subordinateN */) {\n\t\t\tvar i = 0,\n\t\t\t    resolveValues = slice.call(arguments),\n\t\t\t    length = resolveValues.length,\n\t\t\t    // the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,\n\t\t\t    // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\t\t\t    // Update function for both resolve and progress values\n\t\t\tupdateFunc = function (i, contexts, values) {\n\t\t\t\treturn function (value) {\n\t\t\t\t\tcontexts[i] = this;\n\t\t\t\t\tvalues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\n\t\t\t\t\tif (values === progressValues) {\n\t\t\t\t\t\tdeferred.notifyWith(contexts, values);\n\t\t\t\t\t} else if (! --remaining) {\n\t\t\t\t\t\tdeferred.resolveWith(contexts, values);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\t\t\t    progressValues,\n\t\t\t    progressContexts,\n\t\t\t    resolveContexts; // Add listeners to Deferred subordinates; treat others as resolved\n\n\n\t\t\tif (length > 1) {\n\t\t\t\tprogressValues = new Array(length);\n\t\t\t\tprogressContexts = new Array(length);\n\t\t\t\tresolveContexts = new Array(length);\n\n\t\t\t\tfor (; i < length; i++) {\n\t\t\t\t\tif (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {\n\t\t\t\t\t\tresolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));\n\t\t\t\t\t} else {\n\t\t\t\t\t\t--remaining;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} // If we're not waiting on anything, resolve the master\n\n\n\t\t\tif (!remaining) {\n\t\t\t\tdeferred.resolveWith(resolveContexts, resolveValues);\n\t\t\t}\n\n\t\t\treturn deferred.promise();\n\t\t}\n\t});\n\treturn jQuery;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/vendor/jquery/src/deferred.js"],"names":["define","jQuery","slice","extend","Deferred","func","tuples","Callbacks","state","promise","always","deferred","done","arguments","fail","then","fns","newDefer","each","i","tuple","fn","isFunction","returned","apply","resolve","reject","progress","notify","obj","pipe","list","stateString","add","disable","lock","fireWith","call","when","subordinate","resolveValues","length","remaining","updateFunc","contexts","values","value","progressValues","notifyWith","resolveWith","progressContexts","resolveContexts","Array"],"mappings":"AAAAA,OAAO,CACN,QADM,EAEN,aAFM,EAGN,aAHM,CAAP,EAIG,UAAUC,MAAV,EAAkBC,KAAlB,EAA0B;AAE7BD,QAAOE,MAAP,CAAc;AAEbC,YAAU,UAAUC,IAAV,EAAiB;AAC1B,OAAIC,SAAS,CACX;AACA,IAAE,SAAF,EAAa,MAAb,EAAqBL,OAAOM,SAAP,CAAiB,aAAjB,CAArB,EAAsD,UAAtD,CAFW,EAGX,CAAE,QAAF,EAAY,MAAZ,EAAoBN,OAAOM,SAAP,CAAiB,aAAjB,CAApB,EAAqD,UAArD,CAHW,EAIX,CAAE,QAAF,EAAY,UAAZ,EAAwBN,OAAOM,SAAP,CAAiB,QAAjB,CAAxB,CAJW,CAAb;AAAA,OAMCC,QAAQ,SANT;AAAA,OAOCC,UAAU;AACTD,WAAO,YAAW;AACjB,YAAOA,KAAP;AACA,KAHQ;AAITE,YAAQ,YAAW;AAClBC,cAASC,IAAT,CAAeC,SAAf,EAA2BC,IAA3B,CAAiCD,SAAjC;AACA,YAAO,IAAP;AACA,KAPQ;AAQTE,UAAM,YAAU,gCAAmC;AAClD,SAAIC,MAAMH,SAAV;AACA,YAAOZ,OAAOG,QAAP,CAAgB,UAAUa,QAAV,EAAqB;AAC3ChB,aAAOiB,IAAP,CAAaZ,MAAb,EAAqB,UAAUa,CAAV,EAAaC,KAAb,EAAqB;AACzC,WAAIC,KAAKpB,OAAOqB,UAAP,CAAmBN,IAAKG,CAAL,CAAnB,KAAiCH,IAAKG,CAAL,CAA1C,CADyC,CAEzC;;AACAR,gBAAUS,MAAM,CAAN,CAAV,EAAqB,YAAW;AAC/B,YAAIG,WAAWF,MAAMA,GAAGG,KAAH,CAAU,IAAV,EAAgBX,SAAhB,CAArB;;AACA,YAAKU,YAAYtB,OAAOqB,UAAP,CAAmBC,SAASd,OAA5B,CAAjB,EAAyD;AACxDc,kBAASd,OAAT,GACEG,IADF,CACQK,SAASQ,OADjB,EAEEX,IAFF,CAEQG,SAASS,MAFjB,EAGEC,QAHF,CAGYV,SAASW,MAHrB;AAIA,SALD,MAKO;AACNX,kBAAUG,MAAO,CAAP,IAAa,MAAvB,EAAiC,SAASX,OAAT,GAAmBQ,SAASR,OAAT,EAAnB,GAAwC,IAAzE,EAA+EY,KAAK,CAAEE,QAAF,CAAL,GAAoBV,SAAnG;AACA;AACD,QAVD;AAWA,OAdD;AAeAG,YAAM,IAAN;AACA,MAjBM,EAiBJP,OAjBI,EAAP;AAkBA,KA5BQ;AA6BT;AACA;AACAA,aAAS,UAAUoB,GAAV,EAAgB;AACxB,YAAOA,OAAO,IAAP,GAAc5B,OAAOE,MAAP,CAAe0B,GAAf,EAAoBpB,OAApB,CAAd,GAA8CA,OAArD;AACA;AAjCQ,IAPX;AAAA,OA0CCE,WAAW,EA1CZ,CAD0B,CA6C1B;;AACAF,WAAQqB,IAAR,GAAerB,QAAQM,IAAvB,CA9C0B,CAgD1B;;AACAd,UAAOiB,IAAP,CAAaZ,MAAb,EAAqB,UAAUa,CAAV,EAAaC,KAAb,EAAqB;AACzC,QAAIW,OAAOX,MAAO,CAAP,CAAX;AAAA,QACCY,cAAcZ,MAAO,CAAP,CADf,CADyC,CAIzC;;AACAX,YAASW,MAAM,CAAN,CAAT,IAAsBW,KAAKE,GAA3B,CALyC,CAOzC;;AACA,QAAKD,WAAL,EAAmB;AAClBD,UAAKE,GAAL,CAAS,YAAW;AACnB;AACAzB,cAAQwB,WAAR,CAFmB,CAIpB;AACC,MALD,EAKG1B,OAAQa,IAAI,CAAZ,EAAiB,CAAjB,EAAqBe,OALxB,EAKiC5B,OAAQ,CAAR,EAAa,CAAb,EAAiB6B,IALlD;AAMA,KAfwC,CAiBzC;;;AACAxB,aAAUS,MAAM,CAAN,CAAV,IAAuB,YAAW;AACjCT,cAAUS,MAAM,CAAN,IAAW,MAArB,EAA+B,SAAST,QAAT,GAAoBF,OAApB,GAA8B,IAA7D,EAAmEI,SAAnE;AACA,YAAO,IAAP;AACA,KAHD;;AAIAF,aAAUS,MAAM,CAAN,IAAW,MAArB,IAAgCW,KAAKK,QAArC;AACA,IAvBD,EAjD0B,CA0E1B;;AACA3B,WAAQA,OAAR,CAAiBE,QAAjB,EA3E0B,CA6E1B;;AACA,OAAKN,IAAL,EAAY;AACXA,SAAKgC,IAAL,CAAW1B,QAAX,EAAqBA,QAArB;AACA,IAhFyB,CAkF1B;;;AACA,UAAOA,QAAP;AACA,GAtFY;AAwFb;AACA2B,QAAM,UAAUC,WAAV,CAAsB,yBAAtB,EAAkD;AACvD,OAAIpB,IAAI,CAAR;AAAA,OACCqB,gBAAgBtC,MAAMmC,IAAN,CAAYxB,SAAZ,CADjB;AAAA,OAEC4B,SAASD,cAAcC,MAFxB;AAAA,OAIC;AACAC,eAAYD,WAAW,CAAX,IAAkBF,eAAetC,OAAOqB,UAAP,CAAmBiB,YAAY9B,OAA/B,CAAjC,GAA8EgC,MAA9E,GAAuF,CALpG;AAAA,OAOC;AACA9B,cAAW+B,cAAc,CAAd,GAAkBH,WAAlB,GAAgCtC,OAAOG,QAAP,EAR5C;AAAA,OAUC;AACAuC,gBAAa,UAAUxB,CAAV,EAAayB,QAAb,EAAuBC,MAAvB,EAAgC;AAC5C,WAAO,UAAUC,KAAV,EAAkB;AACxBF,cAAUzB,CAAV,IAAgB,IAAhB;AACA0B,YAAQ1B,CAAR,IAAcN,UAAU4B,MAAV,GAAmB,CAAnB,GAAuBvC,MAAMmC,IAAN,CAAYxB,SAAZ,CAAvB,GAAiDiC,KAA/D;;AACA,SAAKD,WAAWE,cAAhB,EAAiC;AAChCpC,eAASqC,UAAT,CAAqBJ,QAArB,EAA+BC,MAA/B;AACA,MAFD,MAEO,IAAK,CAAG,GAAEH,SAAV,EAAwB;AAC9B/B,eAASsC,WAAT,CAAsBL,QAAtB,EAAgCC,MAAhC;AACA;AACD,KARD;AASA,IArBF;AAAA,OAuBCE,cAvBD;AAAA,OAuBiBG,gBAvBjB;AAAA,OAuBmCC,eAvBnC,CADuD,CA0BvD;;;AACA,OAAKV,SAAS,CAAd,EAAkB;AACjBM,qBAAiB,IAAIK,KAAJ,CAAWX,MAAX,CAAjB;AACAS,uBAAmB,IAAIE,KAAJ,CAAWX,MAAX,CAAnB;AACAU,sBAAkB,IAAIC,KAAJ,CAAWX,MAAX,CAAlB;;AACA,WAAQtB,IAAIsB,MAAZ,EAAoBtB,GAApB,EAA0B;AACzB,SAAKqB,cAAerB,CAAf,KAAsBlB,OAAOqB,UAAP,CAAmBkB,cAAerB,CAAf,EAAmBV,OAAtC,CAA3B,EAA6E;AAC5E+B,oBAAerB,CAAf,EAAmBV,OAAnB,GACEG,IADF,CACQ+B,WAAYxB,CAAZ,EAAegC,eAAf,EAAgCX,aAAhC,CADR,EAEE1B,IAFF,CAEQH,SAASe,MAFjB,EAGEC,QAHF,CAGYgB,WAAYxB,CAAZ,EAAe+B,gBAAf,EAAiCH,cAAjC,CAHZ;AAIA,MALD,MAKO;AACN,QAAEL,SAAF;AACA;AACD;AACD,IAzCsD,CA2CvD;;;AACA,OAAK,CAACA,SAAN,EAAkB;AACjB/B,aAASsC,WAAT,CAAsBE,eAAtB,EAAuCX,aAAvC;AACA;;AAED,UAAO7B,SAASF,OAAT,EAAP;AACA;AA1IY,EAAd;AA6IA,QAAOR,MAAP;AACC,CApJD","file":"packages/zurb:foundation-sites/vendor/jquery/src/deferred.js.map","sourcesContent":["define([\n\t\"./core\",\n\t\"./var/slice\",\n\t\"./callbacks\"\n], function( jQuery, slice ) {\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ](function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ]\n\t\t\tdeferred[ tuple[0] ] = function() {\n\t\t\t\tdeferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// Add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n\nreturn jQuery;\n});\n"]},"hash":"f87ec82f8cd442773e9d60caf22051d6d80b4be1"}
