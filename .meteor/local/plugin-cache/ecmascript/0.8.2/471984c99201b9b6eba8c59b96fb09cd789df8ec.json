{"metadata":{"usedHelpers":["inherits","possibleConstructorReturn","classCallCheck","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"jquery","imported":["default"],"specifiers":[{"kind":"named","imported":"default","local":"$"}]},{"source":"./foundation.util.core","imported":["GetYoDigits"],"specifiers":[{"kind":"named","imported":"GetYoDigits","local":"GetYoDigits"}]},{"source":"./foundation.util.mediaQuery","imported":["MediaQuery"],"specifiers":[{"kind":"named","imported":"MediaQuery","local":"MediaQuery"}]},{"source":"./foundation.plugin","imported":["Plugin"],"specifiers":[{"kind":"named","imported":"Plugin","local":"Plugin"}]},{"source":"./foundation.util.triggers","imported":["Triggers"],"specifiers":[{"kind":"named","imported":"Triggers","local":"Triggers"}]}],"exports":{"exported":["Sticky"],"specifiers":[{"kind":"local","local":"Sticky","exported":"Sticky"}]}}},"options":{"filename":"packages/zurb:foundation-sites/js/foundation.sticky.js","filenameRelative":"packages/zurb:foundation-sites/js/foundation.sticky.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/js/foundation.sticky.js.map","sourceFileName":"packages/zurb:foundation-sites/js/foundation.sticky.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"foundation.sticky"},"ignored":false,"code":"'use strict';\n\nvar _classCallCheck2 = require(\"babel-runtime/helpers/classCallCheck\");\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _possibleConstructorReturn2 = require(\"babel-runtime/helpers/possibleConstructorReturn\");\n\nvar _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);\n\nvar _inherits2 = require(\"babel-runtime/helpers/inherits\");\n\nvar _inherits3 = _interopRequireDefault(_inherits2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar module1 = module;\nmodule1.export({\n  Sticky: function () {\n    return Sticky;\n  }\n});\nvar $ = void 0;\nmodule1.watch(require(\"jquery\"), {\n  \"default\": function (v) {\n    $ = v;\n  }\n}, 0);\nvar GetYoDigits = void 0;\nmodule1.watch(require(\"./foundation.util.core\"), {\n  GetYoDigits: function (v) {\n    GetYoDigits = v;\n  }\n}, 1);\nvar MediaQuery = void 0;\nmodule1.watch(require(\"./foundation.util.mediaQuery\"), {\n  MediaQuery: function (v) {\n    MediaQuery = v;\n  }\n}, 2);\nvar Plugin = void 0;\nmodule1.watch(require(\"./foundation.plugin\"), {\n  Plugin: function (v) {\n    Plugin = v;\n  }\n}, 3);\nvar Triggers = void 0;\nmodule1.watch(require(\"./foundation.util.triggers\"), {\n  Triggers: function (v) {\n    Triggers = v;\n  }\n}, 4);\n\n/**\n * Sticky module.\n * @module foundation.sticky\n * @requires foundation.util.triggers\n * @requires foundation.util.mediaQuery\n */var Sticky = function (_Plugin) {\n  (0, _inherits3.default)(Sticky, _Plugin);\n\n  function Sticky() {\n    (0, _classCallCheck3.default)(this, Sticky);\n    return (0, _possibleConstructorReturn3.default)(this, _Plugin.apply(this, arguments));\n  }\n\n  /**\n   * Creates a new instance of a sticky thing.\n   * @class\n   * @name Sticky\n   * @param {jQuery} element - jQuery object to make sticky.\n   * @param {Object} options - options object passed when creating the element programmatically.\n   */Sticky.prototype._setup = function () {\n    function _setup(element, options) {\n      this.$element = element;\n      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);\n      this.className = 'Sticky'; // ie9 back compat\n      // Triggers init is idempotent, just need to make sure it is initialized\n\n      Triggers.init($);\n\n      this._init();\n    }\n\n    return _setup;\n  }(); /**\n        * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\n        * @function\n        * @private\n        */\n\n  Sticky.prototype._init = function () {\n    function _init() {\n      MediaQuery._init();\n\n      var $parent = this.$element.parent('[data-sticky-container]'),\n          id = this.$element[0].id || GetYoDigits(6, 'sticky'),\n          _this = this;\n\n      if ($parent.length) {\n        this.$container = $parent;\n      } else {\n        this.wasWrapped = true;\n        this.$element.wrap(this.options.container);\n        this.$container = this.$element.parent();\n      }\n\n      this.$container.addClass(this.options.containerClass);\n      this.$element.addClass(this.options.stickyClass).attr({\n        'data-resize': id,\n        'data-mutate': id\n      });\n\n      if (this.options.anchor !== '') {\n        $('#' + _this.options.anchor).attr({\n          'data-mutate': id\n        });\n      }\n\n      this.scrollCount = this.options.checkEvery;\n      this.isStuck = false;\n      $(window).one('load.zf.sticky', function () {\n        //We calculate the container height to have correct values for anchor points offset calculation.\n        _this.containerHeight = _this.$element.css(\"display\") == \"none\" ? 0 : _this.$element[0].getBoundingClientRect().height;\n\n        _this.$container.css('height', _this.containerHeight);\n\n        _this.elemHeight = _this.containerHeight;\n\n        if (_this.options.anchor !== '') {\n          _this.$anchor = $('#' + _this.options.anchor);\n        } else {\n          _this._parsePoints();\n        }\n\n        _this._setSizes(function () {\n          var scroll = window.pageYOffset;\n\n          _this._calc(false, scroll); //Unstick the element will ensure that proper classes are set.\n\n\n          if (!_this.isStuck) {\n            _this._removeSticky(scroll >= _this.topPoint ? false : true);\n          }\n        });\n\n        _this._events(id.split('-').reverse().join('-'));\n      });\n    }\n\n    return _init;\n  }(); /**\n        * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\n        * @function\n        * @private\n        */\n\n  Sticky.prototype._parsePoints = function () {\n    function _parsePoints() {\n      var top = this.options.topAnchor == \"\" ? 1 : this.options.topAnchor,\n          btm = this.options.btmAnchor == \"\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\n          pts = [top, btm],\n          breaks = {};\n\n      for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\n        var pt;\n\n        if (typeof pts[i] === 'number') {\n          pt = pts[i];\n        } else {\n          var place = pts[i].split(':'),\n              anchor = $(\"#\" + place[0]);\n          pt = anchor.offset().top;\n\n          if (place[1] && place[1].toLowerCase() === 'bottom') {\n            pt += anchor[0].getBoundingClientRect().height;\n          }\n        }\n\n        breaks[i] = pt;\n      }\n\n      this.points = breaks;\n      return;\n    }\n\n    return _parsePoints;\n  }(); /**\n        * Adds event handlers for the scrolling element.\n        * @private\n        * @param {String} id - pseudo-random id for unique scroll event listener.\n        */\n\n  Sticky.prototype._events = function () {\n    function _events(id) {\n      var _this = this,\n          scrollListener = this.scrollListener = \"scroll.zf.\" + id;\n\n      if (this.isOn) {\n        return;\n      }\n\n      if (this.canStick) {\n        this.isOn = true;\n        $(window).off(scrollListener).on(scrollListener, function (e) {\n          if (_this.scrollCount === 0) {\n            _this.scrollCount = _this.options.checkEvery;\n\n            _this._setSizes(function () {\n              _this._calc(false, window.pageYOffset);\n            });\n          } else {\n            _this.scrollCount--;\n\n            _this._calc(false, window.pageYOffset);\n          }\n        });\n      }\n\n      this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\n        _this._eventsHandler(id);\n      });\n      this.$element.on('mutateme.zf.trigger', function (e, el) {\n        _this._eventsHandler(id);\n      });\n\n      if (this.$anchor) {\n        this.$anchor.on('mutateme.zf.trigger', function (e, el) {\n          _this._eventsHandler(id);\n        });\n      }\n    }\n\n    return _events;\n  }(); /**\n        * Handler for events.\n        * @private\n        * @param {String} id - pseudo-random id for unique scroll event listener.\n        */\n\n  Sticky.prototype._eventsHandler = function () {\n    function _eventsHandler(id) {\n      var _this = this,\n          scrollListener = this.scrollListener = \"scroll.zf.\" + id;\n\n      _this._setSizes(function () {\n        _this._calc(false);\n\n        if (_this.canStick) {\n          if (!_this.isOn) {\n            _this._events(id);\n          }\n        } else if (_this.isOn) {\n          _this._pauseListeners(scrollListener);\n        }\n      });\n    }\n\n    return _eventsHandler;\n  }(); /**\n        * Removes event handlers for scroll and change events on anchor.\n        * @fires Sticky#pause\n        * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\n        */\n\n  Sticky.prototype._pauseListeners = function () {\n    function _pauseListeners(scrollListener) {\n      this.isOn = false;\n      $(window).off(scrollListener); /**\n                                      * Fires when the plugin is paused due to resize event shrinking the view.\n                                      * @event Sticky#pause\n                                      * @private\n                                      */\n      this.$element.trigger('pause.zf.sticky');\n    }\n\n    return _pauseListeners;\n  }(); /**\n        * Called on every `scroll` event and on `_init`\n        * fires functions based on booleans and cached values\n        * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\n        * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\n        */\n\n  Sticky.prototype._calc = function () {\n    function _calc(checkSizes, scroll) {\n      if (checkSizes) {\n        this._setSizes();\n      }\n\n      if (!this.canStick) {\n        if (this.isStuck) {\n          this._removeSticky(true);\n        }\n\n        return false;\n      }\n\n      if (!scroll) {\n        scroll = window.pageYOffset;\n      }\n\n      if (scroll >= this.topPoint) {\n        if (scroll <= this.bottomPoint) {\n          if (!this.isStuck) {\n            this._setSticky();\n          }\n        } else {\n          if (this.isStuck) {\n            this._removeSticky(false);\n          }\n        }\n      } else {\n        if (this.isStuck) {\n          this._removeSticky(true);\n        }\n      }\n    }\n\n    return _calc;\n  }(); /**\n        * Causes the $element to become stuck.\n        * Adds `position: fixed;`, and helper classes.\n        * @fires Sticky#stuckto\n        * @function\n        * @private\n        */\n\n  Sticky.prototype._setSticky = function () {\n    function _setSticky() {\n      var _this = this,\n          stickTo = this.options.stickTo,\n          mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\n          notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\n          css = {};\n\n      css[mrgn] = this.options[mrgn] + \"em\";\n      css[stickTo] = 0;\n      css[notStuckTo] = 'auto';\n      this.isStuck = true;\n      this.$element.removeClass(\"is-anchored is-at-\" + notStuckTo).addClass(\"is-stuck is-at-\" + stickTo).css(css) /**\n                                                                                                                   * Fires when the $element has become `position: fixed;`\n                                                                                                                   * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\n                                                                                                                   * @event Sticky#stuckto\n                                                                                                                   */.trigger(\"sticky.zf.stuckto:\" + stickTo);\n      this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function () {\n        _this._setSizes();\n      });\n    }\n\n    return _setSticky;\n  }(); /**\n        * Causes the $element to become unstuck.\n        * Removes `position: fixed;`, and helper classes.\n        * Adds other helper classes.\n        * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\n        * @fires Sticky#unstuckfrom\n        * @private\n        */\n\n  Sticky.prototype._removeSticky = function () {\n    function _removeSticky(isTop) {\n      var stickTo = this.options.stickTo,\n          stickToTop = stickTo === 'top',\n          css = {},\n          anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n          mrgn = stickToTop ? 'marginTop' : 'marginBottom',\n          notStuckTo = stickToTop ? 'bottom' : 'top',\n          topOrBottom = isTop ? 'top' : 'bottom';\n      css[mrgn] = 0;\n      css['bottom'] = 'auto';\n\n      if (isTop) {\n        css['top'] = 0;\n      } else {\n        css['top'] = anchorPt;\n      }\n\n      this.isStuck = false;\n      this.$element.removeClass(\"is-stuck is-at-\" + stickTo).addClass(\"is-anchored is-at-\" + topOrBottom).css(css) /**\n                                                                                                                    * Fires when the $element has become anchored.\n                                                                                                                    * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\n                                                                                                                    * @event Sticky#unstuckfrom\n                                                                                                                    */.trigger(\"sticky.zf.unstuckfrom:\" + topOrBottom);\n    }\n\n    return _removeSticky;\n  }(); /**\n        * Sets the $element and $container sizes for plugin.\n        * Calls `_setBreakPoints`.\n        * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\n        * @private\n        */\n\n  Sticky.prototype._setSizes = function () {\n    function _setSizes(cb) {\n      this.canStick = MediaQuery.is(this.options.stickyOn);\n\n      if (!this.canStick) {\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      }\n\n      var _this = this,\n          newElemWidth = this.$container[0].getBoundingClientRect().width,\n          comp = window.getComputedStyle(this.$container[0]),\n          pdngl = parseInt(comp['padding-left'], 10),\n          pdngr = parseInt(comp['padding-right'], 10);\n\n      if (this.$anchor && this.$anchor.length) {\n        this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\n      } else {\n        this._parsePoints();\n      }\n\n      this.$element.css({\n        'max-width': newElemWidth - pdngl - pdngr + \"px\"\n      });\n      var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\n\n      if (this.$element.css(\"display\") == \"none\") {\n        newContainerHeight = 0;\n      }\n\n      this.containerHeight = newContainerHeight;\n      this.$container.css({\n        height: newContainerHeight\n      });\n      this.elemHeight = newContainerHeight;\n\n      if (!this.isStuck) {\n        if (this.$element.hasClass('is-at-bottom')) {\n          var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\n          this.$element.css('top', anchorPt);\n        }\n      }\n\n      this._setBreakPoints(newContainerHeight, function () {\n        if (cb && typeof cb === 'function') {\n          cb();\n        }\n      });\n    }\n\n    return _setSizes;\n  }(); /**\n        * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\n        * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\n        * @param {Function} cb - optional callback function to be called on completion.\n        * @private\n        */\n\n  Sticky.prototype._setBreakPoints = function () {\n    function _setBreakPoints(elemHeight, cb) {\n      if (!this.canStick) {\n        if (cb && typeof cb === 'function') {\n          cb();\n        } else {\n          return false;\n        }\n      }\n\n      var mTop = emCalc(this.options.marginTop),\n          mBtm = emCalc(this.options.marginBottom),\n          topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\n          bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\n          // topPoint = this.$anchor.offset().top || this.points[0],\n      // bottomPoint = topPoint + this.anchorHeight || this.points[1],\n      winHeight = window.innerHeight;\n\n      if (this.options.stickTo === 'top') {\n        topPoint -= mTop;\n        bottomPoint -= elemHeight + mTop;\n      } else if (this.options.stickTo === 'bottom') {\n        topPoint -= winHeight - (elemHeight + mBtm);\n        bottomPoint -= winHeight - mBtm;\n      } else {//this would be the stickTo: both option... tricky\n      }\n\n      this.topPoint = topPoint;\n      this.bottomPoint = bottomPoint;\n\n      if (cb && typeof cb === 'function') {\n        cb();\n      }\n    }\n\n    return _setBreakPoints;\n  }(); /**\n        * Destroys the current sticky element.\n        * Resets the element to the top position first.\n        * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\n        * @function\n        */\n\n  Sticky.prototype._destroy = function () {\n    function _destroy() {\n      this._removeSticky(true);\n\n      this.$element.removeClass(this.options.stickyClass + \" is-anchored is-at-top\").css({\n        height: '',\n        top: '',\n        bottom: '',\n        'max-width': ''\n      }).off('resizeme.zf.trigger').off('mutateme.zf.trigger');\n\n      if (this.$anchor && this.$anchor.length) {\n        this.$anchor.off('change.zf.sticky');\n      }\n\n      $(window).off(this.scrollListener);\n\n      if (this.wasWrapped) {\n        this.$element.unwrap();\n      } else {\n        this.$container.removeClass(this.options.containerClass).css({\n          height: ''\n        });\n      }\n    }\n\n    return _destroy;\n  }();\n\n  return Sticky;\n}(Plugin);\n\nSticky.defaults = {\n  /**\n   * Customizable container template. Add your own classes for styling and sizing.\n   * @option\n   * @type {string}\n   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\n   */container: '<div data-sticky-container></div>',\n  /**\n   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\n   * @option\n   * @type {string}\n   * @default 'top'\n   */stickTo: 'top',\n  /**\n   * If anchored to a single element, the id of that element.\n   * @option\n   * @type {string}\n   * @default ''\n   */anchor: '',\n  /**\n   * If using more than one element as anchor points, the id of the top anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */topAnchor: '',\n  /**\n   * If using more than one element as anchor points, the id of the bottom anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */btmAnchor: '',\n  /**\n   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */marginTop: 1,\n  /**\n   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */marginBottom: 1,\n  /**\n   * Breakpoint string that is the minimum screen size an element should become sticky.\n   * @option\n   * @type {string}\n   * @default 'medium'\n   */stickyOn: 'medium',\n  /**\n   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\n   * @option\n   * @type {string}\n   * @default 'sticky'\n   */stickyClass: 'sticky',\n  /**\n   * Class applied to sticky container. Foundation defaults to `sticky-container`.\n   * @option\n   * @type {string}\n   * @default 'sticky-container'\n   */containerClass: 'sticky-container',\n  /**\n   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\n   * @option\n   * @type {number}\n   * @default -1\n   */checkEvery: -1\n}; /**\n    * Helper function to calculate em values\n    * @param Number {em} - number of em's to calculate into pixels\n    */\n\nfunction emCalc(em) {\n  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\n}","map":{"version":3,"sources":["packages/zurb:foundation-sites/js/foundation.sticky.js"],"names":["module1","module","export","Sticky","$","watch","require","v","GetYoDigits","MediaQuery","Plugin","Triggers","_setup","element","options","$element","extend","defaults","data","className","init","_init","$parent","parent","id","_this","length","$container","wasWrapped","wrap","container","addClass","containerClass","stickyClass","attr","anchor","scrollCount","checkEvery","isStuck","window","one","containerHeight","css","getBoundingClientRect","height","elemHeight","$anchor","_parsePoints","_setSizes","scroll","pageYOffset","_calc","_removeSticky","topPoint","_events","split","reverse","join","top","topAnchor","btm","btmAnchor","document","documentElement","scrollHeight","pts","breaks","i","len","pt","place","offset","toLowerCase","points","scrollListener","isOn","canStick","off","on","e","el","_eventsHandler","_pauseListeners","trigger","checkSizes","bottomPoint","_setSticky","stickTo","mrgn","notStuckTo","removeClass","isTop","stickToTop","anchorPt","anchorHeight","topOrBottom","cb","is","stickyOn","newElemWidth","width","comp","getComputedStyle","pdngl","parseInt","pdngr","newContainerHeight","hasClass","_setBreakPoints","mTop","emCalc","marginTop","mBtm","marginBottom","winHeight","innerHeight","_destroy","bottom","unwrap","em","body","fontSize"],"mappings":"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","file":"packages/zurb:foundation-sites/js/foundation.sticky.js.map","sourcesContent":["'use strict';\n\nimport $ from 'jquery';\nimport { GetYoDigits } from './foundation.util.core';\nimport { MediaQuery } from './foundation.util.mediaQuery';\nimport { Plugin } from './foundation.plugin';\nimport { Triggers } from './foundation.util.triggers';\n\n/**\n * Sticky module.\n * @module foundation.sticky\n * @requires foundation.util.triggers\n * @requires foundation.util.mediaQuery\n */\n\nclass Sticky extends Plugin {\n  /**\n   * Creates a new instance of a sticky thing.\n   * @class\n   * @name Sticky\n   * @param {jQuery} element - jQuery object to make sticky.\n   * @param {Object} options - options object passed when creating the element programmatically.\n   */\n  _setup(element, options) {\n    this.$element = element;\n    this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);\n    this.className = 'Sticky'; // ie9 back compat\n\n    // Triggers init is idempotent, just need to make sure it is initialized\n    Triggers.init($);\n\n    this._init();\n  }\n\n  /**\n   * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\n   * @function\n   * @private\n   */\n  _init() {\n    MediaQuery._init();\n\n    var $parent = this.$element.parent('[data-sticky-container]'),\n        id = this.$element[0].id || GetYoDigits(6, 'sticky'),\n        _this = this;\n\n    if($parent.length){\n      this.$container = $parent;\n    } else {\n      this.wasWrapped = true;\n      this.$element.wrap(this.options.container);\n      this.$container = this.$element.parent();\n    }\n    this.$container.addClass(this.options.containerClass);\n\n    this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id, 'data-mutate': id });\n    if (this.options.anchor !== '') {\n        $('#' + _this.options.anchor).attr({ 'data-mutate': id });\n    }\n\n    this.scrollCount = this.options.checkEvery;\n    this.isStuck = false;\n    $(window).one('load.zf.sticky', function(){\n      //We calculate the container height to have correct values for anchor points offset calculation.\n      _this.containerHeight = _this.$element.css(\"display\") == \"none\" ? 0 : _this.$element[0].getBoundingClientRect().height;\n      _this.$container.css('height', _this.containerHeight);\n      _this.elemHeight = _this.containerHeight;\n      if(_this.options.anchor !== ''){\n        _this.$anchor = $('#' + _this.options.anchor);\n      }else{\n        _this._parsePoints();\n      }\n\n      _this._setSizes(function(){\n        var scroll = window.pageYOffset;\n        _this._calc(false, scroll);\n        //Unstick the element will ensure that proper classes are set.\n        if (!_this.isStuck) {\n          _this._removeSticky((scroll >= _this.topPoint) ? false : true);\n        }\n      });\n      _this._events(id.split('-').reverse().join('-'));\n    });\n  }\n\n  /**\n   * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\n   * @function\n   * @private\n   */\n  _parsePoints() {\n    var top = this.options.topAnchor == \"\" ? 1 : this.options.topAnchor,\n        btm = this.options.btmAnchor== \"\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\n        pts = [top, btm],\n        breaks = {};\n    for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\n      var pt;\n      if (typeof pts[i] === 'number') {\n        pt = pts[i];\n      } else {\n        var place = pts[i].split(':'),\n            anchor = $(`#${place[0]}`);\n\n        pt = anchor.offset().top;\n        if (place[1] && place[1].toLowerCase() === 'bottom') {\n          pt += anchor[0].getBoundingClientRect().height;\n        }\n      }\n      breaks[i] = pt;\n    }\n\n\n    this.points = breaks;\n    return;\n  }\n\n  /**\n   * Adds event handlers for the scrolling element.\n   * @private\n   * @param {String} id - pseudo-random id for unique scroll event listener.\n   */\n  _events(id) {\n    var _this = this,\n        scrollListener = this.scrollListener = `scroll.zf.${id}`;\n    if (this.isOn) { return; }\n    if (this.canStick) {\n      this.isOn = true;\n      $(window).off(scrollListener)\n               .on(scrollListener, function(e) {\n                 if (_this.scrollCount === 0) {\n                   _this.scrollCount = _this.options.checkEvery;\n                   _this._setSizes(function() {\n                     _this._calc(false, window.pageYOffset);\n                   });\n                 } else {\n                   _this.scrollCount--;\n                   _this._calc(false, window.pageYOffset);\n                 }\n              });\n    }\n\n    this.$element.off('resizeme.zf.trigger')\n                 .on('resizeme.zf.trigger', function(e, el) {\n                    _this._eventsHandler(id);\n    });\n\n    this.$element.on('mutateme.zf.trigger', function (e, el) {\n        _this._eventsHandler(id);\n    });\n\n    if(this.$anchor) {\n      this.$anchor.on('mutateme.zf.trigger', function (e, el) {\n          _this._eventsHandler(id);\n      });\n    }\n  }\n\n  /**\n   * Handler for events.\n   * @private\n   * @param {String} id - pseudo-random id for unique scroll event listener.\n   */\n  _eventsHandler(id) {\n       var _this = this,\n        scrollListener = this.scrollListener = `scroll.zf.${id}`;\n\n       _this._setSizes(function() {\n       _this._calc(false);\n       if (_this.canStick) {\n         if (!_this.isOn) {\n           _this._events(id);\n         }\n       } else if (_this.isOn) {\n         _this._pauseListeners(scrollListener);\n       }\n     });\n  }\n\n  /**\n   * Removes event handlers for scroll and change events on anchor.\n   * @fires Sticky#pause\n   * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\n   */\n  _pauseListeners(scrollListener) {\n    this.isOn = false;\n    $(window).off(scrollListener);\n\n    /**\n     * Fires when the plugin is paused due to resize event shrinking the view.\n     * @event Sticky#pause\n     * @private\n     */\n     this.$element.trigger('pause.zf.sticky');\n  }\n\n  /**\n   * Called on every `scroll` event and on `_init`\n   * fires functions based on booleans and cached values\n   * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\n   * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\n   */\n  _calc(checkSizes, scroll) {\n    if (checkSizes) { this._setSizes(); }\n\n    if (!this.canStick) {\n      if (this.isStuck) {\n        this._removeSticky(true);\n      }\n      return false;\n    }\n\n    if (!scroll) { scroll = window.pageYOffset; }\n\n    if (scroll >= this.topPoint) {\n      if (scroll <= this.bottomPoint) {\n        if (!this.isStuck) {\n          this._setSticky();\n        }\n      } else {\n        if (this.isStuck) {\n          this._removeSticky(false);\n        }\n      }\n    } else {\n      if (this.isStuck) {\n        this._removeSticky(true);\n      }\n    }\n  }\n\n  /**\n   * Causes the $element to become stuck.\n   * Adds `position: fixed;`, and helper classes.\n   * @fires Sticky#stuckto\n   * @function\n   * @private\n   */\n  _setSticky() {\n    var _this = this,\n        stickTo = this.options.stickTo,\n        mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\n        notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\n        css = {};\n\n    css[mrgn] = `${this.options[mrgn]}em`;\n    css[stickTo] = 0;\n    css[notStuckTo] = 'auto';\n    this.isStuck = true;\n    this.$element.removeClass(`is-anchored is-at-${notStuckTo}`)\n                 .addClass(`is-stuck is-at-${stickTo}`)\n                 .css(css)\n                 /**\n                  * Fires when the $element has become `position: fixed;`\n                  * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\n                  * @event Sticky#stuckto\n                  */\n                 .trigger(`sticky.zf.stuckto:${stickTo}`);\n    this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function() {\n      _this._setSizes();\n    });\n  }\n\n  /**\n   * Causes the $element to become unstuck.\n   * Removes `position: fixed;`, and helper classes.\n   * Adds other helper classes.\n   * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\n   * @fires Sticky#unstuckfrom\n   * @private\n   */\n  _removeSticky(isTop) {\n    var stickTo = this.options.stickTo,\n        stickToTop = stickTo === 'top',\n        css = {},\n        anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n        mrgn = stickToTop ? 'marginTop' : 'marginBottom',\n        notStuckTo = stickToTop ? 'bottom' : 'top',\n        topOrBottom = isTop ? 'top' : 'bottom';\n\n    css[mrgn] = 0;\n\n    css['bottom'] = 'auto';\n    if(isTop) {\n      css['top'] = 0;\n    } else {\n      css['top'] = anchorPt;\n    }\n\n    this.isStuck = false;\n    this.$element.removeClass(`is-stuck is-at-${stickTo}`)\n                 .addClass(`is-anchored is-at-${topOrBottom}`)\n                 .css(css)\n                 /**\n                  * Fires when the $element has become anchored.\n                  * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\n                  * @event Sticky#unstuckfrom\n                  */\n                 .trigger(`sticky.zf.unstuckfrom:${topOrBottom}`);\n  }\n\n  /**\n   * Sets the $element and $container sizes for plugin.\n   * Calls `_setBreakPoints`.\n   * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\n   * @private\n   */\n  _setSizes(cb) {\n    this.canStick = MediaQuery.is(this.options.stickyOn);\n    if (!this.canStick) {\n      if (cb && typeof cb === 'function') { cb(); }\n    }\n    var _this = this,\n        newElemWidth = this.$container[0].getBoundingClientRect().width,\n        comp = window.getComputedStyle(this.$container[0]),\n        pdngl = parseInt(comp['padding-left'], 10),\n        pdngr = parseInt(comp['padding-right'], 10);\n\n    if (this.$anchor && this.$anchor.length) {\n      this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\n    } else {\n      this._parsePoints();\n    }\n\n    this.$element.css({\n      'max-width': `${newElemWidth - pdngl - pdngr}px`\n    });\n\n    var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\n    if (this.$element.css(\"display\") == \"none\") {\n      newContainerHeight = 0;\n    }\n    this.containerHeight = newContainerHeight;\n    this.$container.css({\n      height: newContainerHeight\n    });\n    this.elemHeight = newContainerHeight;\n\n    if (!this.isStuck) {\n      if (this.$element.hasClass('is-at-bottom')) {\n        var anchorPt = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;\n        this.$element.css('top', anchorPt);\n      }\n    }\n\n    this._setBreakPoints(newContainerHeight, function() {\n      if (cb && typeof cb === 'function') { cb(); }\n    });\n  }\n\n  /**\n   * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\n   * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\n   * @param {Function} cb - optional callback function to be called on completion.\n   * @private\n   */\n  _setBreakPoints(elemHeight, cb) {\n    if (!this.canStick) {\n      if (cb && typeof cb === 'function') { cb(); }\n      else { return false; }\n    }\n    var mTop = emCalc(this.options.marginTop),\n        mBtm = emCalc(this.options.marginBottom),\n        topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\n        bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\n        // topPoint = this.$anchor.offset().top || this.points[0],\n        // bottomPoint = topPoint + this.anchorHeight || this.points[1],\n        winHeight = window.innerHeight;\n\n    if (this.options.stickTo === 'top') {\n      topPoint -= mTop;\n      bottomPoint -= (elemHeight + mTop);\n    } else if (this.options.stickTo === 'bottom') {\n      topPoint -= (winHeight - (elemHeight + mBtm));\n      bottomPoint -= (winHeight - mBtm);\n    } else {\n      //this would be the stickTo: both option... tricky\n    }\n\n    this.topPoint = topPoint;\n    this.bottomPoint = bottomPoint;\n\n    if (cb && typeof cb === 'function') { cb(); }\n  }\n\n  /**\n   * Destroys the current sticky element.\n   * Resets the element to the top position first.\n   * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\n   * @function\n   */\n  _destroy() {\n    this._removeSticky(true);\n\n    this.$element.removeClass(`${this.options.stickyClass} is-anchored is-at-top`)\n                 .css({\n                   height: '',\n                   top: '',\n                   bottom: '',\n                   'max-width': ''\n                 })\n                 .off('resizeme.zf.trigger')\n                 .off('mutateme.zf.trigger');\n    if (this.$anchor && this.$anchor.length) {\n      this.$anchor.off('change.zf.sticky');\n    }\n    $(window).off(this.scrollListener);\n\n    if (this.wasWrapped) {\n      this.$element.unwrap();\n    } else {\n      this.$container.removeClass(this.options.containerClass)\n                     .css({\n                       height: ''\n                     });\n    }\n  }\n}\n\nSticky.defaults = {\n  /**\n   * Customizable container template. Add your own classes for styling and sizing.\n   * @option\n   * @type {string}\n   * @default '&lt;div data-sticky-container&gt;&lt;/div&gt;'\n   */\n  container: '<div data-sticky-container></div>',\n  /**\n   * Location in the view the element sticks to. Can be `'top'` or `'bottom'`.\n   * @option\n   * @type {string}\n   * @default 'top'\n   */\n  stickTo: 'top',\n  /**\n   * If anchored to a single element, the id of that element.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  anchor: '',\n  /**\n   * If using more than one element as anchor points, the id of the top anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  topAnchor: '',\n  /**\n   * If using more than one element as anchor points, the id of the bottom anchor.\n   * @option\n   * @type {string}\n   * @default ''\n   */\n  btmAnchor: '',\n  /**\n   * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */\n  marginTop: 1,\n  /**\n   * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\n   * @option\n   * @type {number}\n   * @default 1\n   */\n  marginBottom: 1,\n  /**\n   * Breakpoint string that is the minimum screen size an element should become sticky.\n   * @option\n   * @type {string}\n   * @default 'medium'\n   */\n  stickyOn: 'medium',\n  /**\n   * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\n   * @option\n   * @type {string}\n   * @default 'sticky'\n   */\n  stickyClass: 'sticky',\n  /**\n   * Class applied to sticky container. Foundation defaults to `sticky-container`.\n   * @option\n   * @type {string}\n   * @default 'sticky-container'\n   */\n  containerClass: 'sticky-container',\n  /**\n   * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\n   * @option\n   * @type {number}\n   * @default -1\n   */\n  checkEvery: -1\n};\n\n/**\n * Helper function to calculate em values\n * @param Number {em} - number of em's to calculate into pixels\n */\nfunction emCalc(em) {\n  return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\n}\n\nexport {Sticky};\n"]},"hash":"471984c99201b9b6eba8c59b96fb09cd789df8ec"}
