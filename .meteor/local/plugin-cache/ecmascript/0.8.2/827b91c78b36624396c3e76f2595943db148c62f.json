{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","filenameRelative":"packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js.map","sourceFileName":"packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"Data"},"ignored":false,"code":"define([\"../core\", \"../var/rnotwhite\", \"./accepts\"], function (jQuery, rnotwhite) {\n\tfunction Data() {\n\t\t// Support: Android<4,\n\t\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t\t// return new empty object instead with no [[set]] accessor\n\t\tObject.defineProperty(this.cache = {}, 0, {\n\t\t\tget: function () {\n\t\t\t\treturn {};\n\t\t\t}\n\t\t});\n\t\tthis.expando = jQuery.expando + Data.uid++;\n\t}\n\n\tData.uid = 1;\n\tData.accepts = jQuery.acceptData;\n\tData.prototype = {\n\t\tkey: function (owner) {\n\t\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t\t// but we should not, see #8335.\n\t\t\t// Always return the key for a frozen object.\n\t\t\tif (!Data.accepts(owner)) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tvar descriptor = {},\n\t\t\t    // Check if the owner object already has a cache key\n\t\t\tunlock = owner[this.expando]; // If not, create one\n\n\t\t\tif (!unlock) {\n\t\t\t\tunlock = Data.uid++; // Secure it in a non-enumerable, non-writable property\n\n\t\t\t\ttry {\n\t\t\t\t\tdescriptor[this.expando] = {\n\t\t\t\t\t\tvalue: unlock\n\t\t\t\t\t};\n\t\t\t\t\tObject.defineProperties(owner, descriptor); // Support: Android<4\n\t\t\t\t\t// Fallback to a less secure definition\n\t\t\t\t} catch (e) {\n\t\t\t\t\tdescriptor[this.expando] = unlock;\n\t\t\t\t\tjQuery.extend(owner, descriptor);\n\t\t\t\t}\n\t\t\t} // Ensure the cache object\n\n\n\t\t\tif (!this.cache[unlock]) {\n\t\t\t\tthis.cache[unlock] = {};\n\t\t\t}\n\n\t\t\treturn unlock;\n\t\t},\n\t\tset: function (owner, data, value) {\n\t\t\tvar prop,\n\t\t\t    // There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key(owner),\n\t\t\t    cache = this.cache[unlock]; // Handle: [ owner, key, value ] args\n\n\t\t\tif (typeof data === \"string\") {\n\t\t\t\tcache[data] = value; // Handle: [ owner, { properties } ] args\n\t\t\t} else {\n\t\t\t\t// Fresh assignments by object are shallow copied\n\t\t\t\tif (jQuery.isEmptyObject(cache)) {\n\t\t\t\t\tjQuery.extend(this.cache[unlock], data); // Otherwise, copy the properties one-by-one to the cache object\n\t\t\t\t} else {\n\t\t\t\t\tfor (prop in meteorBabelHelpers.sanitizeForInObject(data)) {\n\t\t\t\t\t\tcache[prop] = data[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn cache;\n\t\t},\n\t\tget: function (owner, key) {\n\t\t\t// Either a valid cache is found, or will be created.\n\t\t\t// New caches will be created and the unlock returned,\n\t\t\t// allowing direct access to the newly created\n\t\t\t// empty data object. A valid owner object must be provided.\n\t\t\tvar cache = this.cache[this.key(owner)];\n\t\t\treturn key === undefined ? cache : cache[key];\n\t\t},\n\t\taccess: function (owner, key, value) {\n\t\t\tvar stored; // In cases where either:\n\t\t\t//\n\t\t\t//   1. No key was specified\n\t\t\t//   2. A string key was specified, but no value provided\n\t\t\t//\n\t\t\t// Take the \"read\" path and allow the get method to determine\n\t\t\t// which value to return, respectively either:\n\t\t\t//\n\t\t\t//   1. The entire cache object\n\t\t\t//   2. The data stored at the key\n\t\t\t//\n\n\t\t\tif (key === undefined || key && typeof key === \"string\" && value === undefined) {\n\t\t\t\tstored = this.get(owner, key);\n\t\t\t\treturn stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));\n\t\t\t} // [*]When the key is not a string, or both a key and value\n\t\t\t// are specified, set or extend (existing objects) with either:\n\t\t\t//\n\t\t\t//   1. An object of properties\n\t\t\t//   2. A key and value\n\t\t\t//\n\n\n\t\t\tthis.set(owner, key, value); // Since the \"set\" path can have two possible entry points\n\t\t\t// return the expected data based on which path was taken[*]\n\n\t\t\treturn value !== undefined ? value : key;\n\t\t},\n\t\tremove: function (owner, key) {\n\t\t\tvar i,\n\t\t\t    name,\n\t\t\t    camel,\n\t\t\t    unlock = this.key(owner),\n\t\t\t    cache = this.cache[unlock];\n\n\t\t\tif (key === undefined) {\n\t\t\t\tthis.cache[unlock] = {};\n\t\t\t} else {\n\t\t\t\t// Support array or space separated string of keys\n\t\t\t\tif (jQuery.isArray(key)) {\n\t\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\t\tname = key.concat(key.map(jQuery.camelCase));\n\t\t\t\t} else {\n\t\t\t\t\tcamel = jQuery.camelCase(key); // Try the string as a key before any manipulation\n\n\t\t\t\t\tif (key in cache) {\n\t\t\t\t\t\tname = [key, camel];\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\t\tname = camel;\n\t\t\t\t\t\tname = name in cache ? [name] : name.match(rnotwhite) || [];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\ti = name.length;\n\n\t\t\t\twhile (i--) {\n\t\t\t\t\tdelete cache[name[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\thasData: function (owner) {\n\t\t\treturn !jQuery.isEmptyObject(this.cache[owner[this.expando]] || {});\n\t\t},\n\t\tdiscard: function (owner) {\n\t\t\tif (owner[this.expando]) {\n\t\t\t\tdelete this.cache[owner[this.expando]];\n\t\t\t}\n\t\t}\n\t};\n\treturn Data;\n});","map":{"version":3,"sources":["packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js"],"names":["define","jQuery","rnotwhite","Data","Object","defineProperty","cache","get","expando","uid","accepts","acceptData","prototype","key","owner","descriptor","unlock","value","defineProperties","e","extend","set","data","prop","isEmptyObject","undefined","access","stored","camelCase","remove","i","name","camel","isArray","concat","map","match","length","hasData","discard"],"mappings":"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","file":"packages/zurb:foundation-sites/vendor/jquery/src/data/Data.js.map","sourcesContent":["define([\n\t\"../core\",\n\t\"../var/rnotwhite\",\n\t\"./accepts\"\n], function( jQuery, rnotwhite ) {\n\nfunction Data() {\n\t// Support: Android<4,\n\t// Old WebKit does not have Object.preventExtensions/freeze method,\n\t// return new empty object instead with no [[set]] accessor\n\tObject.defineProperty( this.cache = {}, 0, {\n\t\tget: function() {\n\t\t\treturn {};\n\t\t}\n\t});\n\n\tthis.expando = jQuery.expando + Data.uid++;\n}\n\nData.uid = 1;\nData.accepts = jQuery.acceptData;\n\nData.prototype = {\n\tkey: function( owner ) {\n\t\t// We can accept data for non-element nodes in modern browsers,\n\t\t// but we should not, see #8335.\n\t\t// Always return the key for a frozen object.\n\t\tif ( !Data.accepts( owner ) ) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tvar descriptor = {},\n\t\t\t// Check if the owner object already has a cache key\n\t\t\tunlock = owner[ this.expando ];\n\n\t\t// If not, create one\n\t\tif ( !unlock ) {\n\t\t\tunlock = Data.uid++;\n\n\t\t\t// Secure it in a non-enumerable, non-writable property\n\t\t\ttry {\n\t\t\t\tdescriptor[ this.expando ] = { value: unlock };\n\t\t\t\tObject.defineProperties( owner, descriptor );\n\n\t\t\t// Support: Android<4\n\t\t\t// Fallback to a less secure definition\n\t\t\t} catch ( e ) {\n\t\t\t\tdescriptor[ this.expando ] = unlock;\n\t\t\t\tjQuery.extend( owner, descriptor );\n\t\t\t}\n\t\t}\n\n\t\t// Ensure the cache object\n\t\tif ( !this.cache[ unlock ] ) {\n\t\t\tthis.cache[ unlock ] = {};\n\t\t}\n\n\t\treturn unlock;\n\t},\n\tset: function( owner, data, value ) {\n\t\tvar prop,\n\t\t\t// There may be an unlock assigned to this node,\n\t\t\t// if there is no entry for this \"owner\", create one inline\n\t\t\t// and set the unlock as though an owner entry had always existed\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\t// Handle: [ owner, key, value ] args\n\t\tif ( typeof data === \"string\" ) {\n\t\t\tcache[ data ] = value;\n\n\t\t// Handle: [ owner, { properties } ] args\n\t\t} else {\n\t\t\t// Fresh assignments by object are shallow copied\n\t\t\tif ( jQuery.isEmptyObject( cache ) ) {\n\t\t\t\tjQuery.extend( this.cache[ unlock ], data );\n\t\t\t// Otherwise, copy the properties one-by-one to the cache object\n\t\t\t} else {\n\t\t\t\tfor ( prop in data ) {\n\t\t\t\t\tcache[ prop ] = data[ prop ];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn cache;\n\t},\n\tget: function( owner, key ) {\n\t\t// Either a valid cache is found, or will be created.\n\t\t// New caches will be created and the unlock returned,\n\t\t// allowing direct access to the newly created\n\t\t// empty data object. A valid owner object must be provided.\n\t\tvar cache = this.cache[ this.key( owner ) ];\n\n\t\treturn key === undefined ?\n\t\t\tcache : cache[ key ];\n\t},\n\taccess: function( owner, key, value ) {\n\t\tvar stored;\n\t\t// In cases where either:\n\t\t//\n\t\t//   1. No key was specified\n\t\t//   2. A string key was specified, but no value provided\n\t\t//\n\t\t// Take the \"read\" path and allow the get method to determine\n\t\t// which value to return, respectively either:\n\t\t//\n\t\t//   1. The entire cache object\n\t\t//   2. The data stored at the key\n\t\t//\n\t\tif ( key === undefined ||\n\t\t\t\t((key && typeof key === \"string\") && value === undefined) ) {\n\n\t\t\tstored = this.get( owner, key );\n\n\t\t\treturn stored !== undefined ?\n\t\t\t\tstored : this.get( owner, jQuery.camelCase(key) );\n\t\t}\n\n\t\t// [*]When the key is not a string, or both a key and value\n\t\t// are specified, set or extend (existing objects) with either:\n\t\t//\n\t\t//   1. An object of properties\n\t\t//   2. A key and value\n\t\t//\n\t\tthis.set( owner, key, value );\n\n\t\t// Since the \"set\" path can have two possible entry points\n\t\t// return the expected data based on which path was taken[*]\n\t\treturn value !== undefined ? value : key;\n\t},\n\tremove: function( owner, key ) {\n\t\tvar i, name, camel,\n\t\t\tunlock = this.key( owner ),\n\t\t\tcache = this.cache[ unlock ];\n\n\t\tif ( key === undefined ) {\n\t\t\tthis.cache[ unlock ] = {};\n\n\t\t} else {\n\t\t\t// Support array or space separated string of keys\n\t\t\tif ( jQuery.isArray( key ) ) {\n\t\t\t\t// If \"name\" is an array of keys...\n\t\t\t\t// When data is initially created, via (\"key\", \"val\") signature,\n\t\t\t\t// keys will be converted to camelCase.\n\t\t\t\t// Since there is no way to tell _how_ a key was added, remove\n\t\t\t\t// both plain key and camelCase key. #12786\n\t\t\t\t// This will only penalize the array argument path.\n\t\t\t\tname = key.concat( key.map( jQuery.camelCase ) );\n\t\t\t} else {\n\t\t\t\tcamel = jQuery.camelCase( key );\n\t\t\t\t// Try the string as a key before any manipulation\n\t\t\t\tif ( key in cache ) {\n\t\t\t\t\tname = [ key, camel ];\n\t\t\t\t} else {\n\t\t\t\t\t// If a key with the spaces exists, use it.\n\t\t\t\t\t// Otherwise, create an array by matching non-whitespace\n\t\t\t\t\tname = camel;\n\t\t\t\t\tname = name in cache ?\n\t\t\t\t\t\t[ name ] : ( name.match( rnotwhite ) || [] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ti = name.length;\n\t\t\twhile ( i-- ) {\n\t\t\t\tdelete cache[ name[ i ] ];\n\t\t\t}\n\t\t}\n\t},\n\thasData: function( owner ) {\n\t\treturn !jQuery.isEmptyObject(\n\t\t\tthis.cache[ owner[ this.expando ] ] || {}\n\t\t);\n\t},\n\tdiscard: function( owner ) {\n\t\tif ( owner[ this.expando ] ) {\n\t\t\tdelete this.cache[ owner[ this.expando ] ];\n\t\t}\n\t}\n};\n\nreturn Data;\n});\n"]},"hash":"827b91c78b36624396c3e76f2595943db148c62f"}
